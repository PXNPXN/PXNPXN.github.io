<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android错误</title>
    <url>/2020/04/12/Android%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>Android Studio报错：Caused by: org.gradle.api.resources.ResourceException: Could not get resource </p>
<a id="more"></a>

<p>Android Studio版本号：3.6</p>
<p>解决办法：把原有build配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">   repositories&#123;</span><br><span class="line">      jcenter()</span><br><span class="line">      google()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">allprojects</span>&#123;</span><br><span class="line">   <span class="variable">repositories</span>&#123;</span><br><span class="line">      <span class="comment">//新加</span></span><br><span class="line">      <span class="function"><span class="title">mavenCentral</span>()</span></span><br><span class="line">      <span class="function"><span class="title">mavenLocal</span>()</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="title">jcenter</span>()</span></span><br><span class="line">      <span class="function"><span class="title">google</span>()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后更新build文件，rebuild后，该错误消失。</p>
<p>据了解jcenter()和mavenCentral()是Android Studio中Gradle插件使用的仓库。Android Studio早期版本使用的是MavenCentral，从某个时候开始切换到jcenter了，也就是说，项目之所以报错，是因为该项目的Android Studio是早期的版本。之所以使用jcenter在性能和占存储大小方面比mavenCentral更优：</p>
<ol>
<li>jcenter 是世界上最大的java仓库</li>
<li>jcenter通过CDN服务，使用的是https协议，安全性更高，而Android Studio 0.8版本mavenCentral使用的是http协议</li>
<li>jcenter是mavenCentral的超集，包括许多额外的仓库</li>
<li>jcenter性能方面比mavenCentral更优</li>
<li>mavenCentral会自动下载很多与IDE相关的index，而这些用到的少，且不是必需</li>
</ol>
<p>而mavenLocal则是用来指定本地仓库路径的，使用mavenLocal就是默认本地路径。若是自定义本地路径，则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">   maven&#123;url <span class="string">'D://Users/user2/.m2/repository'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML元素--1</title>
    <url>/2020/04/06/HTML%E5%85%83%E7%B4%A01/</url>
    <content><![CDATA[<h1 id="HTML元素小记–ol-ul-dl-table"><a href="#HTML元素小记–ol-ul-dl-table" class="headerlink" title="HTML元素小记–ol-ul-dl-table"></a>HTML元素小记–ol-ul-dl-table</h1><a id="more"></a>

<p>可能这些东西对某些大佬老说已经非常熟悉了，但是作为小白的我，依旧需要记录一下，毕竟web前端不是经常用，而且写博客也是催促自己学习的一种方式，若某天大佬看了，请自动忽略本文。只供自己学习用，请勿嘲笑。</p>
<h2 id="1-无序列表标签–ul"><a href="#1-无序列表标签–ul" class="headerlink" title="1. 无序列表标签–ul"></a>1. 无序列表标签–ul</h2><ul>是无序的列表标签，无序嘛，就是列表中的内容是没有顺序的。无序列表中的每一项是<li>

<p>所有主流浏览器都支持ul标签。</p>
<p> 英文单词解释：</p>
<pre><code>*ul: unordered list, &quot;无序列表&quot;

*li: list item, &quot;列表项&quot;</code></pre><p>例如(示例使用了Vue框架，使用时请自行引入Vue框架文件)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ex1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"text in texts"</span>&gt;</span></span><br><span class="line">                &#123;&#123;text.node&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ex1=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#ex1'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            text:[</span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'苹果'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'梨'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'草莓'</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器效果如下：</p>
<ul>
<li>苹果</li>
<li>梨</li>
<li>草莓</li>
</ul>
<hr>
<p>属性：</p>
<ul>
<li>type=”属性值”。属性值可选: disc(实心原点，默认), square(实心方点)，circle(空心圆)</li>
</ul>
<hr>
<p>注意：</p>
<ul>
<li>注意li不能单独使用，且ul标签中的”儿子标签”只能是 li .</li>
<li>ul的作用：是增加无序列表的”语义”的。</li>
<li>li 是一个容器标签，可以放其他的标签元素，甚至是ul</li>
<li>这里就不比较HTML和XHTML之间的差异了，如果需要请自行到<a href="https://www.w3school.com.cn/tags/tag_ul.asp" target="_blank" rel="noopener">W3school</a>查看</li>
</ul>
<hr>
<p>ul 标签可以多层复杂嵌套：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>水果<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>鲜花<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>玫瑰花</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>红玫瑰<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>白玫瑰<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>康乃馨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>杜鹃花<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>丁香花<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>应用场景：</p>
<ul>
<li>导航栏</li>
<li>类似于购物清单列表</li>
</ul>
<hr>
<h2 id="2-有序列表-–ol-里面的每一项是–-li"><a href="#2-有序列表-–ol-里面的每一项是–-li" class="headerlink" title="2. 有序列表 –ol,  里面的每一项是– li"></a>2. 有序列表 –ol,  里面的每一项是– li</h2><p>所有主流浏览器都支持ol标签。</p>
<p>英文单词：</p>
<p>ol :  Ordered List.</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ex2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">                &#123;&#123;todo.text&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#ex2'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            todos:[</span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'苹果'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'梨'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'草莓'</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>演示效果如下：</p>
<ol start="50">
<li>苹果</li>
<li>梨</li>
<li>草莓</li>
</ol>
<hr>
<p>属性：</p>
<ul>
<li>reversed ：规定列表顺序为降序。(9,8,7…) 默认是顺序。</li>
<li>start ：规定有序列的起始值。</li>
<li>type ：规定在列表中使用的标记类型。如：(1, A ,a ,I ,i ).</li>
</ul>
<hr>
<p>ol也可以多层嵌套。</p>
<h2 id="3-定义列表-–dl"><a href="#3-定义列表-–dl" class="headerlink" title="3. 定义列表 –dl"></a>3. 定义列表 –dl</h2><p>dl英文单词：definition list，没有属性。dl的子元素只能是dt和dd。</p>
<p>dt : definition title列表的标题，这个标签是必须的。</p>
<p>dd ：definition description 列表的列表项，如果不需要它，可以不加。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第一天<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>跑步<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>写代码<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第二天<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>陪老婆<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>画画<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>做饭<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以这样使用dl</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>购物指南<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>购物流程<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>会员介绍<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>生活旅行/团购<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>常见问题<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>大家电<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>联系客服<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>配送方式<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>上门自提<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>211限时达<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>配送服务查询<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>配送费收取标准<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>海外配送<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-表格标签–table"><a href="#4-表格标签–table" class="headerlink" title="4. 表格标签–table"></a>4. 表格标签–table</h2><p>一个表格table是由每行tr组成的，每行是由td组成的。即一个表格是由行组成的，每行又是由列组成的。</p>
<p>例如，3行4列的单元格：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>生命壹号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>黄冈<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>许嵩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>29<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>邓紫棋<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>香港<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上图表格中是没有边框的。因此需要设置table的属性：</p>
<p>table的属性：</p>
<ul>
<li>border：边框。像素为单位。</li>
<li>style=“border-collapse:collapse；”      ：单元格的线和表格的边框合并</li>
<li>width：宽度。px为单位。</li>
<li>height：高度。px为单位。</li>
<li>bordercolor：表格的边框颜色。</li>
<li>align：表格的水平对齐方式。属性值可以填：left right cente。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签td进行设置)</li>
<li>cellpadding : 单元格内容到边的距离，像素为单位。默认情况下指最左侧那条边。如果设置属性 dir=”rtl”, 那就指的是内容到最右边那条线的距离。</li>
<li>cellspacing ：单元格和单元格之间的距离(外边距)，px为单位。默认情况下对的值为0.</li>
<li>bgcolor=”#99cc66”：表格的背景颜色。</li>
<li>background=”路径src/…”：背景图片。</li>
<li>bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色。</li>
<li>bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色。这两个属性的目的是为了设置3D的效果。</li>
<li>dir：公有属性，单元格内容的排列方式。可以取值：ltr：从左到右(默认)，rtl：从右到左。既然说dir是公有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。</li>
</ul>
<hr>
<p>对于<tr>：行</p>
<p>属性：</p>
<ul>
<li><p>dir：公有属性，设置一行单元格内容的排列方式。具体上面讲过。</p>
</li>
<li><p>bgcolor：设置一行单元格的背景颜色。</p>
</li>
<li><p>height：一行单元格的高度。</p>
</li>
<li><p>align=”center”：一行的内容水平居中显示，取值：left、center、right。</p>
</li>
<li><p>valign=”center”：一行内容垂直居中，取值：top、middler、bottom。</p>
<p>注：th：加粗的单元格。相当于td+b 属性同td标签一样。使用时和tr标签并列。</p>
<hr>
<p>表格的thead标签、tbody标签、tfoot标签</p>
<p>当浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候从按照代码的从上到下的顺序来显示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML小记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-泛型</title>
    <url>/2020/05/02/Kotlin-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kotlin函数与函数式编程</title>
    <url>/2020/04/23/Kotlin%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Kotlin函数与函数式编程"><a href="#Kotlin函数与函数式编程" class="headerlink" title="Kotlin函数与函数式编程"></a>Kotlin函数与函数式编程</h1><a id="more"></a>

<h2 id="1-函数式编程与命令式编程"><a href="#1-函数式编程与命令式编程" class="headerlink" title="1. 函数式编程与命令式编程"></a>1. 函数式编程与命令式编程</h2><p>函数式编程与命令式编程最大的不同是：函数式编程的焦点在于数据的映射，命令式编程(imperative programming)的焦点是解决问题的步骤。</p>
<p>函数式编程的本质是函数的组合。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    println(list.filter&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;)   <span class="comment">//过滤函数，参数是一个Lambda表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-函数式编程的特点："><a href="#1-1-函数式编程的特点：" class="headerlink" title="1.1 函数式编程的特点："></a>1.1 函数式编程的特点：</h3><p>函数式编程简单、自然、直观易懂且美丽、“优雅”的编程风格。函数式编程语言中通常都会提供常用的map、reduce、filter等基本函数，这些函数是对List、Map集合等基本数据结构的常用操作的高层次封装，就像一个更加智能、好用的工具箱。</p>
<hr>
<h2 id="2-函数式编程简介"><a href="#2-函数式编程简介" class="headerlink" title="2. 函数式编程简介"></a>2. 函数式编程简介</h2><p>函数式编程是关于不变性和函数组合的编程范式。函数式编程有如下特征：</p>
<ul>
<li>一等函数支持(first-class function)：函数也是一种数据类型，可以作为参数传入另一个函数中，同时函数也可以返回一个函数。</li>
<li>纯函数(pure function)和不变性(immutable)：纯函数值指的是没有副作用的函数(函数不去改变外部的数据状态)。例如，一个编译器就是一个广义上的纯函数。在函数式编程中。正因为纯函数不会去修改数据，同时又使用不可变的数据，所以程序不会去修改一个已经存在的数据结构，而是根据一定的映射逻辑创建一份新的数据。函数式编程是转换数据而非修改原始数据。</li>
<li>函数的组合(compose function)：在面向对象编程中是通过对象之间发送消息来构建程序逻辑的；</li>
</ul>
<p>而在函数式编程中是通过不同函数的组合来构建程序逻辑的。</p>
<hr>
<h2 id="3-声明函数"><a href="#3-声明函数" class="headerlink" title="3. 声明函数"></a>3. 声明函数</h2><p>Kotlin中使用fun关键字声明函数为了更加直观地表现函数也可以当做变量来使用、声明一个函数类型的变量sum</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>&#123;<span class="keyword">return</span> x+y&#125;  <span class="comment">//sum的类型是一个函数类型的变量</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    &#125;</span><br><span class="line">    println(sum)   <span class="comment">//打印 (kotlin.Int, kotlin.Int) -&gt; kotlin.Int，表面sum是一个函数类型变量</span></span><br><span class="line">    <span class="comment">//这个带箭头 “-&gt;”的表达式就是一个函数类型表示一个输入两个Int类型值、输出一个Int类型值的函数</span></span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"x+y="</span>+sum(<span class="number">1</span>,<span class="number">3</span>))    <span class="comment">//打印  x+y=4</span></span><br><span class="line">    <span class="keyword">val</span> temp=sum(<span class="number">1</span>,<span class="number">5</span>)     <span class="comment">//调用sum函数，将返回值赋值给temp变量</span></span><br><span class="line">    println(temp)    <span class="comment">//打印结果   6</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Lambda表达式"><a href="#4-Lambda表达式" class="headerlink" title="4. Lambda表达式"></a>4. Lambda表达式</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">list.filter&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里的filter()函数的入参{it%2==1}就是一段Lambda表达式。因为filter()函数只有一个参数，所以括号被省略了。因此，filter()函数调用的完整写法是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.filter(&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>filter()函数的入参是一个函数 predicate:(T)-&gt;Boolean</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;   <span class="comment">//简写的Lambda表达式</span></span><br></pre></td></tr></table></figure>

<p>是一种简写的语法，完整的Lambda表达式是这样写的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;it-&gt;it%<span class="number">2</span>==<span class="number">1</span>&#125;    <span class="comment">//实际的Lambda表达式</span></span><br></pre></td></tr></table></figure>

<p>如果拆开来写，就更加容易理解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line"> <span class="keyword">val</span> isOdd=&#123;it:<span class="built_in">Int</span>-&gt;it%<span class="number">2</span>==<span class="number">1</span>&#125;  <span class="comment">//直接使用Lambda表达式声明一个函数，这个函数判断输入的Int是不是奇数</span></span><br><span class="line">    println(isOdd)            <span class="comment">//打印结果： (kotlin.Int) -&gt; kotlin.Boolean</span></span><br><span class="line">    <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    println(list.filter(isOdd))  <span class="comment">//直接传入isOdd函数 打印结果： [1, 3, 5, 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-高阶函数"><a href="#5-高阶函数" class="headerlink" title="5. 高阶函数"></a>5. 高阶函数</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> strList=listOf(<span class="string">"a"</span>,<span class="string">"ab"</span>,<span class="string">"abc"</span>,<span class="string">"abcd"</span>,<span class="string">"abcde"</span>,<span class="string">"abcdef"</span>,<span class="string">"abcdefg"</span>)</span><br><span class="line"><span class="keyword">val</span> f=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>)</span></span>=x%<span class="number">2</span>==<span class="number">1</span>        <span class="comment">//判断输入的Int是否奇数</span></span><br><span class="line"><span class="keyword">val</span> g=<span class="function"><span class="title">fun</span><span class="params">(s:<span class="type">String</span>)</span></span>=s.length   <span class="comment">//返回输入的字符串参数的长度</span></span><br><span class="line"><span class="keyword">val</span> h=<span class="function"><span class="title">fun</span><span class="params">(g:(<span class="type">String</span>)-&gt;<span class="type">Int</span>,f:(<span class="type">Int</span>)-&gt;<span class="type">Boolean</span>:(<span class="type">String</span>)-&gt;<span class="type">Boolean</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;f(g(it))&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个h函数的声明有些长了，尤其是3个函数类型声明的箭头表达式，显得不够简洁。不过不用担心，Kotlin中有简单好用的Kotlin类型别名，我们使用G、F、H来声明3个函数类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> G=(String)-&gt;<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">typealias</span> F=(<span class="built_in">Int</span>)-&gt;<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">typealias</span> H=(String)-&gt;<span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> h=<span class="function"><span class="title">fun</span><span class="params">(g:<span class="type">G</span>,f:<span class="type">F</span>)</span></span>:H&#123;</span><br><span class="line">   <span class="keyword">return</span>&#123; f(g(it))&#125;   <span class="comment">//需要注意的是，这里的&#123;&#125;是不能省略的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个h函数的映射关系可用下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JBVycQ.jpg" alt="img"></p>
<p>在函数体的代码 return{f(g(it))} 中，{}代表这是一个Lambda表达式。返回的是一个(String)-&gt;Boolean函数类型。如果没有{},那么返回值就是一个布尔类型Boolean了。</p>
<p>综合该例子为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>)</span></span>=x%<span class="number">2</span>==<span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> g=<span class="function"><span class="title">fun</span><span class="params">(s:<span class="type">String</span>)</span></span>=s.length</span><br><span class="line"><span class="keyword">typealias</span> G=(String)-&gt;<span class="built_in">Int</span>      <span class="comment">//typealias--Kotlin类型别名的关键字，声明时应放在main函数之外</span></span><br><span class="line"><span class="keyword">typealias</span> F=(<span class="built_in">Int</span>)-&gt;<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">typealias</span> H=(String)-&gt;<span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> h=<span class="function"><span class="title">fun</span><span class="params">(g:<span class="type">G</span>,f:<span class="type">F</span>)</span></span>:H&#123;      <span class="comment">//高阶函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123;f(g(it))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=listOf(<span class="string">"a"</span>,<span class="string">"ab"</span>,<span class="string">"abc"</span>,<span class="string">"abcd"</span>,<span class="string">"abcde"</span>,<span class="string">"abcdef"</span>,<span class="string">"abcdefg"</span>)</span><br><span class="line">   println(list.filter(h(g,f)))     <span class="comment">//打印结果为：[a, abc, abcde, abcdefg]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-Kotlin中的特殊函数"><a href="#6-Kotlin中的特殊函数" class="headerlink" title="6. Kotlin中的特殊函数"></a>6. Kotlin中的特殊函数</h2><p>我们介绍Kotlin中的run()、apply()、let()、also()和with()这5个特殊的函数。</p>
<h3 id="6-1-run-函数"><a href="#6-1-run-函数" class="headerlink" title="6.1 run()函数"></a>6.1 run()函数</h3><p>run()函数的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block:()-&gt;<span class="type">R</span>)</span></span>:R&#123;</span><br><span class="line">     contract&#123;</span><br><span class="line">        callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行代码block()，其实就是调用传入的block参数，一般情况下是一个Lambda代码块。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myfun</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">   println(<span class="string">"执行了myfun函数"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"这是myfun的返回值"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testRunFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  myfun()           <span class="comment">//直接在代码行调用函数</span></span><br><span class="line">  run(&#123;myfun()&#125;)    <span class="comment">//使用run()函数调用myfun()函数</span></span><br><span class="line">  run&#123;myfun()&#125;      <span class="comment">//run()函数的括号“()”可以省略，因为只有一个参数</span></span><br><span class="line">  run&#123;println(<span class="string">"A"</span>)&#125; <span class="comment">//等价于println("A")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">执行了myfun函数</span></span><br><span class="line"><span class="comment">执行了myfun函数</span></span><br><span class="line"><span class="comment">执行了myfun函数</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-2-apply-函数"><a href="#6-2-apply-函数" class="headerlink" title="6.2  apply()函数"></a>6.2  apply()函数</h3><p>apply()函数的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span>T.<span class="title">apply</span><span class="params">(block:<span class="type">T</span>.()-&gt;<span class="type">Unit</span>():<span class="type">T</span>)</span></span>&#123;</span><br><span class="line">    contract&#123;</span><br><span class="line">      callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后两行代码，先是调用了block()函数，然后返回当前的调用者对象this。意思是执行完block()代码块逻辑后，再次返回当前的调用者对象。测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testApply</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=mutableListOf&lt;String&gt;()</span><br><span class="line">   list.add(<span class="string">"A"</span>)</span><br><span class="line">   list.add(<span class="string">"B"</span>)</span><br><span class="line">   list.add(<span class="string">"C"</span>)</span><br><span class="line">   println(<span class="string">"普通写法list=<span class="variable">$list</span>"</span>)   <span class="comment">//普通写法    打印结果普通写法list=[A,B,C]</span></span><br><span class="line">   println(list)                  <span class="comment">//打印 [A,B,C]</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用apply()函数的写法</span></span><br><span class="line">   <span class="keyword">val</span> a =ArrayList&lt;String&gt;().apply()&#123;    <span class="comment">//这里的调用者是AR让List数组</span></span><br><span class="line">        add(<span class="string">"A"</span>)</span><br><span class="line">        add(<span class="string">"B"</span>)</span><br><span class="line">        add(<span class="string">"C"</span>)</span><br><span class="line">       println(<span class="string">"使用apply函数写法this=<span class="variable">$this</span>"</span>)  <span class="comment">//使用apply函数写法this=[A,B,C]</span></span><br><span class="line">   &#125;</span><br><span class="line">    println(a)    <span class="comment">//打印[A,B,C]</span></span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    a.let&#123;println(it)&#125;  <span class="comment">//打印[A,B,C]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testApply()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-let-函数"><a href="#6-3-let-函数" class="headerlink" title="6.3  let()函数"></a>6.3  let()函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T,R&gt;</span>T.<span class="title">let</span><span class="params">(block:(<span class="type">T</span>)-&gt;<span class="type">R</span>)</span></span>:R&#123;</span><br><span class="line">   contract&#123;</span><br><span class="line">       callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是重点看最后一行代码block(this)，意思是把当前调用对象作为参数传入block()代码块中。测试代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myfun</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">   println(<span class="string">"执行了myfun函数"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"这是myfun的返回值"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLetFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="number">1</span>.let&#123;println(it)&#125;    <span class="comment">//输出1，其中it就是调用者1</span></span><br><span class="line">   <span class="string">"ABC"</span>.let&#123;println(it)&#125;  <span class="comment">//输出ABC，其中it就是调用者ABC</span></span><br><span class="line">   <span class="comment">//执行完函数myfun()，返回值传给let()函数</span></span><br><span class="line">   myfun().let&#123;          <span class="comment">//执行了myfun函数</span></span><br><span class="line">      println(it)        <span class="comment">//it是myfun()函数--这是myfun的返回值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   testLetFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-also-函数"><a href="#6-4-also-函数" class="headerlink" title="6.4  also()函数"></a>6.4  also()函数</h3><p>also()函数的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span>T.<span class="title">also</span><span class="params">(block:(<span class="type">T</span>)-&gt;<span class="type">Unit</span>)</span></span>:T&#123;</span><br><span class="line">   contract&#123;</span><br><span class="line">      callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">   &#125;</span><br><span class="line">   block(<span class="keyword">this</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是看最后两句，首先是调用了block(this)，类似let()函数的逻辑，但是最后返回的值是this，也就是当前的调用者。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testAlsoFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> a=<span class="string">"ABC"</span>.also&#123;</span><br><span class="line">       println(it)  <span class="comment">//输出：ABC</span></span><br><span class="line">   &#125;</span><br><span class="line">   println(a)   <span class="comment">//输出：ABC</span></span><br><span class="line">   a.let&#123;</span><br><span class="line">      println(it)  <span class="comment">//输出：ABC</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   testAlsoFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>6.5  with()函数</p>
<p>with()函数的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T,R&gt;</span><span class="title">with</span><span class="params">(receiver:<span class="type">T</span>,block:<span class="type">T</span>.()-&gt;<span class="type">R</span>)</span></span>:R&#123;</span><br><span class="line">    contract&#123;</span><br><span class="line">        callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with()函数传入了一个接受者对象receiver，然后使用该对象receiver去调用传入的Lambda代码块receiver.block()，测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWithFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=mutableListOf&lt;String&gt;()</span><br><span class="line">   list.add(<span class="string">"A"</span>)</span><br><span class="line">   list.add(<span class="string">"B"</span>)</span><br><span class="line">   list.add(<span class="string">"C"</span>)</span><br><span class="line">   println(<span class="string">"常规写法list=<span class="variable">$list</span>"</span>)     <span class="comment">//常规写法list=[A,B,C]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用with()函数写法</span></span><br><span class="line">    with(ArrayList&lt;String&gt;())&#123;</span><br><span class="line">        add(<span class="string">"A"</span>)</span><br><span class="line">        add(<span class="string">"B"</span>)</span><br><span class="line">        add(<span class="string">"C"</span>)</span><br><span class="line">        println(<span class="string">"使用with函数写法this=<span class="variable">$this</span>"</span>) <span class="comment">//使用with函数写法this=[A,B,C]</span></span><br><span class="line">    &#125;.let&#123;println(it)&#125;   <span class="comment">//Kotlin.Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testWithFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin扩展函数与扩展属性</title>
    <url>/2020/05/02/Kotlin%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E4%B8%8E%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>title: kotlin扩展函数与扩展属性</p>
<p>date: 2020-04-15 12:43:36<br>tags: kotlin<br>categories: kotlin学习<br>copyright: true</p>
<h1 id="kotlin扩展函数与扩展属性"><a href="#kotlin扩展函数与扩展属性" class="headerlink" title="kotlin扩展函数与扩展属性"></a>kotlin扩展函数与扩展属性</h1><a id="more"></a>

<p>(近期在学kotlin和vue希望可以慢慢掌握吧—小小白)</p>
<h2 id="1-给String类扩展firstChar-函数和lastChar-函数"><a href="#1-给String类扩展firstChar-函数和lastChar-函数" class="headerlink" title="1. 给String类扩展firstChar()函数和lastChar()函数"></a>1. 给String类扩展firstChar()函数和lastChar()函数</h2><p>扩展函数与扩展属性可以在不修改原来类的条件下自定义函数和属性，使它们表现得就像是属于这条个类一样。例如，我们给String类型扩展一个返回字符串最后一个字符的firstChar()函数，然后在main函数中调用。代码十分简洁。(kotlin中使用fun来声明函数)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">     &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.length-<span class="number">1</span>].toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">firstChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">ArrayList</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=<span class="string">"abc"</span></span><br><span class="line">    println(<span class="string">"lastChar: "</span>+str.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果非常明显，会打印出 (上例中的this值得就是调用lastChar函数的对象实例):</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lastChar: c</span><br></pre></td></tr></table></figure>

<p>注：kotlin中println函数是封装了java中的System.out.println()函数。</p>
<p>*扩展函数的语法可用下图概括：</p>
<img src="https://s1.ax1x.com/2020/04/29/JHJqpT.jpg" style="zoom:50%;" />



<p>如果在其他的package路径下面，则需要import导入扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.easy.Kotlin.tutorial   <span class="comment">//与扩展函数不在同一个包路径下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.easy.Kotlin.firstChar   <span class="comment">//导入扩展函数firstChar()</span></span><br><span class="line"><span class="keyword">import</span> com.easy.Kotlin.lastChar    <span class="comment">//导入扩展函数lastChar()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> str=<span class="string">"Hello"</span></span><br><span class="line">    println(str.lastChar())   <span class="comment">//打印结果：o</span></span><br><span class="line">    println(<span class="string">"abc"</span>.firstChar()) <span class="comment">//打印结果：a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-给List类扩展一个过滤函数"><a href="#2-给List类扩展一个过滤函数" class="headerlink" title="2. 给List类扩展一个过滤函数"></a>2. 给List类扩展一个过滤函数</h2><p>如果我们要给List类自定义一个扩展过滤函数，应该怎样去做呢？</p>
<h3 id="2-1-用Java给list类扩展一个过滤函数"><a href="#2-1-用Java给list类扩展一个过滤函数" class="headerlink" title="2.1 用Java给list类扩展一个过滤函数"></a>2.1 用Java给list类扩展一个过滤函数</h3><p>为了让读者能更加深刻地体会到Kotlin扩展功能的简单、优雅性，我们先看在Java中是怎样实现的吧！首先，我们会声明一个ListUtil类，里面实现一个List filter(List,list Predicatep)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUtil</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *根据谓词p过滤list中的元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt;filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">        List&lt;T&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//新建一个List链表，用来存放满足predicate条件的值</span></span><br><span class="line">        <span class="keyword">for</span>(T t:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.predicate(t))&#123;        <span class="comment">//判断t是否满足predicate条件</span></span><br><span class="line">            result.add(t);         <span class="comment">//要是满足则添加到result中</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         List&lt;Integer&gt; list=Arrays.asList(<span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;); <span class="comment">//创建一个Integer类型的链表</span></span><br><span class="line">         ListUtil&lt;Integer&gt; listUtil=<span class="keyword">new</span> ListUtil();  <span class="comment">//声明ListUtil类的实例对象</span></span><br><span class="line">         List&lt;Integer&gt; result=listUtil.filter(list,(it)-&gt;it%<span class="number">2</span>==<span class="number">1</span>); <span class="comment">//Lambdab表达式  </span></span><br><span class="line">         out.println(result);  <span class="comment">//打印结果：[1,3,5,7]  </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Predicate接口声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function">Boolean <span class="title">predicate</span><span class="params">(T t)</span></span>;   <span class="comment">//返回布尔值的谓词函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-用Kotlin给list扩展一个过滤函数"><a href="#2-2-用Kotlin给list扩展一个过滤函数" class="headerlink" title="2.2 用Kotlin给list扩展一个过滤函数"></a>2.2 用Kotlin给list扩展一个过滤函数</h3><p>下面我们就来使用Kotlin中的扩展函数为List扩展一个filter()函数</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JHdKl6.jpg" alt=""></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> T List<span class="type">&lt;T&gt;</span><span class="title">filter</span><span class="params">(predicate:(<span class="type">T</span>)-&gt;<span class="type">Boolean</span>)</span></span>:MutableList&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">val</span> result=ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">this</span>.forEach&#123;               <span class="comment">//这里的this，指调用者</span></span><br><span class="line">        <span class="keyword">if</span>(predicate(it))&#123;      <span class="comment">//如果满足谓词判断条件</span></span><br><span class="line">            result.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=mutableListOf&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> result=list.filter&#123;</span><br><span class="line">        it%<span class="number">2</span>==<span class="number">1</span>           <span class="comment">//这是一个Lambda表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)     <span class="comment">//打印结果：[1,3,5,7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin的标准库API中使用了扩展的功能，通过扩展Java的API，提供了大量使用且简单的函数。</p>
<h2 id="3-扩展属性"><a href="#3-扩展属性" class="headerlink" title="3.  扩展属性"></a>3.  扩展属性</h2><p>除了扩展一个类的函数，还可以扩展类的属性。例如，给MutableList扩展两个属性：firstElement和lastElement</p>
<p>*语法：</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JHwpAH.jpg" alt=""></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;T&gt;MutableList&lt;T&gt;.firstElement:T</span><br><span class="line">    <span class="keyword">get</span>()&#123;                         <span class="comment">//扩展属性firstElement的get()函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>]             <span class="comment">//返回第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;                    <span class="comment">//扩展属性firstElement的set()函数</span></span><br><span class="line">        <span class="keyword">this</span>[<span class="number">0</span>]=value              <span class="comment">//设置第一个元素为value</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> &lt;T&gt;MutableList&lt;T&gt;.lastElement:T</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.size-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="keyword">this</span>.size-<span class="number">1</span>]=value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=mutableListOf&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">    println(<span class="string">"list=<span class="subst">$&#123;list&#125;</span>"</span>)  <span class="comment">//打印[1,2,3,4,5,6,7]</span></span><br><span class="line">    println(list.firstElement) <span class="comment">//打印：1</span></span><br><span class="line">    println(list.lastElement) <span class="comment">//打印：7</span></span><br><span class="line">    </span><br><span class="line">    list.firstElement=-<span class="number">1</span></span><br><span class="line">    list.lastElement=-<span class="number">7</span></span><br><span class="line">    println(<span class="string">"list=<span class="subst">$&#123;list&#125;</span>"</span>)  <span class="comment">//打印[-1,2,3,4,5,6,-7]</span></span><br><span class="line">    println(list.firstElement) <span class="comment">//打印：-1</span></span><br><span class="line">    println(list.lastElement) <span class="comment">//打印：-7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-扩展的实现原理"><a href="#4-扩展的实现原理" class="headerlink" title="4.  扩展的实现原理"></a>4.  扩展的实现原理</h2><p>扩展属性和扩展函数的本质是以静态导入的方式来实现的。其背后的实现原理可以通过Kotlin代码的ByteCode来理解。</p>
<p>例如给String类型扩展的firstChar()函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">firstChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面对应的JVM代码反编译成java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">firstChar</span><span class="params">(@NotNull String $receiver)</span></span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver,<span class="string">"$receiver"</span>);</span><br><span class="line">    <span class="keyword">return</span> $receiver.length()==<span class="number">0</span> ? <span class="string">""</span> : String.valueOf($receiver.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-扩展中的this关键字"><a href="#5-扩展中的this关键字" class="headerlink" title="5. 扩展中的this关键字"></a>5. 扩展中的this关键字</h2><p>Kotlin中使用this表达式：</p>
<ul>
<li>在类的成员函数中，this指向这个类的当前对象实例；</li>
<li>在扩展函数中，或带接收者的函数字面值(function literal)中，this代表调用函数时，在点号左侧传递的接收者参数；</li>
<li>如果this没有限定符，那么它指向包含当前代码的最内层范围。如果想要指向其他范围内的this，需要使用标签限定符。</li>
</ul>
<p>*编程技巧提示：可以新建一个公共资源文件，把自定义的扩展属性和扩展函数都放到包中，作为一个通用工具类来使用。</p>
]]></content>
  </entry>
  <entry>
    <title>Kotlin类的学习</title>
    <url>/2020/04/22/Kotlin%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Kotlin类的学习"><a href="#Kotlin类的学习" class="headerlink" title="Kotlin类的学习"></a>Kotlin类的学习</h1><a id="more"></a>

<h2 id="1-oo编程的基本概念"><a href="#1-oo编程的基本概念" class="headerlink" title="1. oo编程的基本概念"></a>1. oo编程的基本概念</h2><p>类是对象的抽象化，而对象则是类的实例化。</p>
<img src="https://s1.ax1x.com/2020/04/22/JYTxYR.jpg" alt="img" style="zoom:50%;" />

<p>oo编程的基本概念</p>
<img src="https://s1.ax1x.com/2020/04/22/JYhWX4.jpg" alt="img" style="zoom:33%;" />



<hr>
<h2 id="2-声明类"><a href="#2-声明类" class="headerlink" title="2. 声明类"></a>2. 声明类</h2><h3 id="2-1-空类"><a href="#2-1-空类" class="headerlink" title="2.1 空类"></a>2.1 空类</h3><p>使用class关键字声明类。我们可以声明一个什么都不干的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnEmptyClass</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> anEmtyClass=AnEmptyClass()   <span class="comment">//kotlin中不需要使用new</span></span><br><span class="line">    println(anEmtyClass <span class="keyword">is</span> AnEmtyClass) <span class="comment">//结果打印为 truezai</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，我们可以在声明类的时候同时声明构造函数，语法格式是在类的后面使用括号包含构造函数的参数列表</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name:String, <span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> sex:String)&#123;</span><br><span class="line">        <span class="comment">//声明类和构造函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;    <span class="comment">//override关键字，用来重写toString()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person(name='<span class="variable">$name</span>',age=<span class="variable">$age</span>,sex='<span class="variable">$sex</span>')"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> person=Person(<span class="string">"kim"</span>,<span class="number">29</span>,<span class="string">"M"</span>)</span><br><span class="line">    println(<span class="string">"person=<span class="subst">$&#123;person&#125;</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*打印结果为：</span></span><br><span class="line"><span class="comment">    person=Person(name='jack',age=29,sex='M')</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-11-lateinit-关键字延迟属性初始化"><a href="#2-11-lateinit-关键字延迟属性初始化" class="headerlink" title="2.11 lateinit 关键字延迟属性初始化"></a>2.11 lateinit 关键字延迟属性初始化</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String  <span class="comment">//lateinit关键字表示该属性延迟初始化</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">0</span>  <span class="comment">//lateinit关键字不能修饰primitive类型</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person(name=<span class="variable">$name</span>,age=<span class="variable">$age</span>,sex=<span class="variable">$sex</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果使用2.1中的例子Person类，用以下方式调用Person类</span></span><br><span class="line"><span class="comment">val person=Person()</span></span><br><span class="line"><span class="comment">person.name="jack"</span></span><br><span class="line"><span class="comment">person.age=29</span></span><br><span class="line"><span class="comment">person.sex="M"</span></span><br><span class="line"><span class="comment">println("person=$&#123;person&#125;")</span></span><br><span class="line"><span class="comment">则会报以下错误</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'name'</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'age'</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'sex'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-constructor关键字声明具有多种构造方式的类"><a href="#3-constructor关键字声明具有多种构造方式的类" class="headerlink" title="3. constructor关键字声明具有多种构造方式的类"></a>3. constructor关键字声明具有多种构造方式的类</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>()&#123;         <span class="comment">//</span></span><br><span class="line">   <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String):<span class="keyword">this</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,sex:String):<span class="keyword">this</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">        <span class="keyword">this</span>.sex=sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person(name='<span class="variable">$name</span>',age=<span class="variable">$age</span>,sex='<span class="variable">$sex</span>')"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有一些样板代码，其实在IDEA中，上面的代码只需要下面3行代码即可替换，剩下的就交给IDEA自动生成了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>&#123;</span><br><span class="line">   <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String </span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">   <span class="comment">//剩下的在IDEA中自动生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IDEA中自动的步骤</p>
<ol>
<li><p>在当前类中右击，在弹出的快捷菜单中选择Generate命令</p>
</li>
<li><p>之后，弹出生成次级构造函数对话框，在其中选择Secondary Constructor命令，</p>
</li>
<li><p>选择构造函数的参数。选中相应的属性，单击OK按钮即可生成构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如上面的例子</span></span><br><span class="line"><span class="keyword">constructor</span>() <span class="comment">//一个属性都不选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String)&#123; <span class="comment">//选择一个name属性，生成带name参数的构造函数</span></span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;<span class="comment">//选择name和age属性，生成带name，age参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,sex:String):<span class="keyword">this</span>(name,age)&#123;<span class="comment">//选择全部属性，生成带有全部参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>当然用到最多的构造函数还是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name:String,<span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> sex:String)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-抽象类与接口"><a href="#4-抽象类与接口" class="headerlink" title="4. 抽象类与接口"></a>4. 抽象类与接口</h2><p>抽象类表示”is-a“的关系，而接口所代表的是”has-a”的关系。</p>
<p>抽象类用来表征问题领域的抽象概念。</p>
<p>所有编程语言都提供抽象机制。机器语言是对机器的模仿抽象。汇编语言是对机器语言的高层次抽象，高级语言是对汇编语言的高层次抽象。而面向对象编程语言是对过程函数的高层次封装。如下图 </p>
<p><img src="https://s1.ax1x.com/2020/04/22/JN7Y9A.jpg" alt="img"></p>
<p>抽象类和接口是Kotlin语言中两种不同的抽象概念，它们的存在对多态提供了非常好的支持。这个机制与java相同</p>
<hr>
<h3 id="4-1-抽象类与抽象成员"><a href="#4-1-抽象类与抽象成员" class="headerlink" title="4.1 抽象类与抽象成员"></a>4.1 抽象类与抽象成员</h3><p>以抽象类Shape为例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span>    //声明抽象父类<span class="title">Shape</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>: <span class="type">Shape</span></span>()  <span class="comment">//继承类的语法是使用冒号":",父类需要在这里使用构造函数进行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="type">Shape</span></span>()   <span class="comment">//Circle继承Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>: <span class="type">Shape</span></span>()    <span class="comment">//Tirangle继承Shape类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s=Shape()    <span class="comment">//编译不通过，不能实例化抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> r=Rectangle()</span><br><span class="line">println(r <span class="keyword">is</span> Shape())   <span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<p>一个类的成员包括属性和函数。抽象类的成员也必须是抽象的，需要使用abstract关键字修饰。下面声明一个带有成员的Shape抽象类.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> width:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> height:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，继承抽象类Shape的方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">                <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>): Shape()&#123;  <span class="comment">//声明类的同时声明了构造函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123; <span class="comment">//override是覆盖父类属性和函数的关键字</span></span><br><span class="line">        <span class="keyword">return</span> height*width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">             <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>):Shape()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> rectangle=Rectangle(<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> circle=Circle(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">2.0</span>)</span><br><span class="line">    println(<span class="string">"area=<span class="subst">$&#123;rectangle.area()&#125;</span>"</span>)  <span class="comment">//结果为： area=12.0</span></span><br><span class="line">    println(<span class="string">"area=<span class="subst">$&#123;circle.area()&#125;</span>"</span>)   <span class="comment">//结果为： area=12.56</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中可以有带实现的函数，例如在抽象类Shape中添加一个函数onClick():</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"I am a student"</span>) <span class="comment">//在抽象类中可以添加实现的函数，如onClick()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r=Rectangle(<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">0.0</span>)</span><br><span class="line">    r.onClick()     <span class="comment">//输出 I am a student</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类Shape中的onClick()函数默认是final的，不可以被覆盖重写。如果想要开放给子类重新实现这个函数，可以在前面加上open关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;   <span class="comment">//在函数onClick加上open关键字</span></span><br><span class="line">         println(<span class="string">"I am a student"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类中覆盖重写onClick函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">               <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>):Shape()&#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> height*width</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;    <span class="comment">//此处的Unit可以不用添加，当函数没有返回值时，默认为Unit相当于java中的void，这里添加当然就是为了再次复习一下。</span></span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;this::class.simpleName&#125;</span> is a teacher"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r=Rectangel()   <span class="comment">//Kotlin中，创建一个新对象时，不添加new</span></span><br><span class="line">    r.onClick()   <span class="comment">//打印结果为  Rectangle is a teacher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 this::class.simpleName 是 Kotlin 中反射的API，在Gradle工程的 build.gradle 中需要添加依赖compile：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">compile<span class="string">"org.jetbrains.kotlin:kotlin-reflect:<span class="variable">$kotlin_version</span>"</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-类继承的规则"><a href="#4-2-类继承的规则" class="headerlink" title="4.2 类继承的规则"></a>4.2 类继承的规则</h3><p>当子类继承了某个类之后，便可以使用父类中的成员变量，但并不是完全继承父类的所有成员变量。</p>
<ul>
<li>能够继承父类的public 和 protected 成员变量</li>
<li>不能继承父类的private类型的成员变量</li>
<li>对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能继承。</li>
<li>对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名变量。如果要在子类中访问父类中的同名成员变量，需要使用super关键字进行引用。</li>
</ul>
<hr>
<h2 id="5-接口"><a href="#5-接口" class="headerlink" title="5. 接口"></a>5. 接口</h2><p>接口是一种比抽象类更加抽象的 ”类“。接口本身代表的是一种”类型“的概念。但在语法层面，接口本身不是类，不能实例化接口，只能实例化它的实现类。</p>
<p>接口是用来建立类与类之间的协议。实现接口的实现类必须要实现该接口的所有方法。在Java8和Kotlin中，接口可以实现一些通用的方法。</p>
<p>接口是抽象类的延伸。在Kotlin和Java中一个类，不支持同时继承多个父类，也就是说一个类只能存在一个父类(单继承).</p>
<p>但是接口不同，一个类可以同时实现多个接口(多组合),无论这些接口之间有没有关系。这样可以实现多重继承。</p>
<p>与Java类似，Kotlin 使用interface作为接口的关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">projectService</span>    //<span class="title">Java</span>中使用<span class="title">interface</span>声明接口</span></span><br></pre></td></tr></table></figure>

<p>接口和抽象类都可以包含抽象的方法和实现的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">projectService</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> name:String</span><br><span class="line">   <span class="keyword">val</span> owner:String</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(project:<span class="type">Project</span>)</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">" I am project"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是没有构造函数的，使用冒号 ”:“ 语法来实现一个接口，如果有多个接口， 用 “,” 逗号隔开：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectServiceImpl</span> : <span class="type">ProjectService //与继承抽象类语法一样，使用冒号</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectMilestoneServiceImpl</span> : <span class="type">ProjectService</span>, <span class="type">MilestoneService  //实现多个接口使用逗号 "</span>,<span class="type">" 隔开</span></span></span><br></pre></td></tr></table></figure>

<p>假如说在 ProjectMilestoneServiceImpl 类中要重写print()方法时，该类继承的两个接口类  ProjectService，MilestoneService 中都有一个print()方法。当直接使用super.print() 函数时，编译器无法知道我们想要调用的是哪个print函数，我们把这种现象叫做覆盖冲突。</p>
<p>这个时候，我们可以使用下面的语法来调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>&lt;ProjectService&gt;.print()  <span class="comment">//使用super&lt;ProjectService&gt;指定调用的是ProjectService接口中的print()函数</span></span><br><span class="line"><span class="keyword">super</span>&lt;MilestoneService&gt;.print() <span class="comment">//使用super&lt;MilestoneService&gt;指定调用的是MilestoneService接口中的print()函数</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-object对象"><a href="#6-object对象" class="headerlink" title="6. object对象"></a>6. object对象</h2><p>单例模式是一种常用的软件设计模式。例如，Spring中的Bean默认就是单例。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p>
<p>Kotlin中没有静态属性和方法，但是可以使用关键字object声明一个object单例对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> User&#123;   <span class="comment">//声明对象类型User</span></span><br><span class="line">    <span class="keyword">val</span> username:String = <span class="string">"admin"</span></span><br><span class="line">    <span class="keyword">val</span> password:String = <span class="string">"admin"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"Hello, object!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(User.username)    <span class="comment">//与Java静态类的调用形式一样</span></span><br><span class="line">    println(User.password)    </span><br><span class="line">    User.hello()              <span class="comment">//与Java静态方法的调用方式一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-Kotlin中还提供了伴生对象，用companion-object关键字声明："><a href="#7-Kotlin中还提供了伴生对象，用companion-object关键字声明：" class="headerlink" title="7. Kotlin中还提供了伴生对象，用companion object关键字声明："></a>7. Kotlin中还提供了伴生对象，用companion object关键字声明：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> DataProcessor&#123; <span class="comment">//使用companion object声明DataProcessor的伴生对象</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> process&#123;</span></span><br><span class="line">            println(<span class="string">"I am processing data..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    DataProcessor.process()   <span class="comment">//I am processing data...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类只能有一个伴生对象</p>
<hr>
<h2 id="8-数据类"><a href="#8-数据类" class="headerlink" title="8. 数据类"></a>8. 数据类</h2><p>数据类就只存储数据，不包含操作行为的类。Kotlin中的数据类可以为我们节省大量的样板代码(Java中强制我们要去写一堆getter、setter代码，而实际上这些方法都是“不言而明”的)，这样最终的代码更易于理解，便于维护。</p>
<h3 id="8-1-创建数据类"><a href="#8-1-创建数据类" class="headerlink" title="8.1 创建数据类"></a>8.1 创建数据类</h3><p>使用关键字为data class创建一个只包含数据的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span></span>(<span class="keyword">val</span> username:String,<span class="keyword">val</span> password:String)</span><br></pre></td></tr></table></figure>

<p>在IDEA中提供了方便的Kotlin工具箱，我们可以把上面的代码反编译成等价的Java代码。</p>
<hr>
<h3 id="8-2-数据类自动创建的函数"><a href="#8-2-数据类自动创建的函数" class="headerlink" title="8.2 数据类自动创建的函数"></a>8.2 数据类自动创建的函数</h3><ul>
<li>equals()/hashCode()函数toString()格式为“LoginUser(username=”this.username+”,password=”+this.password+”)”;</li>
<li>component1()和component2()函数返回对应下标的属性值，按声明顺序排列;</li>
<li>copy()函数：根据旧对象属性重新newLoginUser(username,password)一个对象出来。</li>
</ul>
<p>如果这些函数在类中已经被明确定义了，或者从超类中继承而来，编译器就不再生成。</p>
<hr>
<h3 id="8-3-数据类的语法限制"><a href="#8-3-数据类的语法限制" class="headerlink" title="8.3 数据类的语法限制"></a>8.3 数据类的语法限制</h3><p>数据类有如下限制：</p>
<ul>
<li>主构造函数至少包含一个参数；</li>
<li>参数必须标识为val或者var；</li>
<li>不能为abstract、open、sealed或者inner；</li>
<li>不能继承其他类(但可以实现接口)</li>
</ul>
<p>另外，数据类可以在解构声明中使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span></span>(<span class="keyword">val</span> username:String,<span class="keyword">val</span> password:String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> loginUser=LoginUser(<span class="string">"admin"</span>,<span class="string">"admin"</span>)</span><br><span class="line">    <span class="keyword">val</span>(username,password)=loginUser<span class="comment">//解构声明(username,password)</span></span><br><span class="line">    println(<span class="string">"username=<span class="subst">$&#123;username&#125;</span>,password=<span class="subst">$&#123;password&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">//username=admin,password=admin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-4-Pair和Triple"><a href="#8-4-Pair和Triple" class="headerlink" title="8.4 Pair和Triple"></a>8.4 Pair和Triple</h3><p>Kotlin标准库提供了Pair和Triple数据类，分别表示二元组和三元组对象。它们的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="type">out A,out B</span>&gt;</span>(</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> first:A,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> second:B):Serializable&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String=<span class="string">"&#123;<span class="variable">$first</span>,<span class="variable">$second</span>&#125;"</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;A,B&gt;</span>A.<span class="title">to</span><span class="params">(that:<span class="type">B</span>)</span></span>:Pair&lt;A,B&gt;=Pair(<span class="keyword">this</span>,that)<span class="comment">// 中缀函数to()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Triple</span>&lt;<span class="type">out A,out B, out C</span>&gt;</span>(</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> first:A,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> second:B,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> third:C): Serializable&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String=<span class="string">"&#123;<span class="variable">$first</span>,<span class="variable">$second</span>,<span class="variable">$third</span>&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Pair和Triple这两个函数系统已经定义好了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"A"</span>,<span class="number">2</span> to <span class="string">"B"</span>,<span class="number">3</span> to <span class="string">"C"</span>)</span><br><span class="line">    println(map)   <span class="comment">//结果打印&#123;1=A, 2=B,3=C&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-枚举类-enum-class…"><a href="#9-枚举类-enum-class…" class="headerlink" title="9. 枚举类(enum class…)"></a>9. 枚举类(enum class…)</h2><p>Kotlin中使用enum class关键字来声明一个枚举类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span></span>&#123;   <span class="comment">//使用enum class声明一个Direction枚举类型</span></span><br><span class="line">  NORTH,SOUTH,WEST,EAST  <span class="comment">//每个枚举常量都是一个对象，用逗号隔开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于字符串常量，使用枚举能够实现类型安全。枚举类有两个内置的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">val</span> name:String   <span class="comment">//枚举对象的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">val</span> ordinal:<span class="built_in">Int</span>   <span class="comment">//枚举对象的下标位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> north=Direction.NORTH</span><br><span class="line">    println(north.name)   <span class="comment">//打印NORTH</span></span><br><span class="line">    println(north.ordinal) <span class="comment">//打印下标为：0</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个枚举类都是枚举类的实例，它们可以被初始化：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb:<span class="built_in">Int</span>)&#123; <span class="comment">//声明一个带构造函数 rgb:Int的枚举类，RED，GREEN，BLUE都是该枚举类的实例</span></span><br><span class="line">   RED(<span class="number">0xFF0000</span>),</span><br><span class="line">   GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">   BLUE(<span class="number">0x0000FF</span>)     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> c=Color.GREEN          <span class="comment">//访问Color枚举类型中的GREEN元素</span></span><br><span class="line">    println(c)                  <span class="comment">//打印结果：GREEN</span></span><br><span class="line">    println(c.rgb)             <span class="comment">//访问GREEN枚举的rgb参数值  打印结果：65280</span></span><br><span class="line">    println(c.ordinal)         <span class="comment">//GREEN枚举的ordinal属性 打印结果：1</span></span><br><span class="line">    println(c.name)            <span class="comment">//GREEN枚举的name属性   打印结果：GREEN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-内部类"><a href="#10-内部类" class="headerlink" title="10. 内部类"></a>10. 内部类</h2><p>Kotlin的内部类包括普通嵌套类、内部嵌套类和匿名内部类。</p>
<h3 id="10-1-普通嵌套类"><a href="#10-1-普通嵌套类" class="headerlink" title="10.1 普通嵌套类"></a>10.1 普通嵌套类</h3><p>Kotlin中，类可以嵌套。一个类可以嵌套在其他类中，而且可以嵌套多层。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> zeror:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> one:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getTwo</span><span class="params">()</span></span>=<span class="number">2</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nested1</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> three=<span class="number">3</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">getFour</span><span class="params">()</span></span>=<span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当调用某个类的成员时，该类用过的是对象即"类名()",否则其他的类则只是用类名调用</span></span><br><span class="line">    <span class="keyword">val</span> one=NestedClassDemo.Outer().one</span><br><span class="line">    <span class="keyword">val</span> two=NestedClassDemo.Nested().getTwo()</span><br><span class="line">    <span class="keyword">val</span> three=NestedClassDemo.Nested.Nested1().three</span><br><span class="line">    <span class="keyword">val</span> four=NestedClassDemo.Nested.Nested1().getFour()</span><br><span class="line">     println(<span class="string">"<span class="variable">$one</span>+<span class="variable">$two</span>+<span class="variable">$three</span>+<span class="variable">$four</span>"</span>)   <span class="comment">//打印结果为 1+2+3+4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*注：普通嵌套类没有持有外部类的引用，所以是无法访问外部类变量的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;   <span class="comment">//Nested类是Outer类的内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> zero:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> one:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getTow</span><span class="params">()</span></span>=<span class="number">2</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">accessOuter</span><span class="params">()</span></span>=&#123;</span><br><span class="line">            println(zero)    <span class="comment">//IDEA报错：Kotlin:Unresolved reference:zero</span></span><br><span class="line">            println(one)     <span class="comment">//IDEA报错：Kotlin:Unresolved reference:one</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-2-嵌套内部类"><a href="#10-2-嵌套内部类" class="headerlink" title="10.2  嵌套内部类"></a>10.2  嵌套内部类</h3><p>如果一个类 Inner想要访问外部类Outer中的成员，可以在这个类前面添加修饰符inner。内部类会带有一个对外部类的对象引用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;      <span class="comment">//Inner类是Outer类的内部类</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">val</span> zero:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">      <span class="keyword">val</span> one:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">      </span><br><span class="line">       <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;    <span class="comment">//使用inner关键字声明内部类，来访问外部类的成员</span></span><br><span class="line">         <span class="function"><span class="keyword">fun</span> <span class="title">accessOuter</span><span class="params">()</span></span>=&#123;</span><br><span class="line">             println(zero)</span><br><span class="line">             println(one)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> innerClass=NestedClassDemo.Outer().Inner().accessOuter()</span><br><span class="line">    println(innerClass)   <span class="comment">//打印结果：()-&gt;Kotlin.Unit，代表是个innerClass变量是个函数类型，且无参数，无返回</span></span><br><span class="line">    innerClass()  </span><br><span class="line">    <span class="comment">/*以函数形式调用，打印结果为：</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-3-匿名内部类"><a href="#10-3-匿名内部类" class="headerlink" title="10.3 匿名内部类"></a>10.3 匿名内部类</h3><p>匿名内部类就是没有名字的内部类。匿名内部类也可以访问外部类的变量。下面使用对象表达式创建一个匿名内部类，实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClassDemo</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> isRunning=<span class="literal">false</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Thread(<span class="keyword">object</span> :Runnable&#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    TODO(<span class="string">"Not yet implemented"</span>)</span><br><span class="line">                    isRunning=<span class="literal">true</span></span><br><span class="line">                    println(<span class="string">"doRun : i am running,isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*注：如果对象是函数式子Java接口，即具有单个抽象方法的Java接口的实例，例如上面例子中的Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>                   <span class="comment">//Java 8 中引入的函数式接口注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;       <span class="comment">//函数式接口只有一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用Lambda表达式实现Runnable接口。下面几种写法都是可以的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isRunning=<span class="literal">true</span></span><br><span class="line">  Thread(&#123;    <span class="comment">//直接使用Lambda表达式</span></span><br><span class="line">      isRunning =<span class="literal">false</span></span><br><span class="line">      println(<span class="string">"doStop: i am not running,isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">  &#125;).start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRunning=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> wait=Runnable&#123; <span class="comment">//使用匿名内部类的方式，使用Lambda表达式实现run接口</span></span><br><span class="line">        isRunning=<span class="literal">false</span></span><br><span class="line">        println(<span class="string">"doWait:i am waiting,isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread(wait).start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRunning=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> wait=&#123;       <span class="comment">//直接声明一个Lambda函数</span></span><br><span class="line">        isRunning=<span class="literal">false</span></span><br><span class="line">        println(<span class="string">"doNotify:i notify, isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread(wait).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin集合类</title>
    <url>/2020/04/30/Kotlin%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Kotlin集合类"><a href="#Kotlin集合类" class="headerlink" title="Kotlin集合类"></a>Kotlin集合类</h1><a id="more"></a>

<p>在Java类库中有一套相当完整的容器集合类来持有对象。Kotlin没有去重复造轮子(Scala则是自己实现了一套集合类框架)，而是在Java类库的基础上进行改造和扩展，引入了不可变集合类，同时扩展了大量方便实用的功能，这些功能的API都在Kotlin.collections包下面</p>
<p>另外，在Kotlin的集合类中不仅仅能持有普通对象，而且能够持有函数类型的变量。例如下面是一个持有两个函数的集合类：</p>
<p>其中，(Int) -&gt;Boolean 是一个从Int映射到Boolean的函数，而这个时候，我们可以在代码里选择调用哪个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> funlist:List&lt;(<span class="built_in">Int</span>)-&gt;<span class="built_in">Boolean</span>&gt;=  <span class="comment">//声明一个持有类型为函数(Int) -&gt;Boolean的List</span></span><br><span class="line">listOf(&#123;it-&gt;it%<span class="number">2</span>==<span class="number">0</span>&#125;,   <span class="comment">//第1个函数为&#123;it-&gt;it%2==0&#125;</span></span><br><span class="line">       &#123;it-&gt;it%<span class="number">2</span>==<span class="number">1</span>&#125;)   <span class="comment">//第2个函数为&#123;it-&gt;it%2==1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">     list.filter(funlist[<span class="number">0</span>]) <span class="comment">//传入第1个函数funlist[0]，返回[2,4,6]</span></span><br><span class="line">     list.filter(funlist[<span class="number">1</span>]) <span class="comment">//传入第2个函数funlist[1]，返回[1,3,5,7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-集合类概述"><a href="#1-集合类概述" class="headerlink" title="1. 集合类概述"></a>1. 集合类概述</h2><p>集合类存放的都是对象的引用，而非对象本身，我们通常说的集合中的对象指的是集合中对象的引用(reference)。</p>
<p>Kotlin的集合类分为：可变集合类(Mutable)与不可变集合类(Immutable)</p>
<hr>
<h3 id="1-1-常用的三种集合类"><a href="#1-1-常用的三种集合类" class="headerlink" title="1.1  常用的三种集合类"></a>1.1  常用的三种集合类</h3><p>集合类主要有3种：List(列表)、Set(集)和Map(映射)。</p>
<ul>
<li>List容器中的元素以线性方式存储，集合中可以存放重复对象。列表中的元素是有序地排列。</li>
<li>Set集容器的元素无序、不重复。</li>
<li>Map映射中持有的是”键值对” 对象，每个对象都包含一对键值K-V对象。Map映射容器中存储的每个对象都有一个相关的关键字(Key)对象，关键字决定对象在映射中的存储位置。关键字是唯一的。其实关键字本身并不能决定对象的存储位置，它通过散列(hashing)产生一个被称作散列码(hash code)的整数值，这个散列码对应值(Value)的存储位置。</li>
</ul>
<p>如果我们从数据结构的本质上来看，其实List中的下标就是Key，只不过Key是有序的Int类型，所以说List也可以说是一种特殊的Map数据结构。而Set也是Key为Int类型，但是Value值是不能重复的特殊Map。</p>
<p>下面是Kotlin中集合类接口的结构层次：</p>
<img src="https://s1.ax1x.com/2020/04/30/Jq4MGt.jpg" style="zoom: 33%;" />

<p>其中，各个接口说明如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/30/Jq4rsU.jpg" alt=""></p>
<hr>
<h3 id="1-2-不可变集合类"><a href="#1-2-不可变集合类" class="headerlink" title="1.2  不可变集合类"></a>1.2  不可变集合类</h3><ul>
<li>List列表分为只读不可变的List和可变MutableList(可写入、删除数据)。List列表的类型层次结构如下：</li>
</ul>
<img src="https://s1.ax1x.com/2020/04/30/JqoIyV.jpg" style="zoom: 50%;" />



<ul>
<li>Set集也分为不可变Set和可变MutableSet(可写入、删除数据)。Set集合的类型层次结构如下图：</li>
</ul>
<p>  <img src="https://s1.ax1x.com/2020/04/30/JqbkY4.jpg" alt=""></p>
<ul>
<li>Kotlin中的Map与List、Set一样，Map也分为只读Map和可变MutableMap(可写入、删除数据)</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/04/30/JqbW7T.jpg" alt=""></p>
<hr>
<h3 id="1-3-创建集合类"><a href="#1-3-创建集合类" class="headerlink" title="1.3  创建集合类"></a>1.3  创建集合类</h3><ul>
<li>不可变集合类的创建</li>
</ul>
<p>​       Kotlin中分别使用listOf()、setOf()、mapOf()函数创建不可变的List列表容器、Set容器、Map映射容器；</p>
<ul>
<li><p>可变集合类的创建</p>
<p>使用mutableListOf()、mutableSet()、mutableMapOf()函数来创建可变的MutableList列表容器、MutableSet集容器、MutableMap映射容器</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/04/30/JqO3hF.jpg" alt=""></p>
<p>​                                                                               图7.3.1 创建List</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JqO2nI.jpg" alt=""></p>
<p>​                                                                              图7.3.2 创建Set</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JqOx4U.jpg" alt=""></p>
<p>​                                                                              图7.3.3 创建Map</p>
<p>代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mian</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> list1=listOf(<span class="string">"a"</span>,<span class="string">"d"</span>,<span class="string">"m"</span>,<span class="string">"i"</span>,<span class="string">"n"</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableList=mutableListOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">    mutableList.add(<span class="string">"d"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span>=setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> set1= setOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableset=mutableSetOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line">    mutableset.add(<span class="string">"e"</span>)</span><br><span class="line">    mutableset.remove(<span class="string">"c"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"a"</span>,<span class="number">2</span> to <span class="string">"b"</span>,<span class="number">3</span> to <span class="string">"c"</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableMap=mutableMapOf(<span class="number">1</span> to <span class="string">"X"</span>,<span class="number">2</span> to <span class="string">"Y"</span>,<span class="number">3</span> to <span class="string">"Z"</span>)</span><br><span class="line">    mutableMap.<span class="keyword">set</span>(<span class="number">2</span>,<span class="string">"spring"</span>)</span><br><span class="line">    mutableMap.replace(<span class="number">3</span>,<span class="string">"boot"</span>)</span><br><span class="line">    mutableMap.put(<span class="number">4</span>,<span class="string">"C"</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"list="</span>+list)   <span class="comment">//打印 list=[1,2,3,4,5,6,7]</span></span><br><span class="line">    println(<span class="string">"list1=<span class="variable">$list1</span>"</span>)  <span class="comment">//打印 list1=[a,d,m,i,n]</span></span><br><span class="line">    println(<span class="string">"mutableList=<span class="variable">$mutableList</span>"</span>) <span class="comment">//打印  mutableList=[a,b,c,d]</span></span><br><span class="line">    println(<span class="string">"set="</span>+<span class="keyword">set</span>)   <span class="comment">//打印  set=[1,2,3,4,5,6,7]</span></span><br><span class="line">    println(<span class="string">"set1=<span class="variable">$set1</span>"</span>)  <span class="comment">//打印 set1=[a,b,c,d]</span></span><br><span class="line">    println(<span class="string">"mutableset=<span class="variable">$mutableset</span>"</span>)  <span class="comment">//打印 mutableset=[a,b,d,e]</span></span><br><span class="line">    </span><br><span class="line">    println(mutableMap.[<span class="number">2</span>]) <span class="comment">//打印  Y</span></span><br><span class="line">    println(mutableMap.<span class="keyword">get</span>(<span class="number">2</span>)) <span class="comment">//打印 Y   =&gt; println(mutableMap.[2])</span></span><br><span class="line">    println(<span class="string">"map=<span class="variable">$map</span>"</span>)  <span class="comment">//打印  map=[1=a,2=b,3=c]</span></span><br><span class="line">    println(<span class="string">"mutableMap=<span class="variable">$mutableMap</span>"</span>) <span class="comment">//打印 mutableMap=[1=X,2=spring,3=boot,4=C]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果创建没有元素的空List，使用listOf()即可。不过这个时候，变量的类型不能省略，需要显示声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;<span class="built_in">Int</span>&gt; = listOf() <span class="comment">//这样显示声明一个元素类型为Int，并切为空的List是错误的</span></span><br><span class="line"><span class="comment">//原因是Kotlin中变量要是想为空，必须声明为可空变量</span></span><br><span class="line"><span class="keyword">val</span> emptyList: List&lt;<span class="built_in">Int</span>&gt; ? =listOf() <span class="comment">//这样声明才不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> emptySet: Set&lt;<span class="built_in">Int</span>&gt; ? =setOf()   <span class="comment">//显示声明Set的元素类型为Int</span></span><br><span class="line"><span class="keyword">val</span> emptyMap: Map&lt;<span class="built_in">Int</span>,String&gt; ? =mapOf() <span class="comment">//显示声明Map的元素类型为Int，String键值对</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">listOf</span><span class="params">()</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 fun <T> 泛型参数T编译器无法推断出来。setOf()、mapOf()分析同理。</p>
<hr>
<h3 id="1-4-遍历集合中的元素"><a href="#1-4-遍历集合中的元素" class="headerlink" title="1.4 遍历集合中的元素"></a>1.4 遍历集合中的元素</h3><p>List、Set类继承了Iterable接口，里面扩展了forEach函数来迭代遍历元素；同样，Map接口中也扩展了forEach函数来迭代遍历元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEach&#123;             <span class="comment">//List中的forEach</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>.forEach&#123;              <span class="comment">//Set中的forEach</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line">map.forEach&#123;</span><br><span class="line">  println(<span class="string">"k=<span class="subst">$&#123;it.key&#125;</span>,V=<span class="subst">$&#123;it.value&#125;</span>"</span>)  <span class="comment">//Map里面的对象是Map。Entry&lt;K,V&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，forEach()函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(action:(<span class="type">T</span>)-&gt;<span class="type">Unit</span>)</span></span>:<span class="built_in">Unit</span> <span class="comment">//List和Set的forEach()函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K,V&gt;</span> Map<span class="type">&lt;out K,V&gt;</span>.<span class="title">forEach</span><span class="params">(action:(<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;)-&gt;<span class="type">Unit</span>)</span></span>:<span class="built_in">Unit</span></span><br><span class="line"><span class="comment">//Map的forEach()函数</span></span><br></pre></td></tr></table></figure>



<ul>
<li>另外，如果我们想在迭代遍历元素的时候访问index下标，在List和Set中可以使用下面的forEachIndexed函数</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEachIndexed&#123; index,value-&gt;     <span class="comment">//带下标index来遍历List</span></span><br><span class="line">  println(<span class="string">"list index=<span class="subst">$&#123;index&#125;</span>, value=<span class="subst">$&#123;value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEachIndexed&#123; index,value-&gt;     <span class="comment">//带下标index来遍历set</span></span><br><span class="line">  println(<span class="string">"set index=<span class="subst">$&#123;index&#125;</span>,value=<span class="subst">$&#123;value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，第一个参数是index，第2个参数是value。这里的forEachIndexed函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEachIndexed</span><span class="params">(action:(<span class="type">index</span>:<span class="type">Int</span>,<span class="type">T</span>)-&gt;<span class="type">Unit</span>)</span></span>:<span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>Map的元素是Entry类型，由entries属性特有。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> entries:Set&lt;Entry&lt;K,V&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这个Entry类型定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="type">out K,out V</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> key:K     <span class="comment">//键值对的Key</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> Value:V   <span class="comment">//键值对的Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以直接访问entries属性获取该Map中的所有键值对的Set。代码实例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> map=mapOf(<span class="string">"x"</span> to <span class="number">1</span>,<span class="string">"y"</span> to <span class="number">2</span>,<span class="string">"z"</span> to <span class="number">3</span>)</span><br><span class="line">    println(map)    <span class="comment">//打印结果：&#123;x=1,y=2,z=3&#125;</span></span><br><span class="line">    println(<span class="string">"entries=<span class="subst">$&#123;map.entries&#125;</span>"</span>) <span class="comment">//打印结果：[x=1,y=2,z=3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以遍历这个Entry的Set了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">map.entries.forEach(&#123;println(<span class="string">"key="</span>+it.key+<span class="string">" value="</span>+it.value)&#125;)  <span class="comment">//遍历entries中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印结果：</span></span><br><span class="line"><span class="comment">key=x value=1</span></span><br><span class="line"><span class="comment">key=y value=2</span></span><br><span class="line"><span class="comment">key=z value=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h3 id="1-5-映射函数"><a href="#1-5-映射函数" class="headerlink" title="1.5  映射函数"></a>1.5  映射函数</h3><p>使用map函数，可以把集合中的元素依次使用给定的转换函数进行映射操作，元素映射之后的新值会存入一个新的集合中，并返回这个新集合。</p>
<p>在List、Set继承Iterable接口和Map接口中，都提供了这个map函数。使用map函数的代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">   <span class="keyword">val</span> <span class="keyword">set</span>=setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">   <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"a"</span>, <span class="number">2</span> to <span class="string">"b"</span>, <span class="number">3</span> to <span class="string">"c"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下都没有使用println函数,因此不会被打印出来</span></span><br><span class="line">    list.map&#123;it*it&#125;  <span class="comment">//map函数对每个元素进行乘方操作，返回[1,4,9,16,25,36,49]</span></span><br><span class="line">    <span class="keyword">set</span>.map&#123;it+<span class="number">1</span>&#125;    <span class="comment">//set函数对每个元素进行加1操作，返回[2,3,4,5,6,7,8]</span></span><br><span class="line">    map.map&#123;it.value+<span class="string">"$"</span>&#125;  <span class="comment">//map函数对每个元素后加上字符$，返回[a$,b$,c$]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map函数的签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform:(<span class="type">T</span>)-&gt;<span class="type">R</span>)</span></span>:List&lt;R&gt;  <span class="comment">//这个是List和Set的map函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;K,V,R&gt;</span>Map<span class="type">&lt;K,V&gt;</span>.<span class="title">map</span><span class="params">(transform:(<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>)-&gt;<span class="type">R</span>)</span></span>:List&lt;R&gt; <span class="comment">//Map的map函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的R类型是映射之后的数据类型，我们也可以传入一个List：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> strlist=listOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">    strlist.map&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125; <span class="comment">//map函数，每个it映射之后返回一个List，这个List中有4个元素，分别是it+1，it+2，it+3，it+4</span></span><br><span class="line">    </span><br><span class="line">    println(strlist.map&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125;) </span><br><span class="line">    <span class="comment">/* 返回的类型是List，也就是一个List里嵌套一个List</span></span><br><span class="line"><span class="comment">    打印结果：[[a1,a2,a3,a4],[b1,b2,b3,b4],[c1,c2,c3,c4]]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Kotlin中还提供了一个flatten()函数，效果是把嵌套的List结构“平铺”，变成一层的结构</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(strlist.map&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125;.flatten())<span class="comment">//"平铺"函数，把嵌套在List中的元素“平铺”成一层List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打入结果：[a1,a2,a3,a4,b1,b2,b3,b4,c1,c2,c3,c4]</span></span><br></pre></td></tr></table></figure>



<p>flatMap函数式map和flat两个函数的“复合逻辑”，代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(strlist.flatMap&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125;)</span><br><span class="line"><span class="comment">//打印结果：[a1,a2,a3,a4,b1,b2,b3,b4,c1,c2,c3,c4]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-6-过滤函数"><a href="#1-6-过滤函数" class="headerlink" title="1.6  过滤函数"></a>1.6  过滤函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">var</span> id:<span class="built_in">Long</span>,<span class="keyword">var</span> name:String,<span class="keyword">val</span> age:<span class="built_in">Int</span>,<span class="keyword">var</span> score:<span class="built_in">Int</span>)&#123;</span><br><span class="line">         <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"Student(id=<span class="variable">$id</span>,name=<span class="variable">$name</span>,age=<span class="variable">$age</span>,score=<span class="variable">$score</span>)"</span></span><br><span class="line">             <span class="comment">//重写toString()函数，是为了看到打印信息</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> studentList=listOf(</span><br><span class="line">        Student(<span class="number">1</span>,<span class="string">"Jack"</span>,<span class="number">18</span>,<span class="number">90</span>),</span><br><span class="line">        Student(<span class="number">2</span>,<span class="string">"Kim"</span>,<span class="number">19</span>,<span class="number">89</span>),</span><br><span class="line">        Student(<span class="number">3</span>,<span class="string">"Alice"</span>,<span class="number">17</span>,<span class="number">88</span>)</span><br><span class="line">    )</span><br><span class="line">    println(studentList.filter&#123;it-&gt;it.age&gt;<span class="number">18</span>&#125;)</span><br><span class="line">    <span class="comment">//打印结果：[Student(id=2,name=Kim,age=19,score=89)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外，如果想要通过访问下标来过滤，可以使用filterIndexed()函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">println(list.filterIndexed&#123;index, it-&gt;index%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;it&gt;<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">/*带下标过滤List中的元素</span></span><br><span class="line"><span class="comment">打印结果：[5,7]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>filterIndexed()函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filterIndexed</span><span class="params">(predicate:(<span class="type">index</span>:<span class="type">Int</span>,<span class="type">T</span>)-&gt;<span class="type">Boolean</span>)</span></span>:List&lt;T&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-7-排序函数"><a href="#1-7-排序函数" class="headerlink" title="1.7  排序函数"></a>1.7  排序函数</h3><h4 id="1-7-1-Kotlin-集合类中提供了倒序列集合类元素的函数reversed-，代码示例如下："><a href="#1-7-1-Kotlin-集合类中提供了倒序列集合类元素的函数reversed-，代码示例如下：" class="headerlink" title="1.7.1 Kotlin 集合类中提供了倒序列集合类元素的函数reversed()，代码示例如下："></a>1.7.1 Kotlin 集合类中提供了倒序列集合类元素的函数reversed()，代码示例如下：</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">set</span>=setOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">list.reversed()   <span class="comment">//倒序函数，返回[7,6,5,4,3,2,1]</span></span><br><span class="line"><span class="keyword">set</span>.reversed()    <span class="comment">//倒序函数，返回[2,3,1]</span></span><br><span class="line"><span class="comment">//这里的倒序函数，指的是index下标的倒序，而不是value的倒序</span></span><br></pre></td></tr></table></figure>

<p>这个Iterable的扩展函数reversed()是直接调用的java.util.Collection.reverse()方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span>Iterable<span class="type">&lt;T&gt;</span>.<span class="title">reversed</span><span class="params">()</span></span>:List&lt;T&gt;&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">is</span> Collection &amp;&amp; size&lt;=<span class="number">1</span>) <span class="keyword">return</span> toList()</span><br><span class="line">   <span class="keyword">val</span> list = toMutableList()</span><br><span class="line">   list.reverse()  <span class="comment">//调用Java中List类型的reverse()方法</span></span><br><span class="line">   <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;</span><br><span class="line">    java.util.Collection.reverse(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-7-2-升序排序函数sorted"><a href="#1-7-2-升序排序函数sorted" class="headerlink" title="1.7.2  升序排序函数sorted()"></a>1.7.2  升序排序函数sorted()</h4><p>升序排序函数sorted()，是对List、Set进行value值的升序排序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(list.sorted())  <span class="comment">//打印结果：[1,2,3,4,5,6,7]</span></span><br><span class="line">println(<span class="keyword">set</span>.sorted())   <span class="comment">//打印结果：[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>Kotlin中的这个sorted()函数也是直接调用Java的API来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> fun &lt;T :Comparable&lt;T&gt;&gt;Iterable&lt;T&gt;.sorted():List&lt;T&gt;&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span> is Collection)&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.toList()</span><br><span class="line">        <span class="meta">@Suppress</span>(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">        <span class="keyword">return</span>(toTypeArray&lt;Comparable&lt;T&gt;&gt;()as Array&lt;T&gt;).apply&#123;sort()&#125;.asList()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> toMutableList().apply&#123;sort()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其背后调用的是Java.util.Arrays.sort()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> fun&lt;T&gt;Array&lt;out T&gt;.sort():Unit&#123;</span><br><span class="line">   it(size&gt;<span class="number">1</span>)</span><br><span class="line">   java.util.Arrays.sort(<span class="keyword">this</span>)  <span class="comment">//调用Java中Arrays类型的sort方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-8-元素去重"><a href="#1-8-元素去重" class="headerlink" title="1.8  元素去重"></a>1.8  元素去重</h3><p>如果我们想对一个List列表进行元素去重，可以直接调用distinct()函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dupList=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">dupList.distinct()   <span class="comment">//去重函数，返回[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>Kotlin的集合类中还提供了许多功能丰富的API，此处不再一一介绍。更多内容可以参考官方API文档。</p>
<p>http:// kotlinlang.org/ api/ latest/ jvm/ stdlib/ kotlin.collections/ index.html</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo错误解决</title>
    <url>/2020/04/04/hexo%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="今天遇到的hexo错误，记录下以免以后遇到忘记。"><a href="#今天遇到的hexo错误，记录下以免以后遇到忘记。" class="headerlink" title="今天遇到的hexo错误，记录下以免以后遇到忘记。"></a>今天遇到的hexo错误，记录下以免以后遇到忘记。</h1><a id="more"></a>

<h2 id="1-当执行新建文章命令时："><a href="#1-当执行新建文章命令时：" class="headerlink" title="1. 当执行新建文章命令时："></a>1. 当执行新建文章命令时：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"text"</span></span><br></pre></td></tr></table></figure>

<p>默认[layout]为post。布局.md文件都在scaffolds文件夹下，共有post、draft、page三种。</p>
<p>执行完命令报错：</p>
<table>
<thead>
<tr>
<th>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<p>该错误的原因：是文章或文章布局中的属性: 后面没有空格。当然要是一些配置文件：后面没有空格的话肯定也会报错误。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line">copyright: </span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>后面发现后加了空格，但是不小心又点击了哪里把格式给弄乱了，虽然：后面都有空格，但是用Typora工具查看是下面少了一行虚线，于是就报了如下错误：</p>
<table>
<thead>
<tr>
<th>Cannot read property ‘replace’ of undefined</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<p>看了很多帖子也没有太好的解决办法，于是我猜想就跟那一行虚线有关，其他layout文件用Typora工具打开后是有虚线的，于是我就复制了page.md, 更名为post.md。于是重新执行hexo new命令，结果就解决问题了</p>
<p>归根结底还是冒号(:)后面没有加空格的原因。希望以后多多注意！！！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery-find函数</title>
    <url>/2020/04/15/jQuery-find%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>jQuery.find()函数</p>
<a id="more"></a>

<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>find()函数用于选取每个匹配元素的符合指定表达式的后代元素，并以JQuery对象的方式返回。这里的表达式包括：选择器(字符串)、DOM元素(Element)、jQuery对象。该函数属于JQuery对象(实例)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQueryObject.find(expr)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>expr</td>
<td>String/Element/jQuery类型指定的表达式</td>
</tr>
</tbody></table>
<p>find()函数将在当前JQuery对象每个匹配元素的所有后代元素中筛选符合指定表达式的元素。如果expr参数为字符串，则将其视作jQuery选择器，用以表示该选择器所匹配的元素。jQuery1.6新增支持：参数expr可以为DOM元素(Element)或jQuery对象。</p>
<h2 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h2><p>find()函数的返回值为jQuery类型，返回一个新的jQuery对象，该对象封装了当前jQuery对象匹配元素的所有符合指定选择器的后代元素。</p>
<p>如果没有匹配的元素，则返回空 的jQuery对象。</p>
<h2 id="示例-amp-说明："><a href="#示例-amp-说明：" class="headerlink" title="示例&amp;说明："></a>示例&amp;说明：</h2>]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中关键字与修饰符</title>
    <url>/2020/04/16/kotlin%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>kotlin中的修饰符关键字主要分为</p>
<a id="more"></a>

<ul>
<li>类修饰符</li>
<li>成员修饰符</li>
<li>访问权限修饰符</li>
<li>协变逆变修饰符</li>
<li>函数修饰符</li>
<li>属性修饰符</li>
<li>参数修饰符</li>
<li>具体化类型修饰符</li>
</ul>
<p>​                                 表2-1 kotlin中的类修饰符</p>
<table>
<thead>
<tr>
<th align="center">类修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abstract</td>
<td align="center">抽象类</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">不可被继承final类</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">枚举类</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">可继承open类</td>
</tr>
<tr>
<td align="center">annotation</td>
<td align="center">注解类</td>
</tr>
<tr>
<td align="center">scaled</td>
<td align="center">密封类</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">数据类</td>
</tr>
</tbody></table>
<p>​                               表2-2  kotlin中的成员修饰符</p>
<table>
<thead>
<tr>
<th align="center">成员修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">override</td>
<td align="center">重写函数(方法)</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">声明函数可被重写</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">声明函数不可被重写</td>
</tr>
<tr>
<td align="center">abstract</td>
<td align="center">声明函数为抽象函数</td>
</tr>
<tr>
<td align="center">lateinit</td>
<td align="center">延迟初始化</td>
</tr>
</tbody></table>
<p>​                             表2-3 kotlin中的访问权限修饰符</p>
<table>
<thead>
<tr>
<th align="center">访问权限修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">私有，仅当前类可访问</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">当前类以及继承该类的可访问</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">默认值，对外可访问</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="center">整个模块内可访问(模块是指一起编译的一组kotlin源代码文件。例如，一个Maven工程，或Gradle工程，通过Ant任务的一次调用编译的一组文件等)</td>
</tr>
</tbody></table>
<p>​                         表2-4  空调连载中的协变逆变修饰符</p>
<table>
<thead>
<tr>
<th>协变逆变修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>生产者类型修饰符，in T 等价于 ?super T</td>
</tr>
<tr>
<td>out</td>
<td>消费者类型修饰符，out T 等价于 ?extends T</td>
</tr>
</tbody></table>
<p>​                                       表2-5  kotlin中的函数修饰符</p>
<table>
<thead>
<tr>
<th align="center">函数修饰符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tailrec</td>
<td align="left">尾递归</td>
</tr>
<tr>
<td align="center">operator</td>
<td align="left">运算符重载函数</td>
</tr>
<tr>
<td align="center">infix</td>
<td align="left">中缀函数。例如，给Int定义扩展中缀函数 infix fun Int.shl(x:Int): Int</td>
</tr>
<tr>
<td align="center">inline</td>
<td align="left">内联函数</td>
</tr>
<tr>
<td align="center">external</td>
<td align="left">外部函数</td>
</tr>
<tr>
<td align="center">suspend</td>
<td align="left">挂起协程函数</td>
</tr>
</tbody></table>
<p>​                                              表2-6 kotlin中的属性修饰符</p>
<table>
<thead>
<tr>
<th align="center">属性修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const</td>
<td>常量修饰符</td>
</tr>
</tbody></table>
<p>​                                            表2-7  kotlin中的参数修饰符</p>
<table>
<thead>
<tr>
<th>参数修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vararg</td>
<td>变长参数修饰符</td>
</tr>
<tr>
<td>noinline</td>
<td>不内联参数修饰符，有时，只需要将内联函数的部分参数使用内联Lambda，其他的参数不需要内联，可以使用noinline关键字修饰。例如：inline fun foo(inlined:()-&gt;Unit, noinline notInlined:()-&gt;Unit)</td>
</tr>
<tr>
<td>crossinline</td>
<td>首先，默认内联函数的Lambda表达式参数是允许非局部返回的，即：     fun outterFun(){                                                                                                                                                        innerFun{                                                                                                                                        retuurn   //支持直接返回outterFun                                                             }}                                                                                                               而使用crossinline限制Lambda表达式直接非局部return返回。                    这样做的原因是：                                                                                          一些内联函数可能通用传给它们的不是直接来自函数体，而是来自另一个执行上下文 的Lambda表达式参数，如来自局部对象或嵌套函数。在这种情况下，该Lambda表达式中也是禁止直播return的。为了标识这种情况，该Lambda表达式参数需要用crossinline修饰符标记。</td>
</tr>
</tbody></table>
<p>​                                               表2-8  kotlin中的具体化类型修饰符</p>
<table>
<thead>
<tr>
<th align="center">具体化类型修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reified</td>
<td align="center">具体化类型参数</td>
</tr>
</tbody></table>
<p>一个crossinline代码实例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(<span class="keyword">crossinline</span> body: ()-&gt;<span class="type">Unit</span>)</span></span>&#123;<span class="comment">//内联函数f的body参数是一个Lambda</span></span><br><span class="line">   <span class="keyword">val</span> f=<span class="keyword">object</span>: Runnable&#123;   <span class="comment">//在对象表达式中使用body参数</span></span><br><span class="line">         <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>=body() <span class="comment">//参数标记为crossinline后,return操作将不被允许</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的修饰符关键字之外，还有一些特殊语义的关键字如表2-9所示。</p>
<p>​                                              表2-9  kotlin中的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>package</td>
<td>包声明</td>
</tr>
<tr>
<td>as</td>
<td>类型转换</td>
</tr>
<tr>
<td>typealias</td>
<td>类型别名</td>
</tr>
<tr>
<td>class</td>
<td>声明类</td>
</tr>
<tr>
<td>this</td>
<td>当前对象引用</td>
</tr>
<tr>
<td>super</td>
<td>父亲对象引用</td>
</tr>
<tr>
<td>val</td>
<td>声明不可变变量</td>
</tr>
<tr>
<td>var</td>
<td>声明可变变量</td>
</tr>
<tr>
<td>fun</td>
<td>声明函数</td>
</tr>
<tr>
<td>for</td>
<td>for循环</td>
</tr>
<tr>
<td>null</td>
<td>特殊值null</td>
</tr>
<tr>
<td>true</td>
<td>真值</td>
</tr>
<tr>
<td>false</td>
<td>假值</td>
</tr>
<tr>
<td>is</td>
<td>类型判断</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常</td>
</tr>
<tr>
<td>return</td>
<td>返回值</td>
</tr>
<tr>
<td>break</td>
<td>跳出循环体</td>
</tr>
<tr>
<td>continue</td>
<td>继续下一次循环</td>
</tr>
<tr>
<td>object</td>
<td>单例类声明</td>
</tr>
<tr>
<td>if</td>
<td>逻辑判断if</td>
</tr>
<tr>
<td>else</td>
<td>逻辑判断，结合if使用</td>
</tr>
<tr>
<td>while</td>
<td>while循环</td>
</tr>
<tr>
<td>do</td>
<td>do循环</td>
</tr>
<tr>
<td>when</td>
<td>条件判断</td>
</tr>
<tr>
<td>interface</td>
<td>接口声明</td>
</tr>
<tr>
<td>file</td>
<td>文件</td>
</tr>
<tr>
<td>field</td>
<td>成员</td>
</tr>
<tr>
<td>property</td>
<td>属性</td>
</tr>
<tr>
<td>receiver</td>
<td>接收者</td>
</tr>
<tr>
<td>param</td>
<td>参数</td>
</tr>
<tr>
<td>setparam</td>
<td>设置参数</td>
</tr>
<tr>
<td>delegate</td>
<td>委托</td>
</tr>
<tr>
<td>import</td>
<td>导入包</td>
</tr>
<tr>
<td>where</td>
<td>where条件</td>
</tr>
<tr>
<td>by</td>
<td>委托类或属性</td>
</tr>
<tr>
<td>get</td>
<td>get函数</td>
</tr>
<tr>
<td>set</td>
<td>set函数</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数</td>
</tr>
<tr>
<td>init</td>
<td>初始化代码块</td>
</tr>
<tr>
<td>try</td>
<td>异常捕获</td>
</tr>
<tr>
<td>catch</td>
<td>异常捕获，结合try使用</td>
</tr>
<tr>
<td>finally</td>
<td>异常最终执行代码块</td>
</tr>
<tr>
<td>dynamic</td>
<td>动态的</td>
</tr>
<tr>
<td>typeof</td>
<td>类型定义，预留用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin操作符与重载</title>
    <url>/2020/04/18/kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="Kotlin操作与重载"><a href="#Kotlin操作与重载" class="headerlink" title="Kotlin操作与重载"></a>Kotlin操作与重载</h1><a id="more"></a>

<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="left">标题</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最高级</td>
<td align="left">后缀(Postfix)</td>
<td>++，–，.，?.，？</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">前缀(Prefix)</td>
<td>-，+，++，–，！，labelDefinition@</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">右手类型运算(Type RHS，right-hand side class type (RHS))</td>
<td>:，as，as?</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">乘除取余(Multiplicative)</td>
<td>*，/，%</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">加减(Additive)</td>
<td>+，-</td>
</tr>
<tr>
<td align="center">(优先级往下依次递减)</td>
<td align="left">区间范围(Range)</td>
<td>..</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">Infix 函数</td>
<td>例如，给Int定义扩展 infix fun Int.shl(x:Int):Int{…}，这样调用      1 shl 2，等同于1.shl(2)</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">Elvis操作符</td>
<td>?:</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">命名检查符(Named checks)</td>
<td>in，!in，is，!is</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">比较大小(Comparison)</td>
<td>&lt;，&gt;，&lt;=，&gt;=</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">相等性判断(Equality)</td>
<td>==，!=，===，!==</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">与(Conjunction)</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">或(Disjunction)</td>
<td>||</td>
</tr>
<tr>
<td align="center">最低</td>
<td align="left">赋值(Assignment)</td>
<td>=，+=，-=，*=，/=，%=</td>
</tr>
</tbody></table>
<p>kotlin重载操作符的函数需要使用operator修饰符标记，中缀操作符函数使用infix修饰符标记。</p>
<h2 id="1-1-一元操作符"><a href="#1-1-一元操作符" class="headerlink" title="1.1 一元操作符"></a>1.1 一元操作符</h2><p>一元操作符有前缀操作符、递增和递减操作符等。</p>
<h3 id="1-1-1-前缀操作符"><a href="#1-1-1-前缀操作符" class="headerlink" title="1.1.1 前缀操作符"></a>1.1.1 前缀操作符</h3><p>前缀操作符放在操作数的前面，分别如表所示。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
</tbody></table>
<p>一下是重载一元减运算符的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x:<span class="built_in">Int</span>,<span class="keyword">val</span> y:<span class="built_in">Int</span>)          <span class="comment">//声明数据类Point</span></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span>=Point(-x,-y)  <span class="comment">//operator修饰符修饰一个重载操作符函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPointUnaryMinus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p=Point(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> np=-p                <span class="comment">//直接使用unaryMinus()重载函数操作符"-"</span></span><br><span class="line">    println(np)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testPointUnaryMinus()   <span class="comment">//调用函数</span></span><br><span class="line">    <span class="comment">/*输出 Point(x=-1,y=-1)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-递增和递减操作符"><a href="#1-1-2-递增和递减操作符" class="headerlink" title="1.1.2 递增和递减操作符"></a>1.1.2 递增和递减操作符</h3><p>inc()和dec()函数必须返回一个值，它用于赋值给使用++或–操作的变量。前缀和后缀的表达式的返回值是不同的。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a++</td>
<td align="center">a.inc()返回值是a</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()返回值是a</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">a.inc()返回值是a+1</td>
</tr>
<tr>
<td align="center">–a</td>
<td align="center">a.dec()返回值是a-1</td>
</tr>
</tbody></table>
<h2 id="2-二元操作符"><a href="#2-二元操作符" class="headerlink" title="2. 二元操作符"></a>2. 二元操作符</h2><p>Kotlin中的二元操作符有算术运算符、索引访问操作符、调用操作符、计算并赋值操作符、相等与不相等操作符、Elvis操作符、比较操作符、中缀操作符等。</p>
<h3 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h3><p>Kotlin算数运算符有加、减、乘、除、取余、范围操作符等。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a+b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a-b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a*b</td>
<td align="center">a.temes(b)</td>
</tr>
<tr>
<td align="center">a/b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a%b</td>
<td align="center">a.rem(b)、a.mod(b)</td>
</tr>
<tr>
<td align="center">a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
</tbody></table>
<h3 id="2-2-字符串的”-”运算符重载"><a href="#2-2-字符串的”-”运算符重载" class="headerlink" title="2.2 字符串的”+”运算符重载"></a>2.2 字符串的”+”运算符重载</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>+<span class="number">1</span>    <span class="comment">//String 类型重载了加法操作符</span></span><br><span class="line"><span class="number">1</span>+<span class="string">""</span>   <span class="comment">//Int类型没有重载操作符 plus(other:String) 这种形式会报错</span></span><br><span class="line"><span class="number">1</span>.toString()+<span class="string">""</span>  <span class="comment">//先把Int类型的1转换成String再相加1，显示调用toString()函数</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-自定义重载的”-”运算符"><a href="#2-3-自定义重载的”-”运算符" class="headerlink" title="2.3 自定义重载的”+”运算符"></a>2.3 自定义重载的”+”运算符</h3><p>下面使用一个计数类Counter重载的”+”运算符来增加index的计数值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>(<span class="keyword">var</span> index:<span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Counter.<span class="title">plus</span><span class="params">(increment:<span class="type">Int</span>)</span></span>:Counter&#123;</span><br><span class="line">         <span class="keyword">return</span> Counter(index+increment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCounterIndexPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> a=Counter(<span class="number">1</span>)  <span class="comment">//声明一个Counter对象，初始化为1</span></span><br><span class="line">  <span class="keyword">val</span> ap=a+<span class="number">12</span>       <span class="comment">//调用自定义重载"+"运算符</span></span><br><span class="line">  println(ap)       <span class="comment">//打印变量ap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testCounterIndexPlus()   <span class="comment">//调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：Counter(13)*/</span></span><br></pre></td></tr></table></figure>



<h3 id="2-4-in操作符"><a href="#2-4-in操作符" class="headerlink" title="2.4 in操作符"></a>2.4 in操作符</h3><p>in操作符等价于contains()函数</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a in b</td>
<td align="center">b.contains(a)</td>
</tr>
<tr>
<td align="center">a !in b</td>
<td align="center">!b.contains(a)</td>
</tr>
</tbody></table>
<h3 id="2-5-索引访问操作符"><a href="#2-5-索引访问操作符" class="headerlink" title="2.5  索引访问操作符"></a>2.5  索引访问操作符</h3><p>索引访问操作符方括号[]转换为调用带有适当数量参数的get和set</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a[i]</td>
<td align="center">a.get(i)</td>
</tr>
<tr>
<td align="center">a[i]=b</td>
<td align="center">a.set(i,b)</td>
</tr>
</tbody></table>
<h3 id="2-6-调用操作符"><a href="#2-6-调用操作符" class="headerlink" title="2.6 调用操作符"></a>2.6 调用操作符</h3><p>小括号调用符()转换为调用invoke()，同样带参数调用也会转换为invoke()函数中的参数。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a()</td>
<td align="center">a.invoke()</td>
</tr>
<tr>
<td align="center">a(i)</td>
<td align="center">a.invoke(i)</td>
</tr>
</tbody></table>
<h3 id="2-7-计算并赋值操作符"><a href="#2-7-计算并赋值操作符" class="headerlink" title="2.7 计算并赋值操作符"></a>2.7 计算并赋值操作符</h3><p>对于赋值操作，例如a+=b，编译器会试着生成a=a+b的代码(这里包含类型检查：a+b的类型必须是a的子类型)。计算并赋值操作符对应的重载函数</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a+=b</td>
<td align="center">a.plusAssign(b)</td>
</tr>
<tr>
<td align="center">a-=b</td>
<td align="center">a.minusAssign(b)</td>
</tr>
<tr>
<td align="center">a*=b</td>
<td align="center">a.timesAssign(b)</td>
</tr>
<tr>
<td align="center">a/=b</td>
<td align="center">a.divAssign(b)</td>
</tr>
<tr>
<td align="center">a%=b</td>
<td align="center">a.modAssign(b)</td>
</tr>
</tbody></table>
<h3 id="2-8-相等与不相等操作符"><a href="#2-8-相等与不相等操作符" class="headerlink" title="2.8 相等与不相等操作符"></a>2.8 相等与不相等操作符</h3><p>Kotlin中 有两种类型的相等性：</p>
<ul>
<li><p>引用相等===！==(两个引用指向同一对象)；</p>
</li>
<li><p>结构相等==!=(使用equals()判断)</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a==b</td>
<td>a?.equals(b)?:(b=null)</td>
</tr>
<tr>
<td>a!=b</td>
<td>!(a?.equals(b)?:(b==null))</td>
</tr>
</tbody></table>
<p>“==” 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选null值。意思是：如果a不是null则调用equals(Any?)函数并返回其值；否则(即a===null)就计算b===null的值并返回。</p>
<p>注意：===和 !==不可重载</p>
</li>
</ul>
<h3 id="2-9-Elvis-操作符？"><a href="#2-9-Elvis-操作符？" class="headerlink" title="2.9 Elvis 操作符？"></a>2.9 Elvis 操作符？</h3><p>在kotlin中，Elvis操作符特定是跟null进行比较。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">y=x?:<span class="number">0</span>    <span class="comment">//使用Elvis操作符?:</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">val</span> y=<span class="keyword">if</span>(x!==<span class="literal">null</span>)x <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>主要用来作null安全性检查。</p>
<p>Kotlin中没有这样的三元符号true?1:0取而代之的是if(true)1 else 0. 而Elvis操作符算是精简版的三元运算符。</p>
<p>在java中使用的三元运算符的语法通常要重复变量两次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">"Elvis Presley"</span>;</span><br><span class="line">String displayName=(name!=<span class="keyword">null</span>)name:<span class="string">"Unknown"</span> <span class="comment">//java中的三元操作符</span></span><br></pre></td></tr></table></figure>

<p>可以使用Elvis操作符取而代之：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"Elvis Presley"</span></span><br><span class="line"><span class="keyword">val</span> displayName=name?:<span class="string">"Unknown"</span> <span class="comment">//使用Elvis操作符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> y=x?:<span class="number">0</span>    <span class="comment">//使用Elvis操作符</span></span><br><span class="line">println(y)    <span class="comment">//等价逻辑：if(x!==null) x else 0，此处x===null, 所以选择else分支，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x=<span class="literal">false</span></span><br><span class="line"><span class="keyword">val</span> y=x?:<span class="number">0</span></span><br><span class="line">println(y) <span class="comment">//x!==null,所以y的值为x，即为false</span></span><br></pre></td></tr></table></figure>



<h3 id="2-10-比较操作符"><a href="#2-10-比较操作符" class="headerlink" title="2.10 比较操作符"></a>2.10 比较操作符</h3><p>Kotlin中所有的比较表达式都转换为对compareTo()函数的调用，这个函数需要返回Int值。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a&gt;b</td>
<td>a.compareTo(b)&gt;0</td>
</tr>
<tr>
<td>a&lt;b</td>
<td>a.compareTo(b)&lt;0</td>
</tr>
<tr>
<td>a&gt;=b</td>
<td>a.compareTo(b)&gt;=0</td>
</tr>
<tr>
<td>a&lt;=b</td>
<td>a.compareTo(b)&lt;=0</td>
</tr>
</tbody></table>
<h3 id="2-11-用infix函数自定义中缀操作符"><a href="#2-11-用infix函数自定义中缀操作符" class="headerlink" title="2.11 用infix函数自定义中缀操作符"></a>2.11 用infix函数自定义中缀操作符</h3><p>我们可以通过自定义infix函数来实现中缀操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> age:<span class="built_in">Int</span>)  <span class="comment">//声明Person数据类</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Person.<span class="title">grow</span><span class="params">(years:<span class="type">Int</span>)</span></span>:Person&#123; <span class="comment">//声明Person类型的中缀操作符函数</span></span><br><span class="line">    <span class="keyword">return</span> Person(name,age+years)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> person=Person(<span class="string">"kim"</span>,<span class="number">20</span>)</span><br><span class="line">    println(person.grow(<span class="number">5</span>))  <span class="comment">//直接调用函数</span></span><br><span class="line">    println(person grow <span class="number">5</span>)   <span class="comment">//中缀表达式调用方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testPerson()</span><br><span class="line">    <span class="comment">/*结果为Person(name=kim,age=25)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin知识点记录</title>
    <url>/2020/04/04/kotlin%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>kotlin学习记录</p>
<a id="more"></a>

<p>kotlin和java的使用方法有所区别。Kotlin下载Android Studio后就可以使用。<a href="https://developer.android.com/kotlin/learn" target="_blank" rel="noopener">kotlin文档</a></p>
<p>kotlin使用两个不同的关键字（即val和var）来声明变量。</p>
<ol>
<li>val 用于值从不更改的变量。不能使用val声明的变量重新赋值。就相当于java中的final。</li>
<li>var 用于可以更改的变量。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp: <span class="built_in">Int</span>=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，count是一个Int类型的变量，为其赋予的初始值为10：</p>
<p>Kotlin出了Int类型的，还有Byte、Short、Long、Float和Double、String类型的变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name1: String =<span class="string">"kotlin"</span></span><br><span class="line">name1=<span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name2: String =<span class="string">"kotlin"</span></span><br><span class="line">name2=<span class="string">"helloworld"</span></span><br></pre></td></tr></table></figure>

<p>如上例，name1为val，因此name1被赋值后仍是”kotlin”。而name2是var，被赋值后可以改变，因此name2的值变更为”helloword”。</p>
<p>（注：kotlin编译器可根据所赋值的类型来推断类型，kotlin是一种静态类型的语言。String类型的变量也只能调用String类型的函数）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">num.inc()     <span class="comment">//num.inc()的结果为2，但是num的值并不会变，且num++这种方式kotlin不支持</span></span><br><span class="line">num+=<span class="number">1</span>    <span class="comment">//这种方式kotlin是支持的，执行完后，num=2</span></span><br></pre></td></tr></table></figure>

<h2 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h2><p>在某些语言中，可以声明引用类型变量而不明确提供初始值。在这些情况下，变量通常包含null值。默认情况下，Kotlin变量不能持有null。下段代码无效：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String =<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>要使变量持有null值，它必须是为null类型。可以在变量类型后面加上？后缀，可以将变量指定为null</p>
<p>如下所示:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String?=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>指定String?类型后，可以将name赋值为null或具体的字符串。</p>
<p>当变量被声明为可空类型后，并不能像非空变量那样被调用。可空类型String？只有使用安全调用符(?.)和非空断言调用符(?)才允许调用其方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String?=<span class="string">"abc"</span> <span class="comment">//声明一个可以为空的字符串变量name，且是var类型的变量，即后面可以更改其值。</span></span><br><span class="line">name.length    <span class="comment">//以这种形式调用声明的可空变量则是错误的，系统会提示报错</span></span><br><span class="line">name?.length  <span class="comment">//使用安全调用符</span></span><br><span class="line"></span><br><span class="line">name=<span class="literal">null</span>   <span class="comment">//将var可空String变量name赋值为null</span></span><br><span class="line">name?.length <span class="comment">//再次安全调用length方法时，结果将返回null</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在kotlin中，必须在声明对象时初始化对象的属性。这意味着，当获取类的实例时，立即引用它的任何可访问属性。当调用Fragment#onCreateView之前，Fragment中的View对象尚未准备好进行扩充，所以要推迟View的属性初始化。可以使用 lateinit 推迟属性初始化。使用lateinit时，应尽快初始化属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> usernameEditText: EditText</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> passwordEditText: EditText</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> loginButton: Button</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> statusTextView: TextView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">            usernameEditText = view.findViewById(R.id.username_edit_text)</span><br><span class="line">            passwordEditText = view.findViewById(R.id.password_edit_text)</span><br><span class="line">            loginButton = view.findViewById(R.id.login_button)</span><br><span class="line">            statusTextView = view.findViewById(R.id.status_text_view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> String accessId;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当变量带有@Nullable注解时，表示它可空，kotlin会将accessId视为String？</p>
<p>要指明变量绝不能为null，则使用@NonNull注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> String name;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果要修剪name以使其值不包含前导或尾随空格，则可以使用Kotlin的 trim函数。通过几种不同的方式安全地修剪String？。其中一种方式是使用非null断言预算符！！，如下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name!!.trim()</span><br></pre></td></tr></table></figure>

<p>！！运算符将其左侧的所有内容视为非null，一次，在本例中，将name视为非null String。 如果它左侧表达式的结果为null，则应用会抛出NullPointerException。</p>
<p>更安全的选择是使用安全调用运算符?.   ，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name?.trim()</span><br></pre></td></tr></table></figure>

<p>使用安全调用运算符时，如果 <code>name</code> 不为 null，则 <code>name?.trim()</code> 的结果是一个不带前导或尾随空格的名称值。如果 <code>name</code> 为 null，则 <code>name?.trim()</code> 的结果为 <code>null</code>。这意味着，在执行此语句时，您的应用永远不会抛出 <code>NullPointerException</code>。</p>
<p>虽然安全调用运算符可使您避免潜在的 <code>NullPointerException</code>，但它会将 null 值传递给下一个语句。您可以使用 Elvis 运算符 (<code>?:</code>) 来紧接着处理 null 值的情况，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name?.trim() ?: <span class="string">"Default name"</span></span><br></pre></td></tr></table></figure>

<p>如果 Elvis 运算符左侧表达式的结果为 null，则会将右侧的值赋予 <code>accountName</code>。此方法对于提供本来为 null 的默认值很有用。</p>
<p>您还可以使用 Elvis 运算符提前从函数返回结果，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validateAccount</span><span class="params">(account: <span class="type">Account</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> accountName = account?.name?.trim() ?: <span class="string">"Default name"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// account cannot be null beyond this point</span></span><br><span class="line">        account ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android-kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin流程控制语句</title>
    <url>/2020/04/16/kotlin%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="Kotlin流程控制语句"><a href="#Kotlin流程控制语句" class="headerlink" title="Kotlin流程控制语句"></a>Kotlin流程控制语句</h1><a id="more"></a>

<h2 id="1-if表达式"><a href="#1-if表达式" class="headerlink" title="1. if表达式"></a>1. if表达式</h2><p>if是一个表达式，即它会返回一个值(跟scala一样)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> max=<span class="keyword">if</span>(a&gt;b) a <span class="keyword">else</span> b  <span class="comment">//max定义为val类型，因为max后面不会被改变当a&gt;b时，max=a</span></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     println(<span class="string">"max="</span>+max(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if的分支可以是代码块，最后一行的表达式作为该块的值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">   <span class="keyword">val</span> max=<span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">     println(<span class="string">"Max is a"</span>)</span><br><span class="line">     a</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">"Max is b"</span>)</span><br><span class="line">      b</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin没有类似true?1:0这样的三元表达式。对应的写法是使用if…else语句。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLeapYear</span><span class="params">(year:<span class="type">Int</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLeapYear:<span class="built_in">Boolean</span></span><br><span class="line">  <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))&#123;</span><br><span class="line">    isLeapYear=<span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     isLeapYear=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isLeapYear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  println(isLeapYear(<span class="number">2017</span>))</span><br><span class="line">  println(isLeapYear(<span class="number">2020</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-when表达式"><a href="#2-when表达式" class="headerlink" title="2. when表达式"></a>2. when表达式</h2><p>when 表达式类似于switch…case表达式。when会对所有的分支进行检查直到有一个条件被满足。但相比switch而言，when语句的功能要更加强大、灵活。when语句的每一个分支也可以是一个代码块，它的值是块中最后的表达式的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">casesWhen</span><span class="params">(obj:<span class="type">Any</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">when</span>(obj)&#123;</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> -&gt;println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这是0-9之间的数字"</span>)<span class="comment">//若有多个分支条件放在一起，用逗号隔开</span></span><br><span class="line">        <span class="string">"hello"</span>-&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这个是字符串hello"</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Char</span> -&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这个是Char类型数据"</span>)<span class="comment">//is是类型判断</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;else类似于java中的case-swich中的default"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    casesWhen(<span class="number">6</span>)</span><br><span class="line">    casesWhen(<span class="string">"hello"</span>)</span><br><span class="line">    casesWhen(<span class="string">'X'</span>)</span><br><span class="line">    casesWhen(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以检测一个值在in或不在!in一个区间或者集合中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">casewhen</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> x=<span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> validNumbers = arrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">when</span>(x)&#123;</span><br><span class="line">     <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt;print(<span class="string">"x is in the range"</span>)  <span class="comment">//是否在范围1..10</span></span><br><span class="line">     <span class="keyword">in</span> validNumbers -&gt;print(<span class="string">"x is valid"</span>)   <span class="comment">//是否在数据arrayof(1,2,3)中</span></span><br><span class="line">     !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>) <span class="comment">//不在范围10..20中</span></span><br><span class="line">     <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)  <span class="comment">//默认路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h2><p>如果想要通过索引遍历一个数组或者一个list，可以这么做：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)&#123;</span><br><span class="line"><span class="comment">//array.indices存储了数组array的下标序列</span></span><br><span class="line">  print(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，array.indices持有数组的下标列表。我们也可以使用函数withIndex()来遍历下标与对应的因素：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((index,value) <span class="keyword">in</span> array.withIndex())&#123;   <span class="comment">//带下标index来访问数据</span></span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另外，范围(Ranges)表达式也可用于循环中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>)&#123;  <span class="comment">//等同于1&lt;=i&amp;&amp;i&lt;=10</span></span><br><span class="line">  println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).forEach&#123;print(it)&#125;    <span class="comment">//上面代码简写</span></span><br></pre></td></tr></table></figure>

<h2 id="4-while循环"><a href="#4-while循环" class="headerlink" title="4. while循环"></a>4. while循环</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="number">10</span></span><br><span class="line">  <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    x-</span><br><span class="line">    println(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="number">10</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">     y=y+<span class="number">1</span></span><br><span class="line">     println(y)</span><br><span class="line">  &#125;<span class="keyword">while</span>(y&lt;<span class="number">20</span>)  <span class="comment">//while判断条件，y的作用域包含此处。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-return返回"><a href="#5-return返回" class="headerlink" title="5. return返回"></a>5. return返回</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=&#123;a+b&#125; <span class="comment">//直接使用表达式声明函数，注意到这里的&#123;&#125;表示</span></span><br><span class="line"><span class="comment">//当调用sumf(1,1)时，返回类型是一个函数()-&gt;kotlin.Int</span></span><br><span class="line"><span class="comment">//调用sumf(1,1).invoke()  返回的结果是2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=&#123;<span class="keyword">if</span>(a&gt;b)a <span class="keyword">else</span> b&#125;</span><br><span class="line"><span class="comment">//maxf(2,6) 的返回类型也是一个函数</span></span><br><span class="line"><span class="comment">//使用invoke()函数调用maxf(2,6)函数，返回值为6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sumf(1,1).invoke()和sumf(1,1)()的调用方式是等价的</span></span><br><span class="line"><span class="comment">/*在Kotlin中，()操作符对应的是类的重载函数，如invoke()我们使用()运算符来调用函数*/</span></span><br></pre></td></tr></table></figure>



<p>kotlin中return语句会从最近的函数或匿名函数中返回，但是在Lambda表达式中遇到return语句时，则直接返回最近的外层函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = intArrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//声明一个Int数值</span></span><br><span class="line">intArray.forEach&#123;</span><br><span class="line">  <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span> <span class="comment">//在Lambda表达式中的return直接返回最近的外层函数</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因此，结果为：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">当it为3时就会return，类似于break的作用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> 当给forEach传入一个匿名函数fun(a:Int)，这个匿名函数里的return的语句不会跳出forEach循环，类似于continue语句的效果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = intArrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//声明一个Int数值</span></span><br><span class="line">intArray.forEach&#123; <span class="function"><span class="title">fun</span><span class="params">(a:<span class="type">Int</span>)</span></span>&#123;  <span class="comment">//这是一个匿名函数</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">3</span>) <span class="keyword">return</span>   <span class="comment">//从最近的函数中返回，也就是上面的匿名函数fun(a:Int)，但是循环会继续，类似于continue语句。</span></span><br><span class="line">    println(a)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因此，结果为：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">当a为3时，从匿名函数中返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-1-标签-label"><a href="#5-1-标签-label" class="headerlink" title="5.1  标签(label)"></a>5.1  标签(label)</h2><p>在Kotlin中任何表达式都可以用标签(label)来标记。标签的格式为标识符后跟@符号，如abc@、——isOK@都是有效的标签。我们可以使用Label标签来控制return、break或continue语句的跳转(jump)行为。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array= intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    array.forEach <span class="symbol">here@</span>&#123; <span class="comment">//定义here@标签</span></span><br><span class="line">        <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@here</span> <span class="comment">//执行指令跳转到Lambda表达式标签here@处当it=3时，则会跳转下一个it=4的遍历循环。</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果则是输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>另外可以使用隐式标签、更加方便。该标签与接收该Lambda的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array= intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    array.forEach&#123; </span><br><span class="line">        <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//返回@forEach处继续下一个循环</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果则是输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>throw表达式</p>
<p>在kotlin中throw是表达式，它的类型是特殊类型Nothing。该类型没有值，与java中的void意思一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(msg:<span class="type">String</span>)</span></span>:<span class="built_in">Nothing</span>&#123;<span class="keyword">throw</span> IllegalArgumentException(msg)&#125;</span><br><span class="line"><span class="comment">//返回值为Nothing表示该函数永远不会返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   fail(<span class="string">"nihao"</span>)  <span class="comment">//调用fail函数，将会直接抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.IllegalArgumentException: nihao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果把一个throw表达式的值赋给一个变量，需要显示声明类型为Nothing，代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ex=<span class="keyword">throw</span> Exception(<span class="string">"nihao"</span>) <span class="comment">//ex需要显示声明类型为Nothing，否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ex:<span class="built_in">Nothing</span>=<span class="keyword">throw</span> Exception(<span class="string">"nihao"</span>)</span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.Exception: nihao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习</title>
    <url>/2020/04/03/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="今天你学Vue了吗-1"><a href="#今天你学Vue了吗-1" class="headerlink" title="今天你学Vue了吗?(1)"></a>今天你学Vue了吗?(1)</h1><a id="more"></a>

<p>  作为程序员中的小小白，对vue敬仰已久。这几天心血来潮，想学习一些基础的vue语法，请大佬们赐教。(vue是MVVM(model-view-viewmodel)模式)</p>
<h2 id="如何使用vue呢？"><a href="#如何使用vue呢？" class="headerlink" title="如何使用vue呢？"></a>如何使用vue呢？</h2><h3 id="1-可以直接在-html-文件中，引用一下代码使用Vue："><a href="#1-可以直接在-html-文件中，引用一下代码使用Vue：" class="headerlink" title="1. 可以直接在.html 文件中，引用一下代码使用Vue："></a>1. 可以直接在.html 文件中，引用一下代码使用Vue：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-还有更多安装Vue的方式。但不推荐新手直接使用-vue-cli，尤其不熟悉基于Node-js-的构建工具。"><a href="#2-还有更多安装Vue的方式。但不推荐新手直接使用-vue-cli，尤其不熟悉基于Node-js-的构建工具。" class="headerlink" title="2.还有更多安装Vue的方式。但不推荐新手直接使用 vue-cli，尤其不熟悉基于Node.js  的构建工具。"></a>2.还有更多安装Vue的方式。但不推荐新手直接使用 vue-cli，尤其不熟悉基于Node.js  的构建工具。</h3><h2 id="Coding-Show："><a href="#Coding-Show：" class="headerlink" title="Coding Show："></a>Coding Show：</h2><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM的系统：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">'#app'</span></span><br><span class="line">   data: &#123;</span><br><span class="line">     message: <span class="string">'Hello Vue!'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello Vue!</span><br></pre></td></tr></table></figure>

<p>vue的数据绑定。数据绑定是将数据和视图相关联，当数据发生变化时，可以自动更新视图。</p>
<p>以上代码便是数据绑定的例子。是文本插值，是最基本的方式，例子中的将会被相应的数据对象替换。当text的值变化时，文本的内容也会联动地发生变化。有时候只需要渲染一次数据，后续数据变化不再关心，可以通过“*”实现，代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span></span></span><br><span class="line"><span class="tag">   &#123;&#123;*<span class="attr">message</span>&#125;&#125;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>双大括号标签会把里面的值全部当作字符串来处理。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>spring之IoC(控制反转)和DI(依赖注入)</title>
    <url>/2020/04/28/spring%E4%B9%8BIoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="spring之IoC-控制反转-和DI-依赖注入"><a href="#spring之IoC-控制反转-和DI-依赖注入" class="headerlink" title="spring之IoC(控制反转)和DI(依赖注入)"></a>spring之IoC(控制反转)和DI(依赖注入)</h1><a id="more"></a>

<h2 id="1-什么是spring"><a href="#1-什么是spring" class="headerlink" title="1. 什么是spring"></a>1. 什么是spring</h2><p>  Spring是一个以IoC(Inversion of Control，控制反转)和AOP(Aspect Oriented Progromming)为内核的框架。IoC是Spring的基础。IoC实现的是一种控制，简单地说，就是以前调用new构造方法创建对象，现在变成了使用Spring来创建对象。DI(Dependency Inject，依赖注入)与IoC的含义相同，从两个角度描述同一个概念。简单地说，DI就是对象的属性，已经被注入相关值，直接使用即可。</p>
<h2 id="2-什么是IoC-控制反转"><a href="#2-什么是IoC-控制反转" class="headerlink" title="2. 什么是IoC(控制反转)"></a>2. 什么是IoC(控制反转)</h2><p>IoC(Inversion of control)，译为“控制反转” 或者 “控制倒置” 。</p>
<p>在面向对象传统编程方式中，获取对象的方式通常是用new关键字主动创建一个对象，Spring中的IoC方式对象的生命周期由Spring框架提供的IoC容器来管理，直接从IoC容器中获取一个对象，控制权从应用程序交给了IoC容器。</p>
<p>IoC理论上借助于“第三方” 实现具有依赖关系对象之间的解耦， 即把各个类封装之后，通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，而对象之间没有什么直接联系。</p>
<p>应用程序在没有引入IoC容器之前，对象A依赖对象B，那么A对象在实例化或者运行到某一点的时候。</p>
<p>A对象需要用new主动的来创建B对象。引入IoC之后，对象A获得依赖对象B的过程，由主动行为变为被动行为，即把创建对象的权利交给了IoC容器处理。控制权颠倒过来了，这就是所谓的控制反转。</p>
<p>个人认知：我们将需要的资源(Bean)描述出来，并传递给IoC容器，IoC容器便会自动的帮助我们找到需要的资源。将有依赖的Bean之间关系解耦。并且IoC也可以管理Bean的生命进程，可以延时加载，也可以在Bean定义时做某些事情.</p>
<h2 id="3-什么是DI-依赖注入"><a href="#3-什么是DI-依赖注入" class="headerlink" title="3. 什么是DI(依赖注入)"></a>3. 什么是DI(依赖注入)</h2><p>DI(Dependency Inject)，译为“依赖注入”。所谓依赖注入，就是由IoC容器在运行期间动态地将某种依赖关系注入对象之中。例如，将对象B注入(赋值)给对象A的成员变量。</p>
<p>事实上，依赖注入(DI)和控制反转(IoC)是对一个同一件事情的不同藐视，从某个方面将，就是它们描述的角度不同。依赖注入是从一个应用程序的角度描述，即应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度描述，即容器控制应用程序，由容器反向地向应用程序所需要的外部资源。这里说的外部资源可以是外部实例对象，也可以是外部文件对象等。</p>
<h2 id="4-使用IoC-DI给软件开发带来了多方面的益处。"><a href="#4-使用IoC-DI给软件开发带来了多方面的益处。" class="headerlink" title="4. 使用IoC/DI给软件开发带来了多方面的益处。"></a>4. 使用IoC/DI给软件开发带来了多方面的益处。</h2><p>(1) 可维护性比较好，便于单元测试、调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即，这就是组件(compont)之间低耦合或者无耦合带来的好处。</p>
<p>(2)每个开发团队的成员都只需要关注自己要实现的业务逻辑，完全不用关心其他人的工作进展，因为你的任务跟别人没有关系，你的任务可以单独测试，不用依赖于别人的组件，在也不会扯不清责任了。所以，在一个大中型项目中，团队成员分工明确，责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将地道大幅度的提高。</p>
<p>(3)可复用性好，我们可以把具有普遍性的常用组件独立出来，反复应用到项目中的其他部分，或者是其他项目，当然这也是面向对象的基本特征。显然，IoC更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现都可以插接到支持此标准的模块中。</p>
<p>(4) 生成对象的方式转为外置方式，就是把对象生成放在配置文件中进行定义。这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拔的特性。</p>
]]></content>
      <categories>
        <category>spring学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>win10+eclipse+maven+ssm环境搭建</title>
    <url>/2020/04/24/win10-eclipse-maven-ssm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="win10-eclipse-maven-ssm环境搭建"><a href="#win10-eclipse-maven-ssm环境搭建" class="headerlink" title="win10+eclipse+maven+ssm环境搭建"></a>win10+eclipse+maven+ssm环境搭建</h1><a id="more"></a>

<h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1.安装JDK"></a>1.安装JDK</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载JDK</a></p>
<p>注：JDK比较稳定的还是JDK8，按照自己的系统选择就好，将JDK安装入一个空目录文件夹下</p>
<p>接下来，配置JDK 的环境变量</p>
<ol>
<li><p>创建系统变量JAVA_HOME</p>
<p><img src="https://s1.ax1x.com/2020/04/24/Jrrql6.png" alt="img"></p>
</li>
</ol>
<ol start="2">
<li><p>引用JAVA_HOME变量，添加lib的路径和tool.jar文件的路径</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JryKVe.png" alt="img"></p>
</li>
</ol>
<ol start="3">
<li><p>将JDK中的bin文件的路径添加至系统Path中</p>
<img src="https://s1.ax1x.com/2020/04/24/JrsrnO.png" alt="img" style="zoom: 200%;" />



</li>
</ol>
<ol start="4">
<li><p>测试JDK是否安装成功，win+R输入cmd，然后在cmd中输入 java  命令，若是有java的用法提示，则表明安装成功，否则安装失败。</p>
<hr>
</li>
</ol>
<h2 id="2-安装Eclipse"><a href="#2-安装Eclipse" class="headerlink" title="2. 安装Eclipse"></a>2. 安装Eclipse</h2><p>   <a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载Eclipse</a></p>
<p>   下载完成后，打开eclipse-ins-win64.exe文件</p>
<p>   选择Eclipse IDE for Java EE Developers，直至完成</p>
<hr>
<h2 id="3-安装Maven"><a href="#3-安装Maven" class="headerlink" title="3. 安装Maven"></a>3. 安装Maven</h2><p>   <a href="http://maven.apache.org/download.cgi#" target="_blank" rel="noopener">下载Maven</a></p>
<p>   <img src="https://s1.ax1x.com/2020/04/25/Jsgr1s.png" alt="Download_Maven"></p>
<p>   如上图，可以选择zip压缩包的安装形式</p>
<h3 id="3-1-Maven环境变量的配置"><a href="#3-1-Maven环境变量的配置" class="headerlink" title="3.1  Maven环境变量的配置"></a>3.1  Maven环境变量的配置</h3><p>   win10-&gt;找到此电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p>
<p>   在系统变量中，配置Maven环境</p>
<ul>
<li><p>新增系统变量MAVEN_HOME</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Js2DUO.png" alt="MAVEN_HOME"></p>
<p>注：变量值为bin目录的上级目录</p>
</li>
<li><p>在Path中追加：%MAVEN_HOME%\bin</p>
</li>
<li><p>win+R打开cmd窗口输入：mvn -v, 如果如下图所示则说明maven配置成功</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsR9G4.png" alt="cmd_maven"></p>
</li>
</ul>
<h2 id="3-2-Maven仓库-Repository-设置"><a href="#3-2-Maven仓库-Repository-设置" class="headerlink" title="3.2 Maven仓库(Repository)设置"></a>3.2 Maven仓库(Repository)设置</h2><p>   Maven的仓库有三类，简单来说三个仓库的关系：</p>
<p>   <img src="https://s1.ax1x.com/2020/04/25/Jsh9JS.png" alt="maven_repertory"></p>
<h4 id="3-2-1-编辑setting-xml文件，maven仓库位置在下图"><a href="#3-2-1-编辑setting-xml文件，maven仓库位置在下图" class="headerlink" title="3.2.1 编辑setting.xml文件，maven仓库位置在下图"></a>3.2.1 编辑setting.xml文件，maven仓库位置在下图</h4><p>   <img src="https://s1.ax1x.com/2020/04/25/Jsh6TP.png" alt=""></p>
<ul>
<li><p>当直接访问maven公共仓库的速度会比较慢，所以这里推荐使用仓库镜像，这里使用阿里的maven仓库，在settings.xml文件中找到<mirrors>节点(添加镜像仓库)</p>
</li>
<li><p>在<mirrors>节点中添加如下代码(请添加到该节点原有注释之下)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到<localRepository>节点(该节点被注释掉了，直接在注释下方自己重新添加该节点并添加仓库路径)，加入以下内容(添加本地仓库)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\SoftTool\Maven\maven_repo\localrepo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加代码后如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsI7TI.png" alt="localRepository"></p>
</li>
<li><p>找到<profile>节点，加入如下内容(将默认JDK1.4设置为1.8)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="4-安装Tomcat"><a href="#4-安装Tomcat" class="headerlink" title="4. 安装Tomcat"></a>4. 安装Tomcat</h2><p>   <a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">下载Tomcat</a></p>
<p>   <img src="https://s1.ax1x.com/2020/04/25/JsdhQS.png" alt="img"></p>
<p>   按照上图选择合适的版本和系统配置下载</p>
<h3 id="4-1-环境变量的配置"><a href="#4-1-环境变量的配置" class="headerlink" title="4.1 环境变量的配置"></a>4.1 环境变量的配置</h3><p>   win10-&gt;找到此电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p>
<p>   然后在系统变量这一栏里，配置Tomcat的环境变量</p>
<ul>
<li><p>新建CATALINA_BASE变量</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyfzNV.png" alt="Tomcat"></p>
<p>注：其中变量名必须为CATALINA_BASE，否则Tomcat会找不到配置的环境变量。而变量值则是安装的Tomcat文件中bin目录的上级目录。</p>
</li>
</ul>
<ul>
<li><p>新建CATALINA_HOME变量</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyhPc4.png" alt="Tomcat"></p>
</li>
</ul>
<ul>
<li><p>找到Path变量，点击编辑，添加如下</p>
<img src="https://s1.ax1x.com/2020/04/25/JsDVyT.png" style="zoom:200%;" />



</li>
</ul>
<h3 id="4-3-验证Tomcat是否配置成功"><a href="#4-3-验证Tomcat是否配置成功" class="headerlink" title="4.3  验证Tomcat是否配置成功"></a>4.3  验证Tomcat是否配置成功</h3><p>   启动Tomcat服务的方式有很多种，这里值列举两种：</p>
<ul>
<li><p>方式一</p>
<ol>
<li><p>win+R搜索输入cmd，打开命令提示符窗口：</p>
</li>
<li><p>直接输入startup，按下Enter键，则会弹出一个标题栏为”Tomcat”的窗口，并出现如下图所示的信息。</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsrQHg.png" alt=""></p>
<p>注：先不要关闭黑窗口，否则等于Tomcat也关了，因为随后会打开浏览器验证</p>
</li>
</ol>
</li>
</ul>
<pre><code>3.  在浏览器的地址栏中输入：[http://localhost:8080/](http://localhost:8080/) 或[http://127.0.0.1:8080/](http://127.0.0.1:8080/)

   如果能够显示下图界面，则说明Tomcat配置成功

   ![Test_browser_Tomcat](https://s1.ax1x.com/2020/04/25/JyhQjH.png)



   * 方式二

     1. 找到Tomcat的安装目录下的bin文件

     2. 打开bin文件，找到startup.bat，双击打开该文件，会弹出跟方式一相同的Tomcat窗口(弹窗最后一句话：Server startup in 533 ms，就是说服务启动耗时533毫秒)

        如果想关闭Tomcat，那么只要双击bin文件下的shutdown.bat就可以了</code></pre><h3 id="4-4-Tomcat的详细配置-端口号，部署web应用，配置数据源"><a href="#4-4-Tomcat的详细配置-端口号，部署web应用，配置数据源" class="headerlink" title="4.4 Tomcat的详细配置(端口号，部署web应用，配置数据源)"></a>4.4 Tomcat的详细配置(端口号，部署web应用，配置数据源)</h3><p><a href="https://www.jb51.net/article/140516.htm" target="_blank" rel="noopener">Tomcat详细配置-&gt;脚本之家</a></p>
<hr>
<h2 id="5-Eclipse整合Maven"><a href="#5-Eclipse整合Maven" class="headerlink" title="5.  Eclipse整合Maven"></a>5.  Eclipse整合Maven</h2><p>打开Eclipse-&gt;Window-&gt;Preferences</p>
<p>设置顺序如下：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyNL38.png" alt=""></p>
<p>接着选择Installations节点-&gt;Add-&gt;Directory-&gt;Finish-&gt;勾选maven</p>
<p>Installation name可以自行修改</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JydwjS.png" alt=""></p>
<h2 id="6-使用Maven创建SSM项目"><a href="#6-使用Maven创建SSM项目" class="headerlink" title="6. 使用Maven创建SSM项目"></a>6. 使用Maven创建SSM项目</h2><h3 id="6-1-File-gt-new-gt-project-gt-maven-gt-maven-project"><a href="#6-1-File-gt-new-gt-project-gt-maven-gt-maven-project" class="headerlink" title="6.1  File-&gt;new-&gt;project-&gt;maven-&gt;maven-project"></a>6.1  File-&gt;new-&gt;project-&gt;maven-&gt;maven-project</h3><p>Filter选项选择web类型，(我的话有点慢，过了一阵子才有了Group Id，而且点击Configure后，在搜索框中输入web后，才显示出Group IP)</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyDjJA.png" alt=""></p>
<h3 id="6-2-填写GroupID、ArtifatID"><a href="#6-2-填写GroupID、ArtifatID" class="headerlink" title="6.2 填写GroupID、ArtifatID"></a>6.2 填写GroupID、ArtifatID</h3><ul>
<li><p>Group ID：相当于一个组织</p>
</li>
<li><p>Artifact ID：相当于这个组织下的一个具体项目</p>
</li>
<li><p>Packege：根据Group ID和Artifact ID生成一个默认的名称</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyygZ8.png" alt=""></p>
</li>
</ul>
<p>点击Finish后，会在本地仓库中创建出如下图所示的文件</p>
<img src="https://s1.ax1x.com/2020/04/25/JygNZV.png"  />



<h3 id="6-3-创建出的maven项目如下"><a href="#6-3-创建出的maven项目如下" class="headerlink" title="6.3 创建出的maven项目如下"></a>6.3 创建出的maven项目如下</h3><p><img src="https://s1.ax1x.com/2020/04/25/Jy2bc9.png" alt="project-structure"></p>
<p>创建ssm项目报错如下：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyRPcd.png" alt=""></p>
<h3 id="6-4-在eclipse中设置Server为Tomcat"><a href="#6-4-在eclipse中设置Server为Tomcat" class="headerlink" title="6.4 在eclipse中设置Server为Tomcat"></a>6.4 在eclipse中设置Server为Tomcat</h3><p>Eclipse-&gt;Window-&gt;preferences-&gt;Server-&gt;Runtime Enviroments-&gt;Add-&gt;在弹框type filter text处选择对应的Tomcat版本(这里选v9.0)-&gt;Next</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Jy58tP.png" alt=""></p>
<p>接着找到本地配置好的Tomcat，然后在JRE设置安装JDK的jre</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Jy5OnH.png" alt=""></p>
<h3 id="6-5-在工程上右键，查看工程属性-properties-，找到Java-Build-Path，添加Server-Runtime为Tomcat"><a href="#6-5-在工程上右键，查看工程属性-properties-，找到Java-Build-Path，添加Server-Runtime为Tomcat" class="headerlink" title="6.5 在工程上右键，查看工程属性(properties)，找到Java Build Path，添加Server Runtime为Tomcat"></a>6.5 在工程上右键，查看工程属性(properties)，找到Java Build Path，添加Server Runtime为Tomcat</h3><p><img src="https://s1.ax1x.com/2020/04/25/Jy7uCt.png" alt=""></p>
<p>点击Finish，并Apply</p>
<img src="https://s1.ax1x.com/2020/04/25/Jy7fxK.png"  />

<p>工程错误消失，但是jdk版本显示还是1.7</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyHRoj.png" alt=""></p>
<h3 id="6-6-还是在项目上右键，查看项目信息-properties-，选择project-facets"><a href="#6-6-还是在项目上右键，查看项目信息-properties-，选择project-facets" class="headerlink" title="6.6 还是在项目上右键，查看项目信息(properties)，选择project  facets"></a>6.6 还是在项目上右键，查看项目信息(properties)，选择project  facets</h3><p><img src="https://s1.ax1x.com/2020/04/25/J6AeOg.png" alt=""></p>
<p>默认的Dynamic Web Module为2.3，使用Tomcat v9，需要修改为4.0。这里无法直接选择修改成4.0，需要以下几个步骤设置：</p>
<ol>
<li><p>maven工程setting下org.eclipse.wst.common.project.facet.core.xml</p>
<p><img src="https://s1.ax1x.com/2020/04/25/J6VYdJ.png" alt=""></p>
<p>修改后为(主要修改了java和java.web的版本号)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">faceted-project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fixed</span> <span class="attr">facet</span>=<span class="string">"wst.jsdt.web"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"java"</span> <span class="attr">version</span>=<span class="string">"1.8"</span>/&gt;</span> <span class="comment">&lt;!--JDK版本为1.8--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"jst.web"</span> <span class="attr">version</span>=<span class="string">"4.0"</span>/&gt;</span>  <span class="comment">&lt;!--将2.3改为4.0，搭配Tomcat9--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"wst.jsdt.web"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">faceted-project</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将maven工程目录\src\main\webapp\WEB-INF中的web.xml文件修改为(将整个文件修改)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">"4.0"</span> <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>maven工程目录下的pom.xml文件中修改build节点，添加剂如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--添加--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在project节点下添加如下代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 另外一种激活方式 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>修改后，在项目上右键，点击Maven属性下的Update Project</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/04/25/J6njN4.png" alt=""></p>
<p>选择该项目进行更新，如果怕不能强制更新，可以勾选Force Update of Snapshots/Releases</p>
<p><img src="https://s1.ax1x.com/2020/04/26/J6us54.png" alt=""></p>
<p>右下角更新进度，大约几分钟左右</p>
<ol start="5">
<li><p>更新maven项目(右键-&gt;maven-&gt;updateproject)，再观察项目属性(项目右键-&gt;properties-&gt;project Facets)，Module已经变为4.0</p>
<p><img src="https://s1.ax1x.com/2020/04/26/J6Ms39.png" alt=""></p>
</li>
</ol>
<p>若更新maven项目后，报错建议先检查以上的几个步骤</p>
<ol start="6">
<li><p>下载ssm框架就所需的jar包</p>
<p>修改maven工程目录下的pom.xml文件：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.temptation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ssm Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Spring版本号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Spring相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- AOP相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- MyBatis相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- MySQL相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Spring集成MyBatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- JSP标准标签库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">&lt;!-- 日志相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--单元测试相关包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--添加--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 另外一种激活方式 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接复制上述内容至pom.xml文件，也可以根据需求添加一下jar，保存该文件后，右键点击项目后选中refresh，可以看到相关jar包被下载至本地仓库。</p>
<h3 id="6-7-完善项目结构"><a href="#6-7-完善项目结构" class="headerlink" title="6.7  完善项目结构"></a>6.7  完善项目结构</h3><p>由于服务端maven项目的标准结构有4个子包：src/main/java、src/main/resources、src/test/java、src/test/resources，这里缺少了src/test/resources,所以手动补上。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学证明有界无界</title>
    <url>/2020/04/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E6%9C%89%E7%95%8C%E6%97%A0%E7%95%8C/</url>
    <content><![CDATA[<p>高等数学证明有界无界</p>
<a id="more"></a>

<p>问题：证明函数f(x)= 1/x²在(0,1)上无界。</p>
<ol>
<li><p>“有界” 定义(注意有界与区间有关)</p>
<p>存在M&gt;0，使得对任意的x∈D，都有 |f(x)| ≤ M.</p>
</li>
<li><p>到“无界”定义，即否定“有界”</p>
<p>对任意M&gt;0(无论多大)，存在xm属于D，使得 |f(xm)| &gt; M</p>
</li>
<li><p>回到问题，梳理思路：</p>
<p>要证明f(x)在(0,1)上无界，按“无界” 定义</p>
<p>对任意M&gt;0，要找到一个满足的 |f(x)|&gt;M的x∈(0,1)</p>
<p>即找到一个满足1/x²&gt; M 的x∈(0,1)</p>
<p>即找到一个满足 <img src="https://s1.ax1x.com/2020/04/20/JQUab6.png" alt="img"> 的x∈(0,1)</p>
<p>取<img src="https://s1.ax1x.com/2020/04/20/JQNEOx.png" alt="img">)即可(不唯一)</p>
</li>
<li><p>解题过程：</p>
<p>对任意的M&gt;1/4 (无论多大)，都存在<img src="https://s1.ax1x.com/2020/04/20/JQUT2j.png" alt="img"></p>
<p>使得<img src="https://s1.ax1x.com/2020/04/20/JQULq0.png" alt="img"></p>
</li>
</ol>
<p>   故f(x)在(0,1)上无界。</p>
<p>   摘录<a href="https://zhuanlan.zhihu.com/p/29552253" target="_blank" rel="noopener">高数有界无界</a></p>
]]></content>
      <categories>
        <category>高数学习</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
</search>
