<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue学习</title>
    <url>/2020/04/03/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="今天你学Vue了吗-1"><a href="#今天你学Vue了吗-1" class="headerlink" title="今天你学Vue了吗?(1)"></a>今天你学Vue了吗?(1)</h1><a id="more"></a>

<p>  作为程序员中的小小白，对vue敬仰已久。这几天心血来潮，想学习一些基础的vue语法，请大佬们赐教。(vue是MVVM(model-view-viewmodel)模式)</p>
<h2 id="如何使用vue呢？"><a href="#如何使用vue呢？" class="headerlink" title="如何使用vue呢？"></a>如何使用vue呢？</h2><h3 id="1-可以直接在-html-文件中，引用一下代码使用Vue："><a href="#1-可以直接在-html-文件中，引用一下代码使用Vue：" class="headerlink" title="1. 可以直接在.html 文件中，引用一下代码使用Vue："></a>1. 可以直接在.html 文件中，引用一下代码使用Vue：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-还有更多安装Vue的方式。但不推荐新手直接使用-vue-cli，尤其不熟悉基于Node-js-的构建工具。"><a href="#2-还有更多安装Vue的方式。但不推荐新手直接使用-vue-cli，尤其不熟悉基于Node-js-的构建工具。" class="headerlink" title="2.还有更多安装Vue的方式。但不推荐新手直接使用 vue-cli，尤其不熟悉基于Node.js  的构建工具。"></a>2.还有更多安装Vue的方式。但不推荐新手直接使用 vue-cli，尤其不熟悉基于Node.js  的构建工具。</h3><h2 id="Coding-Show："><a href="#Coding-Show：" class="headerlink" title="Coding Show："></a>Coding Show：</h2><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM的系统：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">'#app'</span></span><br><span class="line">   data: &#123;</span><br><span class="line">     message: <span class="string">'Hello Vue!'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello Vue!</span><br></pre></td></tr></table></figure>

<p>vue的数据绑定。数据绑定是将数据和视图相关联，当数据发生变化时，可以自动更新视图。</p>
<p>以上代码便是数据绑定的例子。是文本插值，是最基本的方式，例子中的将会被相应的数据对象替换。当text的值变化时，文本的内容也会联动地发生变化。有时候只需要渲染一次数据，后续数据变化不再关心，可以通过“*”实现，代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span></span></span><br><span class="line"><span class="tag">   &#123;&#123;*<span class="attr">message</span>&#125;&#125;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>双大括号标签会把里面的值全部当作字符串来处理。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo错误解决</title>
    <url>/2020/04/04/hexo%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="今天遇到的hexo错误，记录下以免以后遇到忘记。"><a href="#今天遇到的hexo错误，记录下以免以后遇到忘记。" class="headerlink" title="今天遇到的hexo错误，记录下以免以后遇到忘记。"></a>今天遇到的hexo错误，记录下以免以后遇到忘记。</h1><a id="more"></a>

<h2 id="1-当执行新建文章命令时："><a href="#1-当执行新建文章命令时：" class="headerlink" title="1. 当执行新建文章命令时："></a>1. 当执行新建文章命令时：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"text"</span></span><br></pre></td></tr></table></figure>

<p>默认[layout]为post。布局.md文件都在scaffolds文件夹下，共有post、draft、page三种。</p>
<p>执行完命令报错：</p>
<table>
<thead>
<tr>
<th>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<p>该错误的原因：是文章或文章布局中的属性: 后面没有空格。当然要是一些配置文件：后面没有空格的话肯定也会报错误。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line">copyright: </span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>后面发现后加了空格，但是不小心又点击了哪里把格式给弄乱了，虽然：后面都有空格，但是用Typora工具查看是下面少了一行虚线，于是就报了如下错误：</p>
<table>
<thead>
<tr>
<th>Cannot read property ‘replace’ of undefined</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<p>看了很多帖子也没有太好的解决办法，于是我猜想就跟那一行虚线有关，其他layout文件用Typora工具打开后是有虚线的，于是我就复制了page.md, 更名为post.md。于是重新执行hexo new命令，结果就解决问题了</p>
<p>归根结底还是冒号(:)后面没有加空格的原因。希望以后多多注意！！！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin知识点记录</title>
    <url>/2020/04/04/kotlin%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>kotlin学习记录</p>
<a id="more"></a>

<p>kotlin和java的使用方法有所区别。Kotlin下载Android Studio后就可以使用。<a href="https://developer.android.com/kotlin/learn" target="_blank" rel="noopener">kotlin文档</a></p>
<p>kotlin使用两个不同的关键字（即val和var）来声明变量。</p>
<ol>
<li>val 用于值从不更改的变量。不能使用val声明的变量重新赋值。就相当于java中的final。</li>
<li>var 用于可以更改的变量。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp: <span class="built_in">Int</span>=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，count是一个Int类型的变量，为其赋予的初始值为10：</p>
<p>Kotlin出了Int类型的，还有Byte、Short、Long、Float和Double、String类型的变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name1: String =<span class="string">"kotlin"</span></span><br><span class="line">name1=<span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name2: String =<span class="string">"kotlin"</span></span><br><span class="line">name2=<span class="string">"helloworld"</span></span><br></pre></td></tr></table></figure>

<p>如上例，name1为val，因此name1被赋值后仍是”kotlin”。而name2是var，被赋值后可以改变，因此name2的值变更为”helloword”。</p>
<p>（注：kotlin编译器可根据所赋值的类型来推断类型，kotlin是一种静态类型的语言。String类型的变量也只能调用String类型的函数）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">num.inc()     <span class="comment">//num.inc()的结果为2，但是num的值并不会变，且num++这种方式kotlin不支持</span></span><br><span class="line">num+=<span class="number">1</span>    <span class="comment">//这种方式kotlin是支持的，执行完后，num=2</span></span><br></pre></td></tr></table></figure>

<h2 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h2><p>在某些语言中，可以声明引用类型变量而不明确提供初始值。在这些情况下，变量通常包含null值。默认情况下，Kotlin变量不能持有null。下段代码无效：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String =<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>要使变量持有null值，它必须是为null类型。可以在变量类型后面加上？后缀，可以将变量指定为null</p>
<p>如下所示:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String?=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>指定String?类型后，可以将name赋值为null或具体的字符串。</p>
<p>当变量被声明为可空类型后，并不能像非空变量那样被调用。可空类型String？只有使用安全调用符(?.)和非空断言调用符(?)才允许调用其方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String?=<span class="string">"abc"</span> <span class="comment">//声明一个可以为空的字符串变量name，且是var类型的变量，即后面可以更改其值。</span></span><br><span class="line">name.length    <span class="comment">//以这种形式调用声明的可空变量则是错误的，系统会提示报错</span></span><br><span class="line">name?.length  <span class="comment">//使用安全调用符</span></span><br><span class="line"></span><br><span class="line">name=<span class="literal">null</span>   <span class="comment">//将var可空String变量name赋值为null</span></span><br><span class="line">name?.length <span class="comment">//再次安全调用length方法时，结果将返回null</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在kotlin中，必须在声明对象时初始化对象的属性。这意味着，当获取类的实例时，立即引用它的任何可访问属性。当调用Fragment#onCreateView之前，Fragment中的View对象尚未准备好进行扩充，所以要推迟View的属性初始化。可以使用 lateinit 推迟属性初始化。使用lateinit时，应尽快初始化属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> usernameEditText: EditText</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> passwordEditText: EditText</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> loginButton: Button</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> statusTextView: TextView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">            usernameEditText = view.findViewById(R.id.username_edit_text)</span><br><span class="line">            passwordEditText = view.findViewById(R.id.password_edit_text)</span><br><span class="line">            loginButton = view.findViewById(R.id.login_button)</span><br><span class="line">            statusTextView = view.findViewById(R.id.status_text_view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> String accessId;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当变量带有@Nullable注解时，表示它可空，kotlin会将accessId视为String？</p>
<p>要指明变量绝不能为null，则使用@NonNull注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> String name;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果要修剪name以使其值不包含前导或尾随空格，则可以使用Kotlin的 trim函数。通过几种不同的方式安全地修剪String？。其中一种方式是使用非null断言预算符！！，如下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name!!.trim()</span><br></pre></td></tr></table></figure>

<p>！！运算符将其左侧的所有内容视为非null，一次，在本例中，将name视为非null String。 如果它左侧表达式的结果为null，则应用会抛出NullPointerException。</p>
<p>更安全的选择是使用安全调用运算符?.   ，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name?.trim()</span><br></pre></td></tr></table></figure>

<p>使用安全调用运算符时，如果 <code>name</code> 不为 null，则 <code>name?.trim()</code> 的结果是一个不带前导或尾随空格的名称值。如果 <code>name</code> 为 null，则 <code>name?.trim()</code> 的结果为 <code>null</code>。这意味着，在执行此语句时，您的应用永远不会抛出 <code>NullPointerException</code>。</p>
<p>虽然安全调用运算符可使您避免潜在的 <code>NullPointerException</code>，但它会将 null 值传递给下一个语句。您可以使用 Elvis 运算符 (<code>?:</code>) 来紧接着处理 null 值的情况，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name?.trim() ?: <span class="string">"Default name"</span></span><br></pre></td></tr></table></figure>

<p>如果 Elvis 运算符左侧表达式的结果为 null，则会将右侧的值赋予 <code>accountName</code>。此方法对于提供本来为 null 的默认值很有用。</p>
<p>您还可以使用 Elvis 运算符提前从函数返回结果，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validateAccount</span><span class="params">(account: <span class="type">Account</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> accountName = account?.name?.trim() ?: <span class="string">"Default name"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// account cannot be null beyond this point</span></span><br><span class="line">        account ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android-kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML元素--1</title>
    <url>/2020/04/06/HTML%E5%85%83%E7%B4%A01/</url>
    <content><![CDATA[<h1 id="HTML元素小记–ol-ul-dl-table"><a href="#HTML元素小记–ol-ul-dl-table" class="headerlink" title="HTML元素小记–ol-ul-dl-table"></a>HTML元素小记–ol-ul-dl-table</h1><a id="more"></a>

<p>可能这些东西对某些大佬老说已经非常熟悉了，但是作为小白的我，依旧需要记录一下，毕竟web前端不是经常用，而且写博客也是催促自己学习的一种方式，若某天大佬看了，请自动忽略本文。只供自己学习用，请勿嘲笑。</p>
<h2 id="1-无序列表标签–ul"><a href="#1-无序列表标签–ul" class="headerlink" title="1. 无序列表标签–ul"></a>1. 无序列表标签–ul</h2><ul>是无序的列表标签，无序嘛，就是列表中的内容是没有顺序的。无序列表中的每一项是<li>

<p>所有主流浏览器都支持ul标签。</p>
<p> 英文单词解释：</p>
<pre><code>*ul: unordered list, &quot;无序列表&quot;

*li: list item, &quot;列表项&quot;</code></pre><p>例如(示例使用了Vue框架，使用时请自行引入Vue框架文件)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ex1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"text in texts"</span>&gt;</span></span><br><span class="line">                &#123;&#123;text.node&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ex1=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#ex1'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            text:[</span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'苹果'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'梨'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'草莓'</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器效果如下：</p>
<ul>
<li>苹果</li>
<li>梨</li>
<li>草莓</li>
</ul>
<hr>
<p>属性：</p>
<ul>
<li>type=”属性值”。属性值可选: disc(实心原点，默认), square(实心方点)，circle(空心圆)</li>
</ul>
<hr>
<p>注意：</p>
<ul>
<li>注意li不能单独使用，且ul标签中的”儿子标签”只能是 li .</li>
<li>ul的作用：是增加无序列表的”语义”的。</li>
<li>li 是一个容器标签，可以放其他的标签元素，甚至是ul</li>
<li>这里就不比较HTML和XHTML之间的差异了，如果需要请自行到<a href="https://www.w3school.com.cn/tags/tag_ul.asp" target="_blank" rel="noopener">W3school</a>查看</li>
</ul>
<hr>
<p>ul 标签可以多层复杂嵌套：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>水果<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>鲜花<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>玫瑰花</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>红玫瑰<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>白玫瑰<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>康乃馨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>杜鹃花<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>丁香花<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>应用场景：</p>
<ul>
<li>导航栏</li>
<li>类似于购物清单列表</li>
</ul>
<hr>
<h2 id="2-有序列表-–ol-里面的每一项是–-li"><a href="#2-有序列表-–ol-里面的每一项是–-li" class="headerlink" title="2. 有序列表 –ol,  里面的每一项是– li"></a>2. 有序列表 –ol,  里面的每一项是– li</h2><p>所有主流浏览器都支持ol标签。</p>
<p>英文单词：</p>
<p>ol :  Ordered List.</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ex2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">                &#123;&#123;todo.text&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#ex2'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            todos:[</span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'苹果'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'梨'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'草莓'</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>演示效果如下：</p>
<ol start="50">
<li>苹果</li>
<li>梨</li>
<li>草莓</li>
</ol>
<hr>
<p>属性：</p>
<ul>
<li>reversed ：规定列表顺序为降序。(9,8,7…) 默认是顺序。</li>
<li>start ：规定有序列的起始值。</li>
<li>type ：规定在列表中使用的标记类型。如：(1, A ,a ,I ,i ).</li>
</ul>
<hr>
<p>ol也可以多层嵌套。</p>
<h2 id="3-定义列表-–dl"><a href="#3-定义列表-–dl" class="headerlink" title="3. 定义列表 –dl"></a>3. 定义列表 –dl</h2><p>dl英文单词：definition list，没有属性。dl的子元素只能是dt和dd。</p>
<p>dt : definition title列表的标题，这个标签是必须的。</p>
<p>dd ：definition description 列表的列表项，如果不需要它，可以不加。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第一天<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>跑步<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>写代码<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第二天<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>陪老婆<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>画画<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>做饭<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以这样使用dl</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>购物指南<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>购物流程<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>会员介绍<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>生活旅行/团购<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>常见问题<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>大家电<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>联系客服<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>配送方式<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>上门自提<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>211限时达<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>配送服务查询<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>配送费收取标准<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>海外配送<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-表格标签–table"><a href="#4-表格标签–table" class="headerlink" title="4. 表格标签–table"></a>4. 表格标签–table</h2><p>一个表格table是由每行tr组成的，每行是由td组成的。即一个表格是由行组成的，每行又是由列组成的。</p>
<p>例如，3行4列的单元格：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>生命壹号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>黄冈<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>许嵩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>29<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>邓紫棋<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>香港<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上图表格中是没有边框的。因此需要设置table的属性：</p>
<p>table的属性：</p>
<ul>
<li>border：边框。像素为单位。</li>
<li>style=“border-collapse:collapse；”      ：单元格的线和表格的边框合并</li>
<li>width：宽度。px为单位。</li>
<li>height：高度。px为单位。</li>
<li>bordercolor：表格的边框颜色。</li>
<li>align：表格的水平对齐方式。属性值可以填：left right cente。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签td进行设置)</li>
<li>cellpadding : 单元格内容到边的距离，像素为单位。默认情况下指最左侧那条边。如果设置属性 dir=”rtl”, 那就指的是内容到最右边那条线的距离。</li>
<li>cellspacing ：单元格和单元格之间的距离(外边距)，px为单位。默认情况下对的值为0.</li>
<li>bgcolor=”#99cc66”：表格的背景颜色。</li>
<li>background=”路径src/…”：背景图片。</li>
<li>bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色。</li>
<li>bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色。这两个属性的目的是为了设置3D的效果。</li>
<li>dir：公有属性，单元格内容的排列方式。可以取值：ltr：从左到右(默认)，rtl：从右到左。既然说dir是公有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。</li>
</ul>
<hr>
<p>对于<tr>：行</p>
<p>属性：</p>
<ul>
<li><p>dir：公有属性，设置一行单元格内容的排列方式。具体上面讲过。</p>
</li>
<li><p>bgcolor：设置一行单元格的背景颜色。</p>
</li>
<li><p>height：一行单元格的高度。</p>
</li>
<li><p>align=”center”：一行的内容水平居中显示，取值：left、center、right。</p>
</li>
<li><p>valign=”center”：一行内容垂直居中，取值：top、middler、bottom。</p>
<p>注：th：加粗的单元格。相当于td+b 属性同td标签一样。使用时和tr标签并列。</p>
<hr>
<p>表格的thead标签、tbody标签、tfoot标签</p>
<p>当浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候从按照代码的从上到下的顺序来显示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML小记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Android错误</title>
    <url>/2020/04/12/Android%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>Android Studio报错：Caused by: org.gradle.api.resources.ResourceException: Could not get resource </p>
<a id="more"></a>

<p>Android Studio版本号：3.6</p>
<p>解决办法：把原有build配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">   repositories&#123;</span><br><span class="line">      jcenter()</span><br><span class="line">      google()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">allprojects</span>&#123;</span><br><span class="line">   <span class="variable">repositories</span>&#123;</span><br><span class="line">      <span class="comment">//新加</span></span><br><span class="line">      <span class="function"><span class="title">mavenCentral</span>()</span></span><br><span class="line">      <span class="function"><span class="title">mavenLocal</span>()</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="title">jcenter</span>()</span></span><br><span class="line">      <span class="function"><span class="title">google</span>()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后更新build文件，rebuild后，该错误消失。</p>
<p>据了解jcenter()和mavenCentral()是Android Studio中Gradle插件使用的仓库。Android Studio早期版本使用的是MavenCentral，从某个时候开始切换到jcenter了，也就是说，项目之所以报错，是因为该项目的Android Studio是早期的版本。之所以使用jcenter在性能和占存储大小方面比mavenCentral更优：</p>
<ol>
<li>jcenter 是世界上最大的java仓库</li>
<li>jcenter通过CDN服务，使用的是https协议，安全性更高，而Android Studio 0.8版本mavenCentral使用的是http协议</li>
<li>jcenter是mavenCentral的超集，包括许多额外的仓库</li>
<li>jcenter性能方面比mavenCentral更优</li>
<li>mavenCentral会自动下载很多与IDE相关的index，而这些用到的少，且不是必需</li>
</ol>
<p>而mavenLocal则是用来指定本地仓库路径的，使用mavenLocal就是默认本地路径。若是自定义本地路径，则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">   maven&#123;url <span class="string">'D://Users/user2/.m2/repository'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin扩展函数与扩展属性</title>
    <url>/2020/04/15/kotlin%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E4%B8%8E%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="kotlin扩展函数与扩展属性"><a href="#kotlin扩展函数与扩展属性" class="headerlink" title="kotlin扩展函数与扩展属性"></a>kotlin扩展函数与扩展属性</h1><a id="more"></a>

<p>(近期在学kotlin和vue希望可以慢慢掌握吧—小小白)</p>
<p>扩展函数与扩展属性可以在不修改原来类的条件下自定义函数和属性，使它们表现得就像是属于这条个类一样。例如，我们给String类型扩展一个返回字符串最后一个字符的firstChar()函数，然后在main函数中调用。代码十分简洁。(kotlin中使用fun来声明函数)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">     &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.length-<span class="number">1</span>].toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">ArrayList</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=<span class="string">"abc"</span></span><br><span class="line">    println(<span class="string">"lastChar: "</span>+str.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果非常明显，会打印出 (上例中的this值得就是调用lastChar函数的对象实例):</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lastChar: c</span><br></pre></td></tr></table></figure>

<p>注：kotlin中println函数是封装了java中的System.out.println()函数。</p>
]]></content>
      <categories>
        <category>kotlin学习</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery-find函数</title>
    <url>/2020/04/15/jQuery-find%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>jQuery.find()函数</p>
<a id="more"></a>

<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>find()函数用于选取每个匹配元素的符合指定表达式的后代元素，并以JQuery对象的方式返回。这里的表达式包括：选择器(字符串)、DOM元素(Element)、jQuery对象。该函数属于JQuery对象(实例)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQueryObject.find(expr)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>expr</td>
<td>String/Element/jQuery类型指定的表达式</td>
</tr>
</tbody></table>
<p>find()函数将在当前JQuery对象每个匹配元素的所有后代元素中筛选符合指定表达式的元素。如果expr参数为字符串，则将其视作jQuery选择器，用以表示该选择器所匹配的元素。jQuery1.6新增支持：参数expr可以为DOM元素(Element)或jQuery对象。</p>
<h2 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h2><p>find()函数的返回值为jQuery类型，返回一个新的jQuery对象，该对象封装了当前jQuery对象匹配元素的所有符合指定选择器的后代元素。</p>
<p>如果没有匹配的元素，则返回空 的jQuery对象。</p>
<h2 id="示例-amp-说明："><a href="#示例-amp-说明：" class="headerlink" title="示例&amp;说明："></a>示例&amp;说明：</h2>]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中关键字与修饰符</title>
    <url>/2020/04/16/kotlin%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>kotlin中的修饰符关键字主要分为</p>
<a id="more"></a>

<ul>
<li>类修饰符</li>
<li>成员修饰符</li>
<li>访问权限修饰符</li>
<li>协变逆变修饰符</li>
<li>函数修饰符</li>
<li>属性修饰符</li>
<li>参数修饰符</li>
<li>具体化类型修饰符</li>
</ul>
<p>​                                 表2-1 kotlin中的类修饰符</p>
<table>
<thead>
<tr>
<th align="center">类修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abstract</td>
<td align="center">抽象类</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">不可被继承final类</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">枚举类</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">可继承open类</td>
</tr>
<tr>
<td align="center">annotation</td>
<td align="center">注解类</td>
</tr>
<tr>
<td align="center">scaled</td>
<td align="center">密封类</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">数据类</td>
</tr>
</tbody></table>
<p>​                               表2-2  kotlin中的成员修饰符</p>
<table>
<thead>
<tr>
<th align="center">成员修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">override</td>
<td align="center">重写函数(方法)</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">声明函数可被重写</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">声明函数不可被重写</td>
</tr>
<tr>
<td align="center">abstract</td>
<td align="center">声明函数为抽象函数</td>
</tr>
<tr>
<td align="center">lateinit</td>
<td align="center">延迟初始化</td>
</tr>
</tbody></table>
<p>​                             表2-3 kotlin中的访问权限修饰符</p>
<table>
<thead>
<tr>
<th align="center">访问权限修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">私有，仅当前类可访问</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">当前类以及继承该类的可访问</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">默认值，对外可访问</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="center">整个模块内可访问(模块是指一起编译的一组kotlin源代码文件。例如，一个Maven工程，或Gradle工程，通过Ant任务的一次调用编译的一组文件等)</td>
</tr>
</tbody></table>
<p>​                         表2-4  空调连载中的协变逆变修饰符</p>
<table>
<thead>
<tr>
<th>协变逆变修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>生产者类型修饰符，in T 等价于 ?super T</td>
</tr>
<tr>
<td>out</td>
<td>消费者类型修饰符，out T 等价于 ?extends T</td>
</tr>
</tbody></table>
<p>​                                       表2-5  kotlin中的函数修饰符</p>
<table>
<thead>
<tr>
<th align="center">函数修饰符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tailrec</td>
<td align="left">尾递归</td>
</tr>
<tr>
<td align="center">operator</td>
<td align="left">运算符重载函数</td>
</tr>
<tr>
<td align="center">infix</td>
<td align="left">中缀函数。例如，给Int定义扩展中缀函数 infix fun Int.shl(x:Int): Int</td>
</tr>
<tr>
<td align="center">inline</td>
<td align="left">内联函数</td>
</tr>
<tr>
<td align="center">external</td>
<td align="left">外部函数</td>
</tr>
<tr>
<td align="center">suspend</td>
<td align="left">挂起协程函数</td>
</tr>
</tbody></table>
<p>​                                              表2-6 kotlin中的属性修饰符</p>
<table>
<thead>
<tr>
<th align="center">属性修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const</td>
<td>常量修饰符</td>
</tr>
</tbody></table>
<p>​                                            表2-7  kotlin中的参数修饰符</p>
<table>
<thead>
<tr>
<th>参数修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vararg</td>
<td>变长参数修饰符</td>
</tr>
<tr>
<td>noinline</td>
<td>不内联参数修饰符，有时，只需要将内联函数的部分参数使用内联Lambda，其他的参数不需要内联，可以使用noinline关键字修饰。例如：inline fun foo(inlined:()-&gt;Unit, noinline notInlined:()-&gt;Unit)</td>
</tr>
<tr>
<td>crossinline</td>
<td>首先，默认内联函数的Lambda表达式参数是允许非局部返回的，即：     fun outterFun(){                                                                                                                                                        innerFun{                                                                                                                                        retuurn   //支持直接返回outterFun                                                             }}                                                                                                               而使用crossinline限制Lambda表达式直接非局部return返回。                    这样做的原因是：                                                                                          一些内联函数可能通用传给它们的不是直接来自函数体，而是来自另一个执行上下文 的Lambda表达式参数，如来自局部对象或嵌套函数。在这种情况下，该Lambda表达式中也是禁止直播return的。为了标识这种情况，该Lambda表达式参数需要用crossinline修饰符标记。</td>
</tr>
</tbody></table>
<p>​                                               表2-8  kotlin中的具体化类型修饰符</p>
<table>
<thead>
<tr>
<th align="center">具体化类型修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reified</td>
<td align="center">具体化类型参数</td>
</tr>
</tbody></table>
<p>一个crossinline代码实例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(<span class="keyword">crossinline</span> body: ()-&gt;<span class="type">Unit</span>)</span></span>&#123;<span class="comment">//内联函数f的body参数是一个Lambda</span></span><br><span class="line">   <span class="keyword">val</span> f=<span class="keyword">object</span>: Runnable&#123;   <span class="comment">//在对象表达式中使用body参数</span></span><br><span class="line">         <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>=body() <span class="comment">//参数标记为crossinline后,return操作将不被允许</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的修饰符关键字之外，还有一些特殊语义的关键字如表2-9所示。</p>
<p>​                                              表2-9  kotlin中的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>package</td>
<td>包声明</td>
</tr>
<tr>
<td>as</td>
<td>类型转换</td>
</tr>
<tr>
<td>typealias</td>
<td>类型别名</td>
</tr>
<tr>
<td>class</td>
<td>声明类</td>
</tr>
<tr>
<td>this</td>
<td>当前对象引用</td>
</tr>
<tr>
<td>super</td>
<td>父亲对象引用</td>
</tr>
<tr>
<td>val</td>
<td>声明不可变变量</td>
</tr>
<tr>
<td>var</td>
<td>声明可变变量</td>
</tr>
<tr>
<td>fun</td>
<td>声明函数</td>
</tr>
<tr>
<td>for</td>
<td>for循环</td>
</tr>
<tr>
<td>null</td>
<td>特殊值null</td>
</tr>
<tr>
<td>true</td>
<td>真值</td>
</tr>
<tr>
<td>false</td>
<td>假值</td>
</tr>
<tr>
<td>is</td>
<td>类型判断</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常</td>
</tr>
<tr>
<td>return</td>
<td>返回值</td>
</tr>
<tr>
<td>break</td>
<td>跳出循环体</td>
</tr>
<tr>
<td>continue</td>
<td>继续下一次循环</td>
</tr>
<tr>
<td>object</td>
<td>单例类声明</td>
</tr>
<tr>
<td>if</td>
<td>逻辑判断if</td>
</tr>
<tr>
<td>else</td>
<td>逻辑判断，结合if使用</td>
</tr>
<tr>
<td>while</td>
<td>while循环</td>
</tr>
<tr>
<td>do</td>
<td>do循环</td>
</tr>
<tr>
<td>when</td>
<td>条件判断</td>
</tr>
<tr>
<td>interface</td>
<td>接口声明</td>
</tr>
<tr>
<td>file</td>
<td>文件</td>
</tr>
<tr>
<td>field</td>
<td>成员</td>
</tr>
<tr>
<td>property</td>
<td>属性</td>
</tr>
<tr>
<td>receiver</td>
<td>接收者</td>
</tr>
<tr>
<td>param</td>
<td>参数</td>
</tr>
<tr>
<td>setparam</td>
<td>设置参数</td>
</tr>
<tr>
<td>delegate</td>
<td>委托</td>
</tr>
<tr>
<td>import</td>
<td>导入包</td>
</tr>
<tr>
<td>where</td>
<td>where条件</td>
</tr>
<tr>
<td>by</td>
<td>委托类或属性</td>
</tr>
<tr>
<td>get</td>
<td>get函数</td>
</tr>
<tr>
<td>set</td>
<td>set函数</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数</td>
</tr>
<tr>
<td>init</td>
<td>初始化代码块</td>
</tr>
<tr>
<td>try</td>
<td>异常捕获</td>
</tr>
<tr>
<td>catch</td>
<td>异常捕获，结合try使用</td>
</tr>
<tr>
<td>finally</td>
<td>异常最终执行代码块</td>
</tr>
<tr>
<td>dynamic</td>
<td>动态的</td>
</tr>
<tr>
<td>typeof</td>
<td>类型定义，预留用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin流程控制语句</title>
    <url>/2020/04/16/kotlin%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="Kotlin流程控制语句"><a href="#Kotlin流程控制语句" class="headerlink" title="Kotlin流程控制语句"></a>Kotlin流程控制语句</h1><a id="more"></a>

<h2 id="1-if表达式"><a href="#1-if表达式" class="headerlink" title="1. if表达式"></a>1. if表达式</h2><p>if是一个表达式，即它会返回一个值(跟scala一样)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> max=<span class="keyword">if</span>(a&gt;b) a <span class="keyword">else</span> b  <span class="comment">//max定义为val类型，因为max后面不会被改变当a&gt;b时，max=a</span></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     println(<span class="string">"max="</span>+max(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if的分支可以是代码块，最后一行的表达式作为该块的值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">   <span class="keyword">val</span> max=<span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">     println(<span class="string">"Max is a"</span>)</span><br><span class="line">     a</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">"Max is b"</span>)</span><br><span class="line">      b</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin没有类似true?1:0这样的三元表达式。对应的写法是使用if…else语句。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLeapYear</span><span class="params">(year:<span class="type">Int</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLeapYear:<span class="built_in">Boolean</span></span><br><span class="line">  <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))&#123;</span><br><span class="line">    isLeapYear=<span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     isLeapYear=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isLeapYear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  println(isLeapYear(<span class="number">2017</span>))</span><br><span class="line">  println(isLeapYear(<span class="number">2020</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-when表达式"><a href="#2-when表达式" class="headerlink" title="2. when表达式"></a>2. when表达式</h2><p>when 表达式类似于switch…case表达式。when会对所有的分支进行检查直到有一个条件被满足。但相比switch而言，when语句的功能要更加强大、灵活。when语句的每一个分支也可以是一个代码块，它的值是块中最后的表达式的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">casesWhen</span><span class="params">(obj:<span class="type">Any</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">when</span>(obj)&#123;</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> -&gt;println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这是0-9之间的数字"</span>)<span class="comment">//若有多个分支条件放在一起，用逗号隔开</span></span><br><span class="line">        <span class="string">"hello"</span>-&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这个是字符串hello"</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Char</span> -&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这个是Char类型数据"</span>)<span class="comment">//is是类型判断</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;else类似于java中的case-swich中的default"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    casesWhen(<span class="number">6</span>)</span><br><span class="line">    casesWhen(<span class="string">"hello"</span>)</span><br><span class="line">    casesWhen(<span class="string">'X'</span>)</span><br><span class="line">    casesWhen(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以检测一个值在in或不在!in一个区间或者集合中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">casewhen</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> x=<span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> validNumbers = arrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">when</span>(x)&#123;</span><br><span class="line">     <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt;print(<span class="string">"x is in the range"</span>)  <span class="comment">//是否在范围1..10</span></span><br><span class="line">     <span class="keyword">in</span> validNumbers -&gt;print(<span class="string">"x is valid"</span>)   <span class="comment">//是否在数据arrayof(1,2,3)中</span></span><br><span class="line">     !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>) <span class="comment">//不在范围10..20中</span></span><br><span class="line">     <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)  <span class="comment">//默认路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h2><p>如果想要通过索引遍历一个数组或者一个list，可以这么做：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)&#123;</span><br><span class="line"><span class="comment">//array.indices存储了数组array的下标序列</span></span><br><span class="line">  print(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，array.indices持有数组的下标列表。我们也可以使用函数withIndex()来遍历下标与对应的因素：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((index,value) <span class="keyword">in</span> array.withIndex())&#123;   <span class="comment">//带下标index来访问数据</span></span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另外，范围(Ranges)表达式也可用于循环中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>)&#123;  <span class="comment">//等同于1&lt;=i&amp;&amp;i&lt;=10</span></span><br><span class="line">  println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).forEach&#123;print(it)&#125;    <span class="comment">//上面代码简写</span></span><br></pre></td></tr></table></figure>

<h2 id="4-while循环"><a href="#4-while循环" class="headerlink" title="4. while循环"></a>4. while循环</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="number">10</span></span><br><span class="line">  <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    x-</span><br><span class="line">    println(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="number">10</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">     y=y+<span class="number">1</span></span><br><span class="line">     println(y)</span><br><span class="line">  &#125;<span class="keyword">while</span>(y&lt;<span class="number">20</span>)  <span class="comment">//while判断条件，y的作用域包含此处。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-return返回"><a href="#5-return返回" class="headerlink" title="5. return返回"></a>5. return返回</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=&#123;a+b&#125; <span class="comment">//直接使用表达式声明函数，注意到这里的&#123;&#125;表示</span></span><br><span class="line"><span class="comment">//当调用sumf(1,1)时，返回类型是一个函数()-&gt;kotlin.Int</span></span><br><span class="line"><span class="comment">//调用sumf(1,1).invoke()  返回的结果是2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=&#123;<span class="keyword">if</span>(a&gt;b)a <span class="keyword">else</span> b&#125;</span><br><span class="line"><span class="comment">//maxf(2,6) 的返回类型也是一个函数</span></span><br><span class="line"><span class="comment">//使用invoke()函数调用maxf(2,6)函数，返回值为6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sumf(1,1).invoke()和sumf(1,1)()的调用方式是等价的</span></span><br><span class="line"><span class="comment">/*在Kotlin中，()操作符对应的是类的重载函数，如invoke()我们使用()运算符来调用函数*/</span></span><br></pre></td></tr></table></figure>



<p>kotlin中return语句会从最近的函数或匿名函数中返回，但是在Lambda表达式中遇到return语句时，则直接返回最近的外层函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = intArrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//声明一个Int数值</span></span><br><span class="line">intArray.forEach&#123;</span><br><span class="line">  <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span> <span class="comment">//在Lambda表达式中的return直接返回最近的外层函数</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因此，结果为：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">当it为3时就会return，类似于break的作用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> 当给forEach传入一个匿名函数fun(a:Int)，这个匿名函数里的return的语句不会跳出forEach循环，类似于continue语句的效果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = intArrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//声明一个Int数值</span></span><br><span class="line">intArray.forEach&#123; <span class="function"><span class="title">fun</span><span class="params">(a:<span class="type">Int</span>)</span></span>&#123;  <span class="comment">//这是一个匿名函数</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">3</span>) <span class="keyword">return</span>   <span class="comment">//从最近的函数中返回，也就是上面的匿名函数fun(a:Int)，但是循环会继续，类似于continue语句。</span></span><br><span class="line">    println(a)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因此，结果为：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">当a为3时，从匿名函数中返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-1-标签-label"><a href="#5-1-标签-label" class="headerlink" title="5.1  标签(label)"></a>5.1  标签(label)</h2><p>在Kotlin中任何表达式都可以用标签(label)来标记。标签的格式为标识符后跟@符号，如abc@、——isOK@都是有效的标签。我们可以使用Label标签来控制return、break或continue语句的跳转(jump)行为。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array= intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    array.forEach <span class="symbol">here@</span>&#123; <span class="comment">//定义here@标签</span></span><br><span class="line">        <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@here</span> <span class="comment">//执行指令跳转到Lambda表达式标签here@处当it=3时，则会跳转下一个it=4的遍历循环。</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果则是输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>另外可以使用隐式标签、更加方便。该标签与接收该Lambda的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array= intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    array.forEach&#123; </span><br><span class="line">        <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//返回@forEach处继续下一个循环</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果则是输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>throw表达式</p>
<p>在kotlin中throw是表达式，它的类型是特殊类型Nothing。该类型没有值，与java中的void意思一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(msg:<span class="type">String</span>)</span></span>:<span class="built_in">Nothing</span>&#123;<span class="keyword">throw</span> IllegalArgumentException(msg)&#125;</span><br><span class="line"><span class="comment">//返回值为Nothing表示该函数永远不会返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   fail(<span class="string">"nihao"</span>)  <span class="comment">//调用fail函数，将会直接抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.IllegalArgumentException: nihao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果把一个throw表达式的值赋给一个变量，需要显示声明类型为Nothing，代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ex=<span class="keyword">throw</span> Exception(<span class="string">"nihao"</span>) <span class="comment">//ex需要显示声明类型为Nothing，否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ex:<span class="built_in">Nothing</span>=<span class="keyword">throw</span> Exception(<span class="string">"nihao"</span>)</span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.Exception: nihao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学证明有界无界</title>
    <url>/2020/04/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E6%9C%89%E7%95%8C%E6%97%A0%E7%95%8C/</url>
    <content><![CDATA[<p>高等数学证明有界无界</p>
<a id="more"></a>

<p>问题：证明函数f(x)= 1/x²在(0,1)上无界。</p>
<ol>
<li><p>“有界” 定义(注意有界与区间有关)</p>
<p>存在M&gt;0，使得对任意的x∈D，都有 |f(x)| ≤ M.</p>
</li>
<li><p>到“无界”定义，即否定“有界”</p>
<p>对任意M&gt;0(无论多大)，存在xm属于D，使得 |f(xm)| &gt; M</p>
</li>
<li><p>回到问题，梳理思路：</p>
<p>要证明f(x)在(0,1)上无界，按“无界” 定义</p>
<p>对任意M&gt;0，要找到一个满足的 |f(x)|&gt;M的x∈(0,1)</p>
<p>即找到一个满足1/x²&gt; M 的x∈(0,1)</p>
<p>即找到一个满足 <img src="https://s1.ax1x.com/2020/04/20/JQUab6.png" alt="img"> 的x∈(0,1)</p>
<p>取<img src="https://s1.ax1x.com/2020/04/20/JQNEOx.png" alt="img">)即可(不唯一)</p>
</li>
<li><p>解题过程：</p>
<p>对任意的M&gt;1/4 (无论多大)，都存在<img src="https://s1.ax1x.com/2020/04/20/JQUT2j.png" alt="img"></p>
<p>使得<img src="https://s1.ax1x.com/2020/04/20/JQULq0.png" alt="img"></p>
</li>
</ol>
<p>   故f(x)在(0,1)上无界。</p>
<p>   摘录<a href="https://zhuanlan.zhihu.com/p/29552253" target="_blank" rel="noopener">高数有界无界</a></p>
]]></content>
      <categories>
        <category>高数学习</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin操作符与重载</title>
    <url>/2020/04/18/kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="Kotlin操作与重载"><a href="#Kotlin操作与重载" class="headerlink" title="Kotlin操作与重载"></a>Kotlin操作与重载</h1><a id="more"></a>

<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="left">标题</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最高级</td>
<td align="left">后缀(Postfix)</td>
<td>++，–，.，?.，？</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">前缀(Prefix)</td>
<td>-，+，++，–，！，labelDefinition@</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">右手类型运算(Type RHS，right-hand side class type (RHS))</td>
<td>:，as，as?</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">乘除取余(Multiplicative)</td>
<td>*，/，%</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">加减(Additive)</td>
<td>+，-</td>
</tr>
<tr>
<td align="center">(优先级往下依次递减)</td>
<td align="left">区间范围(Range)</td>
<td>..</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">Infix 函数</td>
<td>例如，给Int定义扩展 infix fun Int.shl(x:Int):Int{…}，这样调用      1 shl 2，等同于1.shl(2)</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">Elvis操作符</td>
<td>?:</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">命名检查符(Named checks)</td>
<td>in，!in，is，!is</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">比较大小(Comparison)</td>
<td>&lt;，&gt;，&lt;=，&gt;=</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">相等性判断(Equality)</td>
<td>==，!=，===，!==</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">与(Conjunction)</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">或(Disjunction)</td>
<td>||</td>
</tr>
<tr>
<td align="center">最低</td>
<td align="left">赋值(Assignment)</td>
<td>=，+=，-=，*=，/=，%=</td>
</tr>
</tbody></table>
<p>kotlin重载操作符的函数需要使用operator修饰符标记，中缀操作符函数使用infix修饰符标记。</p>
<h2 id="1-1-一元操作符"><a href="#1-1-一元操作符" class="headerlink" title="1.1 一元操作符"></a>1.1 一元操作符</h2><p>一元操作符有前缀操作符、递增和递减操作符等。</p>
<h3 id="1-1-1-前缀操作符"><a href="#1-1-1-前缀操作符" class="headerlink" title="1.1.1 前缀操作符"></a>1.1.1 前缀操作符</h3><p>前缀操作符放在操作数的前面，分别如表所示。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
</tbody></table>
<p>一下是重载一元减运算符的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x:<span class="built_in">Int</span>,<span class="keyword">val</span> y:<span class="built_in">Int</span>)          <span class="comment">//声明数据类Point</span></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span>=Point(-x,-y)  <span class="comment">//operator修饰符修饰一个重载操作符函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPointUnaryMinus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p=Point(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> np=-p                <span class="comment">//直接使用unaryMinus()重载函数操作符"-"</span></span><br><span class="line">    println(np)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testPointUnaryMinus()   <span class="comment">//调用函数</span></span><br><span class="line">    <span class="comment">/*输出 Point(x=-1,y=-1)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-递增和递减操作符"><a href="#1-1-2-递增和递减操作符" class="headerlink" title="1.1.2 递增和递减操作符"></a>1.1.2 递增和递减操作符</h3><p>inc()和dec()函数必须返回一个值，它用于赋值给使用++或–操作的变量。前缀和后缀的表达式的返回值是不同的。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a++</td>
<td align="center">a.inc()返回值是a</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()返回值是a</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">a.inc()返回值是a+1</td>
</tr>
<tr>
<td align="center">–a</td>
<td align="center">a.dec()返回值是a-1</td>
</tr>
</tbody></table>
<h2 id="2-二元操作符"><a href="#2-二元操作符" class="headerlink" title="2. 二元操作符"></a>2. 二元操作符</h2><p>Kotlin中的二元操作符有算术运算符、索引访问操作符、调用操作符、计算并赋值操作符、相等与不相等操作符、Elvis操作符、比较操作符、中缀操作符等。</p>
<h3 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h3><p>Kotlin算数运算符有加、减、乘、除、取余、范围操作符等。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a+b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a-b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a*b</td>
<td align="center">a.temes(b)</td>
</tr>
<tr>
<td align="center">a/b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a%b</td>
<td align="center">a.rem(b)、a.mod(b)</td>
</tr>
<tr>
<td align="center">a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
</tbody></table>
<h3 id="2-2-字符串的”-”运算符重载"><a href="#2-2-字符串的”-”运算符重载" class="headerlink" title="2.2 字符串的”+”运算符重载"></a>2.2 字符串的”+”运算符重载</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>+<span class="number">1</span>    <span class="comment">//String 类型重载了加法操作符</span></span><br><span class="line"><span class="number">1</span>+<span class="string">""</span>   <span class="comment">//Int类型没有重载操作符 plus(other:String) 这种形式会报错</span></span><br><span class="line"><span class="number">1</span>.toString()+<span class="string">""</span>  <span class="comment">//先把Int类型的1转换成String再相加1，显示调用toString()函数</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-自定义重载的”-”运算符"><a href="#2-3-自定义重载的”-”运算符" class="headerlink" title="2.3 自定义重载的”+”运算符"></a>2.3 自定义重载的”+”运算符</h3><p>下面使用一个计数类Counter重载的”+”运算符来增加index的计数值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>(<span class="keyword">var</span> index:<span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Counter.<span class="title">plus</span><span class="params">(increment:<span class="type">Int</span>)</span></span>:Counter&#123;</span><br><span class="line">         <span class="keyword">return</span> Counter(index+increment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCounterIndexPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> a=Counter(<span class="number">1</span>)  <span class="comment">//声明一个Counter对象，初始化为1</span></span><br><span class="line">  <span class="keyword">val</span> ap=a+<span class="number">12</span>       <span class="comment">//调用自定义重载"+"运算符</span></span><br><span class="line">  println(ap)       <span class="comment">//打印变量ap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testCounterIndexPlus()   <span class="comment">//调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：Counter(13)*/</span></span><br></pre></td></tr></table></figure>



<h3 id="2-4-in操作符"><a href="#2-4-in操作符" class="headerlink" title="2.4 in操作符"></a>2.4 in操作符</h3><p>in操作符等价于contains()函数</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a in b</td>
<td align="center">b.contains(a)</td>
</tr>
<tr>
<td align="center">a !in b</td>
<td align="center">!b.contains(a)</td>
</tr>
</tbody></table>
<h3 id="2-5-索引访问操作符"><a href="#2-5-索引访问操作符" class="headerlink" title="2.5  索引访问操作符"></a>2.5  索引访问操作符</h3><p>索引访问操作符方括号[]转换为调用带有适当数量参数的get和set</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a[i]</td>
<td align="center">a.get(i)</td>
</tr>
<tr>
<td align="center">a[i]=b</td>
<td align="center">a.set(i,b)</td>
</tr>
</tbody></table>
<h3 id="2-6-调用操作符"><a href="#2-6-调用操作符" class="headerlink" title="2.6 调用操作符"></a>2.6 调用操作符</h3><p>小括号调用符()转换为调用invoke()，同样带参数调用也会转换为invoke()函数中的参数。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a()</td>
<td align="center">a.invoke()</td>
</tr>
<tr>
<td align="center">a(i)</td>
<td align="center">a.invoke(i)</td>
</tr>
</tbody></table>
<h3 id="2-7-计算并赋值操作符"><a href="#2-7-计算并赋值操作符" class="headerlink" title="2.7 计算并赋值操作符"></a>2.7 计算并赋值操作符</h3><p>对于赋值操作，例如a+=b，编译器会试着生成a=a+b的代码(这里包含类型检查：a+b的类型必须是a的子类型)。计算并赋值操作符对应的重载函数</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a+=b</td>
<td align="center">a.plusAssign(b)</td>
</tr>
<tr>
<td align="center">a-=b</td>
<td align="center">a.minusAssign(b)</td>
</tr>
<tr>
<td align="center">a*=b</td>
<td align="center">a.timesAssign(b)</td>
</tr>
<tr>
<td align="center">a/=b</td>
<td align="center">a.divAssign(b)</td>
</tr>
<tr>
<td align="center">a%=b</td>
<td align="center">a.modAssign(b)</td>
</tr>
</tbody></table>
<h3 id="2-8-相等与不相等操作符"><a href="#2-8-相等与不相等操作符" class="headerlink" title="2.8 相等与不相等操作符"></a>2.8 相等与不相等操作符</h3><p>Kotlin中 有两种类型的相等性：</p>
<ul>
<li><p>引用相等===！==(两个引用指向同一对象)；</p>
</li>
<li><p>结构相等==!=(使用equals()判断)</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a==b</td>
<td>a?.equals(b)?:(b=null)</td>
</tr>
<tr>
<td>a!=b</td>
<td>!(a?.equals(b)?:(b==null))</td>
</tr>
</tbody></table>
<p>“==” 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选null值。意思是：如果a不是null则调用equals(Any?)函数并返回其值；否则(即a===null)就计算b===null的值并返回。</p>
<p>注意：===和 !==不可重载</p>
</li>
</ul>
<h3 id="2-9-Elvis-操作符？"><a href="#2-9-Elvis-操作符？" class="headerlink" title="2.9 Elvis 操作符？"></a>2.9 Elvis 操作符？</h3><p>在kotlin中，Elvis操作符特定是跟null进行比较。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">y=x?:<span class="number">0</span>    <span class="comment">//使用Elvis操作符?:</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">val</span> y=<span class="keyword">if</span>(x!==<span class="literal">null</span>)x <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>主要用来作null安全性检查。</p>
<p>Kotlin中没有这样的三元符号true?1:0取而代之的是if(true)1 else 0. 而Elvis操作符算是精简版的三元运算符。</p>
<p>在java中使用的三元运算符的语法通常要重复变量两次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">"Elvis Presley"</span>;</span><br><span class="line">String displayName=(name!=<span class="keyword">null</span>)name:<span class="string">"Unknown"</span> <span class="comment">//java中的三元操作符</span></span><br></pre></td></tr></table></figure>

<p>可以使用Elvis操作符取而代之：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"Elvis Presley"</span></span><br><span class="line"><span class="keyword">val</span> displayName=name?:<span class="string">"Unknown"</span> <span class="comment">//使用Elvis操作符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> y=x?:<span class="number">0</span>    <span class="comment">//使用Elvis操作符</span></span><br><span class="line">println(y)    <span class="comment">//等价逻辑：if(x!==null) x else 0，此处x===null, 所以选择else分支，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x=<span class="literal">false</span></span><br><span class="line"><span class="keyword">val</span> y=x?:<span class="number">0</span></span><br><span class="line">println(y) <span class="comment">//x!==null,所以y的值为x，即为false</span></span><br></pre></td></tr></table></figure>



<h3 id="2-10-比较操作符"><a href="#2-10-比较操作符" class="headerlink" title="2.10 比较操作符"></a>2.10 比较操作符</h3><p>Kotlin中所有的比较表达式都转换为对compareTo()函数的调用，这个函数需要返回Int值。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a&gt;b</td>
<td>a.compareTo(b)&gt;0</td>
</tr>
<tr>
<td>a&lt;b</td>
<td>a.compareTo(b)&lt;0</td>
</tr>
<tr>
<td>a&gt;=b</td>
<td>a.compareTo(b)&gt;=0</td>
</tr>
<tr>
<td>a&lt;=b</td>
<td>a.compareTo(b)&lt;=0</td>
</tr>
</tbody></table>
<h3 id="2-11-用infix函数自定义中缀操作符"><a href="#2-11-用infix函数自定义中缀操作符" class="headerlink" title="2.11 用infix函数自定义中缀操作符"></a>2.11 用infix函数自定义中缀操作符</h3><p>我们可以通过自定义infix函数来实现中缀操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> age:<span class="built_in">Int</span>)  <span class="comment">//声明Person数据类</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Person.<span class="title">grow</span><span class="params">(years:<span class="type">Int</span>)</span></span>:Person&#123; <span class="comment">//声明Person类型的中缀操作符函数</span></span><br><span class="line">    <span class="keyword">return</span> Person(name,age+years)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> person=Person(<span class="string">"kim"</span>,<span class="number">20</span>)</span><br><span class="line">    println(person.grow(<span class="number">5</span>))  <span class="comment">//直接调用函数</span></span><br><span class="line">    println(person grow <span class="number">5</span>)   <span class="comment">//中缀表达式调用方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testPerson()</span><br><span class="line">    <span class="comment">/*结果为Person(name=kim,age=25)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin类的学习</title>
    <url>/2020/04/22/Kotlin%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Kotlin类的学习"><a href="#Kotlin类的学习" class="headerlink" title="Kotlin类的学习"></a>Kotlin类的学习</h1><a id="more"></a>

<h2 id="1-oo编程的基本概念"><a href="#1-oo编程的基本概念" class="headerlink" title="1. oo编程的基本概念"></a>1. oo编程的基本概念</h2><p>类是对象的抽象化，而对象则是类的实例化。</p>
<img src="https://s1.ax1x.com/2020/04/22/JYTxYR.jpg" alt="img" style="zoom:50%;" />

<p>oo编程的基本概念</p>
<img src="https://s1.ax1x.com/2020/04/22/JYhWX4.jpg" alt="img" style="zoom:33%;" />



<hr>
<h2 id="2-声明类"><a href="#2-声明类" class="headerlink" title="2. 声明类"></a>2. 声明类</h2><h3 id="2-1-空类"><a href="#2-1-空类" class="headerlink" title="2.1 空类"></a>2.1 空类</h3><p>使用class关键字声明类。我们可以声明一个什么都不干的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnEmptyClass</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> anEmtyClass=AnEmptyClass()   <span class="comment">//kotlin中不需要使用new</span></span><br><span class="line">    println(anEmtyClass <span class="keyword">is</span> AnEmtyClass) <span class="comment">//结果打印为 truezai</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，我们可以在声明类的时候同时声明构造函数，语法格式是在类的后面使用括号包含构造函数的参数列表</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name:String, <span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> sex:String)&#123;</span><br><span class="line">        <span class="comment">//声明类和构造函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;    <span class="comment">//override关键字，用来重写toString()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person(name='<span class="variable">$name</span>',age=<span class="variable">$age</span>,sex='<span class="variable">$sex</span>')"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> person=Person(<span class="string">"kim"</span>,<span class="number">29</span>,<span class="string">"M"</span>)</span><br><span class="line">    println(<span class="string">"person=<span class="subst">$&#123;person&#125;</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*打印结果为：</span></span><br><span class="line"><span class="comment">    person=Person(name='jack',age=29,sex='M')</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-11-lateinit-关键字延迟属性初始化"><a href="#2-11-lateinit-关键字延迟属性初始化" class="headerlink" title="2.11 lateinit 关键字延迟属性初始化"></a>2.11 lateinit 关键字延迟属性初始化</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String  <span class="comment">//lateinit关键字表示该属性延迟初始化</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">0</span>  <span class="comment">//lateinit关键字不能修饰primitive类型</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person(name=<span class="variable">$name</span>,age=<span class="variable">$age</span>,sex=<span class="variable">$sex</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果使用2.1中的例子Person类，用以下方式调用Person类</span></span><br><span class="line"><span class="comment">val person=Person()</span></span><br><span class="line"><span class="comment">person.name="jack"</span></span><br><span class="line"><span class="comment">person.age=29</span></span><br><span class="line"><span class="comment">person.sex="M"</span></span><br><span class="line"><span class="comment">println("person=$&#123;person&#125;")</span></span><br><span class="line"><span class="comment">则会报以下错误</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'name'</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'age'</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'sex'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-constructor关键字声明具有多种构造方式的类"><a href="#3-constructor关键字声明具有多种构造方式的类" class="headerlink" title="3. constructor关键字声明具有多种构造方式的类"></a>3. constructor关键字声明具有多种构造方式的类</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>()&#123;         <span class="comment">//</span></span><br><span class="line">   <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String):<span class="keyword">this</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,sex:String):<span class="keyword">this</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">        <span class="keyword">this</span>.sex=sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person(name='<span class="variable">$name</span>',age=<span class="variable">$age</span>,sex='<span class="variable">$sex</span>')"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有一些样板代码，其实在IDEA中，上面的代码只需要下面3行代码即可替换，剩下的就交给IDEA自动生成了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>&#123;</span><br><span class="line">   <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String </span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">   <span class="comment">//剩下的在IDEA中自动生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IDEA中自动的步骤</p>
<ol>
<li><p>在当前类中右击，在弹出的快捷菜单中选择Generate命令</p>
</li>
<li><p>之后，弹出生成次级构造函数对话框，在其中选择Secondary Constructor命令，</p>
</li>
<li><p>选择构造函数的参数。选中相应的属性，单击OK按钮即可生成构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如上面的例子</span></span><br><span class="line"><span class="keyword">constructor</span>() <span class="comment">//一个属性都不选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String)&#123; <span class="comment">//选择一个name属性，生成带name参数的构造函数</span></span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;<span class="comment">//选择name和age属性，生成带name，age参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,sex:String):<span class="keyword">this</span>(name,age)&#123;<span class="comment">//选择全部属性，生成带有全部参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>当然用到最多的构造函数还是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name:String,<span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> sex:String)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-抽象类与接口"><a href="#4-抽象类与接口" class="headerlink" title="4. 抽象类与接口"></a>4. 抽象类与接口</h2><p>抽象类表示”is-a“的关系，而接口所代表的是”has-a”的关系。</p>
<p>抽象类用来表征问题领域的抽象概念。</p>
<p>所有编程语言都提供抽象机制。机器语言是对机器的模仿抽象。汇编语言是对机器语言的高层次抽象，高级语言是对汇编语言的高层次抽象。而面向对象编程语言是对过程函数的高层次封装。如下图 </p>
<p><img src="https://s1.ax1x.com/2020/04/22/JN7Y9A.jpg" alt="img"></p>
<p>抽象类和接口是Kotlin语言中两种不同的抽象概念，它们的存在对多态提供了非常好的支持。这个机制与java相同</p>
<hr>
<h3 id="4-1-抽象类与抽象成员"><a href="#4-1-抽象类与抽象成员" class="headerlink" title="4.1 抽象类与抽象成员"></a>4.1 抽象类与抽象成员</h3><p>以抽象类Shape为例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span>    //声明抽象父类<span class="title">Shape</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>: <span class="type">Shape</span></span>()  <span class="comment">//继承类的语法是使用冒号":",父类需要在这里使用构造函数进行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="type">Shape</span></span>()   <span class="comment">//Circle继承Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>: <span class="type">Shape</span></span>()    <span class="comment">//Tirangle继承Shape类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s=Shape()    <span class="comment">//编译不通过，不能实例化抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> r=Rectangle()</span><br><span class="line">println(r <span class="keyword">is</span> Shape())   <span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<p>一个类的成员包括属性和函数。抽象类的成员也必须是抽象的，需要使用abstract关键字修饰。下面声明一个带有成员的Shape抽象类.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> width:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> height:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，继承抽象类Shape的方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">                <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>): Shape()&#123;  <span class="comment">//声明类的同时声明了构造函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123; <span class="comment">//override是覆盖父类属性和函数的关键字</span></span><br><span class="line">        <span class="keyword">return</span> height*width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">             <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>):Shape()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> rectangle=Rectangle(<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> circle=Circle(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">2.0</span>)</span><br><span class="line">    println(<span class="string">"area=<span class="subst">$&#123;rectangle.area()&#125;</span>"</span>)  <span class="comment">//结果为： area=12.0</span></span><br><span class="line">    println(<span class="string">"area=<span class="subst">$&#123;circle.area()&#125;</span>"</span>)   <span class="comment">//结果为： area=12.56</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中可以有带实现的函数，例如在抽象类Shape中添加一个函数onClick():</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"I am a student"</span>) <span class="comment">//在抽象类中可以添加实现的函数，如onClick()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r=Rectangle(<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">0.0</span>)</span><br><span class="line">    r.onClick()     <span class="comment">//输出 I am a student</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类Shape中的onClick()函数默认是final的，不可以被覆盖重写。如果想要开放给子类重新实现这个函数，可以在前面加上open关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;   <span class="comment">//在函数onClick加上open关键字</span></span><br><span class="line">         println(<span class="string">"I am a student"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类中覆盖重写onClick函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">               <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>):Shape()&#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> height*width</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;    <span class="comment">//此处的Unit可以不用添加，当函数没有返回值时，默认为Unit相当于java中的void，这里添加当然就是为了再次复习一下。</span></span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;this::class.simpleName&#125;</span> is a teacher"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r=Rectangel()   <span class="comment">//Kotlin中，创建一个新对象时，不添加new</span></span><br><span class="line">    r.onClick()   <span class="comment">//打印结果为  Rectangle is a teacher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 this::class.simpleName 是 Kotlin 中反射的API，在Gradle工程的 build.gradle 中需要添加依赖compile：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">compile<span class="string">"org.jetbrains.kotlin:kotlin-reflect:<span class="variable">$kotlin_version</span>"</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-类继承的规则"><a href="#4-2-类继承的规则" class="headerlink" title="4.2 类继承的规则"></a>4.2 类继承的规则</h3><p>当子类继承了某个类之后，便可以使用父类中的成员变量，但并不是完全继承父类的所有成员变量。</p>
<ul>
<li>能够继承父类的public 和 protected 成员变量</li>
<li>不能继承父类的private类型的成员变量</li>
<li>对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能继承。</li>
<li>对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名变量。如果要在子类中访问父类中的同名成员变量，需要使用super关键字进行引用。</li>
</ul>
<hr>
<h2 id="5-接口"><a href="#5-接口" class="headerlink" title="5. 接口"></a>5. 接口</h2><p>接口是一种比抽象类更加抽象的 ”类“。接口本身代表的是一种”类型“的概念。但在语法层面，接口本身不是类，不能实例化接口，只能实例化它的实现类。</p>
<p>接口是用来建立类与类之间的协议。实现接口的实现类必须要实现该接口的所有方法。在Java8和Kotlin中，接口可以实现一些通用的方法。</p>
<p>接口是抽象类的延伸。在Kotlin和Java中一个类，不支持同时继承多个父类，也就是说一个类只能存在一个父类(单继承).</p>
<p>但是接口不同，一个类可以同时实现多个接口(多组合),无论这些接口之间有没有关系。这样可以实现多重继承。</p>
<p>与Java类似，Kotlin 使用interface作为接口的关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">projectService</span>    //<span class="title">Java</span>中使用<span class="title">interface</span>声明接口</span></span><br></pre></td></tr></table></figure>

<p>接口和抽象类都可以包含抽象的方法和实现的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">projectService</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> name:String</span><br><span class="line">   <span class="keyword">val</span> owner:String</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(project:<span class="type">Project</span>)</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">" I am project"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是没有构造函数的，使用冒号 ”:“ 语法来实现一个接口，如果有多个接口， 用 “,” 逗号隔开：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectServiceImpl</span> : <span class="type">ProjectService //与继承抽象类语法一样，使用冒号</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectMilestoneServiceImpl</span> : <span class="type">ProjectService</span>, <span class="type">MilestoneService  //实现多个接口使用逗号 "</span>,<span class="type">" 隔开</span></span></span><br></pre></td></tr></table></figure>

<p>假如说在 ProjectMilestoneServiceImpl 类中要重写print()方法时，该类继承的两个接口类  ProjectService，MilestoneService 中都有一个print()方法。当直接使用super.print() 函数时，编译器无法知道我们想要调用的是哪个print函数，我们把这种现象叫做覆盖冲突。</p>
<p>这个时候，我们可以使用下面的语法来调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>&lt;ProjectService&gt;.print()  <span class="comment">//使用super&lt;ProjectService&gt;指定调用的是ProjectService接口中的print()函数</span></span><br><span class="line"><span class="keyword">super</span>&lt;MilestoneService&gt;.print() <span class="comment">//使用super&lt;MilestoneService&gt;指定调用的是MilestoneService接口中的print()函数</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-object对象"><a href="#6-object对象" class="headerlink" title="6. object对象"></a>6. object对象</h2><p>单例模式是一种常用的软件设计模式。例如，Spring中的Bean默认就是单例。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p>
<p>Kotlin中没有静态属性和方法，但是可以使用关键字object声明一个object单例对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> User&#123;   <span class="comment">//声明对象类型User</span></span><br><span class="line">    <span class="keyword">val</span> username:String = <span class="string">"admin"</span></span><br><span class="line">    <span class="keyword">val</span> password:String = <span class="string">"admin"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"Hello, object!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(User.username)    <span class="comment">//与Java静态类的调用形式一样</span></span><br><span class="line">    println(User.password)    </span><br><span class="line">    User.hello()              <span class="comment">//与Java静态方法的调用方式一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-Kotlin中还提供了伴生对象，用companion-object关键字声明："><a href="#7-Kotlin中还提供了伴生对象，用companion-object关键字声明：" class="headerlink" title="7. Kotlin中还提供了伴生对象，用companion object关键字声明："></a>7. Kotlin中还提供了伴生对象，用companion object关键字声明：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> DataProcessor&#123; <span class="comment">//使用companion object声明DataProcessor的伴生对象</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> process&#123;</span></span><br><span class="line">            println(<span class="string">"I am processing data..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    DataProcessor.process()   <span class="comment">//I am processing data...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类只能有一个伴生对象</p>
<hr>
<h2 id="8-数据类"><a href="#8-数据类" class="headerlink" title="8. 数据类"></a>8. 数据类</h2><p>数据类就只存储数据，不包含操作行为的类。Kotlin中的数据类可以为我们节省大量的样板代码(Java中强制我们要去写一堆getter、setter代码，而实际上这些方法都是“不言而明”的)，这样最终的代码更易于理解，便于维护。</p>
<h3 id="8-1-创建数据类"><a href="#8-1-创建数据类" class="headerlink" title="8.1 创建数据类"></a>8.1 创建数据类</h3><p>使用关键字为data class创建一个只包含数据的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span></span>(<span class="keyword">val</span> username:String,<span class="keyword">val</span> password:String)</span><br></pre></td></tr></table></figure>

<p>在IDEA中提供了方便的Kotlin工具箱，我们可以把上面的代码反编译成等价的Java代码。</p>
<hr>
<h3 id="8-2-数据类自动创建的函数"><a href="#8-2-数据类自动创建的函数" class="headerlink" title="8.2 数据类自动创建的函数"></a>8.2 数据类自动创建的函数</h3><ul>
<li>equals()/hashCode()函数toString()格式为“LoginUser(username=”this.username+”,password=”+this.password+”)”;</li>
<li>component1()和component2()函数返回对应下标的属性值，按声明顺序排列;</li>
<li>copy()函数：根据旧对象属性重新newLoginUser(username,password)一个对象出来。</li>
</ul>
<p>如果这些函数在类中已经被明确定义了，或者从超类中继承而来，编译器就不再生成。</p>
<hr>
<h3 id="8-3-数据类的语法限制"><a href="#8-3-数据类的语法限制" class="headerlink" title="8.3 数据类的语法限制"></a>8.3 数据类的语法限制</h3><p>数据类有如下限制：</p>
<ul>
<li>主构造函数至少包含一个参数；</li>
<li>参数必须标识为val或者var；</li>
<li>不能为abstract、open、sealed或者inner；</li>
<li>不能继承其他类(但可以实现接口)</li>
</ul>
<p>另外，数据类可以在解构声明中使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span></span>(<span class="keyword">val</span> username:String,<span class="keyword">val</span> password:String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> loginUser=LoginUser(<span class="string">"admin"</span>,<span class="string">"admin"</span>)</span><br><span class="line">    <span class="keyword">val</span>(username,password)=loginUser<span class="comment">//解构声明(username,password)</span></span><br><span class="line">    println(<span class="string">"username=<span class="subst">$&#123;username&#125;</span>,password=<span class="subst">$&#123;password&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">//username=admin,password=admin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-4-Pair和Triple"><a href="#8-4-Pair和Triple" class="headerlink" title="8.4 Pair和Triple"></a>8.4 Pair和Triple</h3><p>Kotlin标准库提供了Pair和Triple数据类，分别表示二元组和三元组对象。它们的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="type">out A,out B</span>&gt;</span>(</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> first:A,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> second:B):Serializable&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String=<span class="string">"&#123;<span class="variable">$first</span>,<span class="variable">$second</span>&#125;"</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;A,B&gt;</span>A.<span class="title">to</span><span class="params">(that:<span class="type">B</span>)</span></span>:Pair&lt;A,B&gt;=Pair(<span class="keyword">this</span>,that)<span class="comment">// 中缀函数to()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Triple</span>&lt;<span class="type">out A,out B, out C</span>&gt;</span>(</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> first:A,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> second:B,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> third:C): Serializable&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String=<span class="string">"&#123;<span class="variable">$first</span>,<span class="variable">$second</span>,<span class="variable">$third</span>&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Pair和Triple这两个函数系统已经定义好了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"A"</span>,<span class="number">2</span> to <span class="string">"B"</span>,<span class="number">3</span> to <span class="string">"C"</span>)</span><br><span class="line">    println(map)   <span class="comment">//结果打印&#123;1=A, 2=B,3=C&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
</search>
