<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android错误</title>
    <url>/2020/04/12/Android%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>Android Studio报错：Caused by: org.gradle.api.resources.ResourceException: Could not get resource </p>
<a id="more"></a>

<p>Android Studio版本号：3.6</p>
<p>解决办法：把原有build配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">   repositories&#123;</span><br><span class="line">      jcenter()</span><br><span class="line">      google()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">allprojects</span>&#123;</span><br><span class="line">   <span class="variable">repositories</span>&#123;</span><br><span class="line">      <span class="comment">//新加</span></span><br><span class="line">      <span class="function"><span class="title">mavenCentral</span>()</span></span><br><span class="line">      <span class="function"><span class="title">mavenLocal</span>()</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="title">jcenter</span>()</span></span><br><span class="line">      <span class="function"><span class="title">google</span>()</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后更新build文件，rebuild后，该错误消失。</p>
<p>据了解jcenter()和mavenCentral()是Android Studio中Gradle插件使用的仓库。Android Studio早期版本使用的是MavenCentral，从某个时候开始切换到jcenter了，也就是说，项目之所以报错，是因为该项目的Android Studio是早期的版本。之所以使用jcenter在性能和占存储大小方面比mavenCentral更优：</p>
<ol>
<li>jcenter 是世界上最大的java仓库</li>
<li>jcenter通过CDN服务，使用的是https协议，安全性更高，而Android Studio 0.8版本mavenCentral使用的是http协议</li>
<li>jcenter是mavenCentral的超集，包括许多额外的仓库</li>
<li>jcenter性能方面比mavenCentral更优</li>
<li>mavenCentral会自动下载很多与IDE相关的index，而这些用到的少，且不是必需</li>
</ol>
<p>而mavenLocal则是用来指定本地仓库路径的，使用mavenLocal就是默认本地路径。若是自定义本地路径，则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">   maven&#123;url <span class="string">'D://Users/user2/.m2/repository'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML元素--1</title>
    <url>/2020/04/06/HTML%E5%85%83%E7%B4%A01/</url>
    <content><![CDATA[<h1 id="HTML元素小记–ol-ul-dl-table"><a href="#HTML元素小记–ol-ul-dl-table" class="headerlink" title="HTML元素小记–ol-ul-dl-table"></a>HTML元素小记–ol-ul-dl-table</h1><a id="more"></a>

<p>可能这些东西对某些大佬老说已经非常熟悉了，但是作为小白的我，依旧需要记录一下，毕竟web前端不是经常用，而且写博客也是催促自己学习的一种方式，若某天大佬看了，请自动忽略本文。只供自己学习用，请勿嘲笑。</p>
<h2 id="1-无序列表标签–ul"><a href="#1-无序列表标签–ul" class="headerlink" title="1. 无序列表标签–ul"></a>1. 无序列表标签–ul</h2><ul>是无序的列表标签，无序嘛，就是列表中的内容是没有顺序的。无序列表中的每一项是<li>

<p>所有主流浏览器都支持ul标签。</p>
<p> 英文单词解释：</p>
<pre><code>*ul: unordered list, &quot;无序列表&quot;

*li: list item, &quot;列表项&quot;</code></pre><p>例如(示例使用了Vue框架，使用时请自行引入Vue框架文件)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ex1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"text in texts"</span>&gt;</span></span><br><span class="line">                &#123;&#123;text.node&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ex1=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#ex1'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            text:[</span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'苹果'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'梨'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;node:<span class="string">'草莓'</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器效果如下：</p>
<ul>
<li>苹果</li>
<li>梨</li>
<li>草莓</li>
</ul>
<hr>
<p>属性：</p>
<ul>
<li>type=”属性值”。属性值可选: disc(实心原点，默认), square(实心方点)，circle(空心圆)</li>
</ul>
<hr>
<p>注意：</p>
<ul>
<li>注意li不能单独使用，且ul标签中的”儿子标签”只能是 li .</li>
<li>ul的作用：是增加无序列表的”语义”的。</li>
<li>li 是一个容器标签，可以放其他的标签元素，甚至是ul</li>
<li>这里就不比较HTML和XHTML之间的差异了，如果需要请自行到<a href="https://www.w3school.com.cn/tags/tag_ul.asp" target="_blank" rel="noopener">W3school</a>查看</li>
</ul>
<hr>
<p>ul 标签可以多层复杂嵌套：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>水果<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>鲜花<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>玫瑰花</span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>红玫瑰<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>白玫瑰<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>康乃馨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>杜鹃花<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>丁香花<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>应用场景：</p>
<ul>
<li>导航栏</li>
<li>类似于购物清单列表</li>
</ul>
<hr>
<h2 id="2-有序列表-–ol-里面的每一项是–-li"><a href="#2-有序列表-–ol-里面的每一项是–-li" class="headerlink" title="2. 有序列表 –ol,  里面的每一项是– li"></a>2. 有序列表 –ol,  里面的每一项是– li</h2><p>所有主流浏览器都支持ol标签。</p>
<p>英文单词：</p>
<p>ol :  Ordered List.</p>
<p>例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ex2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">                &#123;&#123;todo.text&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#ex2'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line">            todos:[</span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'苹果'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'梨'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">                &#123;text:<span class="string">'草莓'</span>&#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>演示效果如下：</p>
<ol start="50">
<li>苹果</li>
<li>梨</li>
<li>草莓</li>
</ol>
<hr>
<p>属性：</p>
<ul>
<li>reversed ：规定列表顺序为降序。(9,8,7…) 默认是顺序。</li>
<li>start ：规定有序列的起始值。</li>
<li>type ：规定在列表中使用的标记类型。如：(1, A ,a ,I ,i ).</li>
</ul>
<hr>
<p>ol也可以多层嵌套。</p>
<h2 id="3-定义列表-–dl"><a href="#3-定义列表-–dl" class="headerlink" title="3. 定义列表 –dl"></a>3. 定义列表 –dl</h2><p>dl英文单词：definition list，没有属性。dl的子元素只能是dt和dd。</p>
<p>dt : definition title列表的标题，这个标签是必须的。</p>
<p>dd ：definition description 列表的列表项，如果不需要它，可以不加。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第一天<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>跑步<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>写代码<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第二天<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>陪老婆<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>画画<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dd</span>&gt;</span>做饭<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以这样使用dl</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>购物指南<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>购物流程<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>会员介绍<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>生活旅行/团购<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>常见问题<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>大家电<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>联系客服<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>配送方式<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>上门自提<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>211限时达<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>配送服务查询<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>配送费收取标准<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>海外配送<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-表格标签–table"><a href="#4-表格标签–table" class="headerlink" title="4. 表格标签–table"></a>4. 表格标签–table</h2><p>一个表格table是由每行tr组成的，每行是由td组成的。即一个表格是由行组成的，每行又是由列组成的。</p>
<p>例如，3行4列的单元格：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>生命壹号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>黄冈<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>许嵩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>29<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>邓紫棋<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">td</span>&gt;</span>香港<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上图表格中是没有边框的。因此需要设置table的属性：</p>
<p>table的属性：</p>
<ul>
<li>border：边框。像素为单位。</li>
<li>style=“border-collapse:collapse；”      ：单元格的线和表格的边框合并</li>
<li>width：宽度。px为单位。</li>
<li>height：高度。px为单位。</li>
<li>bordercolor：表格的边框颜色。</li>
<li>align：表格的水平对齐方式。属性值可以填：left right cente。注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签td进行设置)</li>
<li>cellpadding : 单元格内容到边的距离，像素为单位。默认情况下指最左侧那条边。如果设置属性 dir=”rtl”, 那就指的是内容到最右边那条线的距离。</li>
<li>cellspacing ：单元格和单元格之间的距离(外边距)，px为单位。默认情况下对的值为0.</li>
<li>bgcolor=”#99cc66”：表格的背景颜色。</li>
<li>background=”路径src/…”：背景图片。</li>
<li>bordercolorlight：表格的上、左边框，以及单元格的右、下边框的颜色。</li>
<li>bordercolordark：表格的右、下边框，以及单元格的上、左的边框的颜色。这两个属性的目的是为了设置3D的效果。</li>
<li>dir：公有属性，单元格内容的排列方式。可以取值：ltr：从左到右(默认)，rtl：从右到左。既然说dir是公有属性，如果把这个属性放在任意标签中，那表明这个标签的位置可能会从右开始排列。</li>
</ul>
<hr>
<p>对于<tr>：行</p>
<p>属性：</p>
<ul>
<li><p>dir：公有属性，设置一行单元格内容的排列方式。具体上面讲过。</p>
</li>
<li><p>bgcolor：设置一行单元格的背景颜色。</p>
</li>
<li><p>height：一行单元格的高度。</p>
</li>
<li><p>align=”center”：一行的内容水平居中显示，取值：left、center、right。</p>
</li>
<li><p>valign=”center”：一行内容垂直居中，取值：top、middler、bottom。</p>
<p>注：th：加粗的单元格。相当于td+b 属性同td标签一样。使用时和tr标签并列。</p>
<hr>
<p>表格的thead标签、tbody标签、tfoot标签</p>
<p>当浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候从按照代码的从上到下的顺序来显示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML小记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识与数据结构</title>
    <url>/2020/09/20/Java%E5%AD%A6%E4%B9%A0-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Java基础知识与数据结构"><a href="#Java基础知识与数据结构" class="headerlink" title="Java基础知识与数据结构"></a>Java基础知识与数据结构</h1><a id="more"></a>

<h2 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="*Java Scanner 类"></a>*Java Scanner 类</h2><p>通过Scanner类来获取用户的输入，创建Scanner对象的基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<h3 id="1-next-与nextLine-方法获取输入的字符串"><a href="#1-next-与nextLine-方法获取输入的字符串" class="headerlink" title="1. next() 与nextLine()方法获取输入的字符串"></a>1. next() 与nextLine()方法获取输入的字符串</h3><p>hasNext 和hasNexLine判断是否还有输入的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerDemo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">       Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="comment">//从键盘上接收数据</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//next方式接收字符串</span></span><br><span class="line">       System.out.println(<span class="string">"next方式接收字符串"</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//判断是否还有输入</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * next()</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span>(scan.hasNext())&#123;</span><br><span class="line">           String str1 = scan.next();</span><br><span class="line">           System.out.println(<span class="string">"输入的数据为："</span>+str1);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       *nextLine()</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">if</span>(scan.hasNextLine())&#123;</span><br><span class="line">           String str2 = scan.nextLine();</span><br><span class="line">           System.out.println(<span class="string">"输入的数据为："</span>+str2);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       scan.close(); <span class="comment">//释放资源</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//next() 结果：比如说输入 jjjj kkkk   则只打印jjjj</span></span><br><span class="line"><span class="comment">//nextLine() 结果：比如说输入 jjjj kkkk 则打印jjjj kkkk</span></span><br></pre></td></tr></table></figure>

<h4 id="next-："><a href="#next-：" class="headerlink" title="*next()："></a>*next()：</h4><p>1.一定要读取到有效字符后才可以结束输入。</p>
<p>2.对输入有效字符之前遇到的空白，next()方法会自动将其去掉</p>
<p>3.只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符</p>
<p>4.next()不能得到有空格的字符串</p>
<h4 id="nextLine-："><a href="#nextLine-：" class="headerlink" title="*nextLine()："></a>*nextLine()：</h4><p>1.以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符。</p>
<p>2.可以获得空白</p>
<p>如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> j = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">if</span>(scan.hasNextInt())&#123;   <span class="comment">//判断输入是否为整数</span></span><br><span class="line">            i = scan.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"输入的整数数据"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入有误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat())&#123;   <span class="comment">//判断输入的是否为浮点数</span></span><br><span class="line">            j = scan.nextFloat();</span><br><span class="line">            System.out.println(<span class="string">"输入的浮点型数据为："</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();   <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下实例我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字来结束输入并输出执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">       Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">double</span> x,sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(scan.hasNextDouble())&#123;  <span class="comment">//判断下个是否为Double数据</span></span><br><span class="line">            x = scan.nextDouble();   <span class="comment">//获取下个Double数据的值</span></span><br><span class="line">            m = m+<span class="number">1</span>;</span><br><span class="line">            sum = sum + x;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"和为："</span>+sum);</span><br><span class="line">       System.out.println(<span class="string">"平均值为："</span>+sum/m);</span><br><span class="line">       scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个会一直输入，直到不为Double类型数据为止，之间就是有多行空行也不影响，可以用空格和空行隔开数据，这样的数据都是有效数据</span></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="*数组"></a>*数组</h2><h3 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h3><p>声明数组变量，才能在程序中使用数组，下面是声明数组变量的语法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar;  <span class="comment">//首选的方法</span></span><br><span class="line">dataType arrayRefVar[];  <span class="comment">//效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure>

<p>Java语言使用new操作符来创建数组，语法如下：</p>
<p>arrayRefvar = new dataType[arraySize];</p>
<p>上面的语法语句做了两件事：</p>
<p>一、使用dataType[arraySize]创建了一个数组</p>
<p>二、把新创建的数组的引用赋值给变量arrayRefVar。</p>
<h3 id="数组变量的声明"><a href="#数组变量的声明" class="headerlink" title="数组变量的声明"></a>数组变量的声明</h3><p>和创建数组可以用一条语句完成，如下所示：</p>
<p>dataType [] arrayRefVar = new dataType[arraySize]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如下面创建的int，double，String类型的一维数组</span></span><br><span class="line">       <span class="keyword">int</span>[] arryInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];   </span><br><span class="line">       <span class="keyword">double</span>[] arrayDouble = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">30</span>];</span><br><span class="line">       String[] arrayString = <span class="keyword">new</span> String[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 查找最大元素</span></span><br><span class="line">      <span class="keyword">double</span> max = myList[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (myList[i] &gt; max) max = myList[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK 1.5中引进了一种新的循环类型,被称为For-Each循环或者加强型循环，它能在不使用下标的情况下遍历数组。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">1.1</span>,<span class="number">2</span>,<span class="number">3.3</span>,<span class="number">5.9</span>,<span class="number">19.5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> element:myList)&#123;</span><br><span class="line">            System.out.Println(element);</span><br><span class="line">            <span class="comment">//结果为：</span></span><br><span class="line">            <span class="comment">//1.1</span></span><br><span class="line">            <span class="comment">//2.0</span></span><br><span class="line">            <span class="comment">//3.3</span></span><br><span class="line">            <span class="comment">//5.9</span></span><br><span class="line">            <span class="comment">//19.5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组可以作为参数传递给方法，例如，下面的例子就是一个打印的int数组元素的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">      System.out.print(array[i]+<span class="string">""</span>);  <span class="comment">//用print可以不换行输出</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用 printArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>&#125;);  <span class="comment">//调用函数，打印3 1 2 6 4 2</span></span><br></pre></td></tr></table></figure>

<p>数组作为函数的返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] list)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>,j =result.length-<span class="number">1</span>;i&lt;list.length;i++,j--)&#123;</span><br><span class="line">        result[j] = list[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">多维数组的动态初始化</span><br><span class="line">type[][] typename = <span class="keyword">new</span> type[typelength1][typelength2]</span><br><span class="line"></span><br><span class="line">例如String str[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line">先跟类型在跟[][]</span><br></pre></td></tr></table></figure>

<h2 id="Java中Map的操作"><a href="#Java中Map的操作" class="headerlink" title="*Java中Map的操作"></a>*Java中Map的操作</h2><p>Java中Map集合中的元素为两个对象，一个是Key，一个是value，一个key和一个value对应，一次存入一对元素，eg：Map&lt;String,String&gt; map = new Hash Map&lt;String,String&gt; 其存储的数据类型是任意的。</p>
<h3 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="*HashMap与HashTable"></a>*HashMap与HashTable</h3><p>Hashmap中的链表大小超过8个时会自动转化为红黑树，当删除小于6时重新变为链表，为啥呢？</p>
<h4 id="HashMap的线程安全"><a href="#HashMap的线程安全" class="headerlink" title="*HashMap的线程安全"></a>*HashMap的线程安全</h4><h5 id="1-Collections-synchronizedMap-map-mutex-有条件的线程安全性"><a href="#1-Collections-synchronizedMap-map-mutex-有条件的线程安全性" class="headerlink" title="1.Collections.synchronizedMap(map,mutex)(有条件的线程安全性)"></a>1.Collections.synchronizedMap(map,mutex)(有条件的线程安全性)</h5><p>即单个的操作都是线程安全的，但是多个操作组成的操作序列却可能导致数据的争用，因为在操作序列中控制流取决于前面操作的结果</p>
<p>怎样创建synchronizedMap呢？</p>
<p><img src="C:%5CUsers%5CPXN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200910093634577.png" alt="image-20200910093634577"></p>
<p>其中排斥锁默认的this就是调用的synchronizedMap的对象，就是上面的map。</p>
<p>创建出synchronizedMap后，在对map操作的时候，就会对map的方法上锁</p>
<p><img src="C:%5CUsers%5CPXN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200910094042039.png" alt="image-20200910094042039"></p>
<p>清单1中第一片段展示了公用的put - if - absent语句块 - 如果一个条目不在Map中，那么添加这个条目。不幸的是，在containsKey()方法返回到put()方法被调用这段时间内，可能会有另一个带有相同键的值。如果您想确保只有一次插入，您需要用一个对Map m 进行同步的同步块将这一对语句包装起来。</p>
<p><strong>清单1</strong>中其他的例子与迭代有关。在第一个例子中，<code>List.size()</code> 的结果在循环的执行期间可能会变得无效，因为另一个线程可以从这个列表中删除条目。如果时机不得当，在刚好进入循环的最后一次迭代之后有一个条目被另一个线程删除 了，则<code>List.get()</code>将返回<code>null</code>，而<code>doSomething()</code> 则很可能会抛出一个<code>NullPointerException</code>异常。那么，采取什么措施才能避免这种情况呢？如果当您正在迭代一个<code>List</code>时另一个线程也 可能正在访问这个 <code>List</code>，那么在进行迭代时您必须使用一个<code>synchronized</code>块将这个<code>List</code>包装起来， 在<code>List</code> 1 上同步，从而锁住整个<code>List</code>。这样做虽然解决了数据争用问题，但是在并发性方面付出了更多的代价，因为在迭代期间锁住整个<code>List</code>会阻塞其他线程，使它们在很长一段时间内不能访问这个列表。</p>
<p>集合框架引入了迭代器，用于遍历一个列表或者其他集合，从而优化了对一个集合中的元素进行迭代的过程。然而，在<code>java.util</code> 集合类中实现的迭代器极易崩溃，也就是说，如果在一个线程正在通过一个<code>Iterator</code>遍历集合时，另一个线程也来修改这个 集合，那么接下来的<code>Iterator.hasNext()</code> 或<code>Iterator.next()</code>调用将抛出<code>ConcurrentModificationException</code>异常。就拿 刚才这个例子来讲，如果想要防止出现<code>ConcurrentModificationException</code>异常，那么当您正在进行迭代时，您必须 使用一个在 <code>List l</code>上同步的<code>synchronized</code>块将该 <code>List</code> 包装起来，从而锁住整个 <code>List</code>。（或者，您也可以调用<code>List.toArray()</code>，在 不同步的情况下对数组进行迭代，但是如果列表比较大的话这样做代价很高）</p>
<p><a href="https://blog.csdn.net/varyall/article/details/81276473" target="_blank" rel="noopener">https://blog.csdn.net/varyall/article/details/81276473</a></p>
<p><a href="https://blog.csdn.net/u011212394/article/details/82228321?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/u011212394/article/details/82228321?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p>
<p><img src="C:%5CUsers%5CPXN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200910100143016.png" alt="image-20200910100143016"></p>
<h2 id="Java排序"><a href="#Java排序" class="headerlink" title="*Java排序"></a>*Java排序</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMjMyMzg0NDktMjE0NjE2OTE5Ny5naWY" alt=""></p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="*原理："></a>*原理：</h4><p>比较两个相邻的元素，将值大的元素交换至右端。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="*思路："></a>*思路：</h4><p>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个…..第一趟后，最后一位数是所有元素中最大的数，所以下一轮不要比较，则需要比较 arr.length - i -1次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                  arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                  arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>##* java 生成随机数</p>
<p>Java 中提供了一个获取随机数的一个类(Math) </p>
<p>Math: 此类在java.lang包下，jvm会自动导入，所以无需import导包生成随机数要使用Math类下的方法：random() 方法的返回值是</p>
<p>[0.0-1.0]</p>
<ol>
<li><p>获取上述范围内的随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = Math.random();</span><br><span class="line">System.out.println(d);  <span class="comment">//输出结果为 [0.0-1.0]  范围的double类型的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)(Math.random());</span><br><span class="line">System.out.println(num)  <span class="comment">//打印的结果则一直为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成1~100之间的随机数</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">Syetem.out.print(num);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个1~100之间的随机数(int 型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num =(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>+<span class="number">1</span>);</span><br><span class="line">System.out.print(num);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个任意范围(n~m)之间的随机函数(int 型)</p>
<p>int num = (int)(Math.random()*(m-n+1)+n);</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取一个任意范围(n~m)之间的随机整数 (int型)</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)(Math.random()*(<span class="number">200</span>-<span class="number">100</span>+<span class="number">1</span>)+<span class="number">100</span>);</span><br><span class="line">System.out.print(num);</span><br></pre></td></tr></table></figure>





<h2 id="Synchronized-同步机制"><a href="#Synchronized-同步机制" class="headerlink" title="*Synchronized(同步机制)"></a>*Synchronized(同步机制)</h2><h2 id="Obeject-对象占16个byte内存空间"><a href="#Obeject-对象占16个byte内存空间" class="headerlink" title="*Obeject 对象占16个byte内存空间"></a>*Obeject 对象占16个byte内存空间</h2><h2 id="Java子类继承父类重写父类函数和变量问题"><a href="#Java子类继承父类重写父类函数和变量问题" class="headerlink" title="*Java子类继承父类重写父类函数和变量问题"></a>*Java子类继承父类重写父类函数和变量问题</h2><p>首先定义父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"In Parent,a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义子类B，并继承父类A，然后重写公有变量a和公有函数printA()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> a = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b = <span class="number">520</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(<span class="string">"In son,a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(<span class="string">"In son,b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义主类和main函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        A ob1 = <span class="keyword">new</span> B();</span><br><span class="line">        A ob2 = <span class="keyword">new</span> A();</span><br><span class="line">        B ob3 = <span class="keyword">new</span> B();</span><br><span class="line">        </span><br><span class="line">        ob1.printA();</span><br><span class="line">        ob2.printA();</span><br><span class="line">        ob3.printA();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        ob1.printB();  </span></span><br><span class="line"><span class="comment">        System.out.println(ob1.b);</span></span><br><span class="line"><span class="comment">//会报错，因为用子例的实例赋值给父类的对象，只能调用同名函数和变量</span></span><br><span class="line"><span class="comment">        ob2.printB();</span></span><br><span class="line"><span class="comment">        System.out.println(ob2.b);</span></span><br><span class="line"><span class="comment">       //父类不能调用子类声明的对象和变量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        ob3.printB();</span><br><span class="line"></span><br><span class="line">        System.out.println(ob1.a);</span><br><span class="line">        System.out.println(ob2.a);</span><br><span class="line">        System.out.println(ob3.a);</span><br><span class="line">        System.out.println(ob3.b);</span><br><span class="line">        </span><br><span class="line">     <span class="comment">/*输出结果如下：</span></span><br><span class="line"><span class="comment">     In son,a=31</span></span><br><span class="line"><span class="comment">	In Parent,a=0</span></span><br><span class="line"><span class="comment">	In son,a=31</span></span><br><span class="line"><span class="comment">	In son,b=520</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	0</span></span><br><span class="line"><span class="comment">	32</span></span><br><span class="line"><span class="comment">	520</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*子类与父类同名变量和函数的定义</span></span><br><span class="line"><span class="comment">1. 当父类的函数定义为public或protected时，则子类的同名函数可以为public，且当父类为protected时，子类也可以为protected，剩下的情况均与父类同名函数保持一致。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.父类和子类的同名函数可以不保持一致，并且当子类的同名变量定义为私有，而父类为公有时，当调用同名函数比如printA()时，此时输出的变量a还是用子类定义的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*子类调用与父类同名函数时</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.  A ob1 = new B();</span></span><br><span class="line"><span class="comment">1.1当用子类的实例赋给父类的对象时，调用名字相同的函数时</span></span><br><span class="line"><span class="comment">会调用子类的函数，并且当子类的函数中使用了和父类同名的变量时，也会优先调用子类的变量，</span></span><br><span class="line"><span class="comment">1.2但是用父类的对象调用子类的函数和变量时，只能调用与父类定义的同名的函数和变量。</span></span><br><span class="line"><span class="comment">1.3 且子类中若是没有声明需要调用的函数，则调用父类的函数</span></span><br><span class="line"><span class="comment">1.4 直接调用同名变量时，则会优先调用父类的变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. A ob2 = new A(); B ob3 = new B();</span></span><br><span class="line"><span class="comment">2.1当用父类的实例赋值给父类的对象，子类的实例赋值给子类的对象时，都是照常的，父类调用父类中的函数和变量，子类调用子类中的函数和变量</span></span><br><span class="line"><span class="comment">2.2 调用和父类同名的函数时，若是，子类中没有重新声明与父类同名的变量时，子类的函数则会调用父类定义的变量，且对该变量的操作只能在子类的函数中做修改，不管函数名是否与父类同名，都可以对该变量进行相应的操作</span></span><br><span class="line"><span class="comment">2.3 子类可以有不同于父类的变量和函数。且函数中也可以调用与父类同名的函数和变量，只不过会优先调用子类中声明的，同时，也可以在子类的其他函数中调用父类的函数和变量</span></span><br></pre></td></tr></table></figure>

<h2 id="Java子类能否重写-覆盖-父类的静态方法？"><a href="#Java子类能否重写-覆盖-父类的静态方法？" class="headerlink" title="*Java子类能否重写(覆盖)父类的静态方法？"></a>*Java子类能否重写(覆盖)父类的静态方法？</h2><p>答案：不能重写，也就是不能被覆盖</p>
<p>但是子类可以继承父类的静态变量和静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticParent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"In Parent, a = "</span> + a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//2.定义子类并继承父类</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSon</span> <span class="keyword">extends</span> <span class="title">StaticParent</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//2.1不重写父类的方法和变量，可以成功调用</span></span><br><span class="line">    		printA();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.重写父类的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSon</span> <span class="keyword">extends</span> <span class="title">StaticParent</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//3.1 重写后依然会调用父类的静态方法，子类重写的静态方法不会覆盖掉父类的。</span></span><br><span class="line">    		printA();</span><br><span class="line">            <span class="comment">//输出：In Parent, a = 0;</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">//	@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		System.out.println(<span class="string">"In son a = "</span> + a);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注：@Override重写标记，表示下面的方法必须重写父类的方法，使用后会报错</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-泛型</title>
    <url>/2020/05/02/Kotlin-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Kotlin-泛型"><a href="#Kotlin-泛型" class="headerlink" title="Kotlin 泛型"></a>Kotlin 泛型</h1><a id="more"></a>

<h2 id="1-参数化类型-Parameterized-Type"><a href="#1-参数化类型-Parameterized-Type" class="headerlink" title="1.参数化类型( Parameterized Type)"></a>1.参数化类型( Parameterized Type)</h2><p>   参数化类型，顾名思义就是将类型由原来的具体化类型参数化，类似于方法中的变量参数，此时类型也       定义成参数形式，我们称之为类型参数，然后在使用时传入具体的类型(类型参数)</p>
<p>在没有泛型之前，在Java中，Object类是所有类的根类 为了集合类的通用性，把元素的类型定义为Object，当放入具体的类型时，再进行相应的强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RawArrayList</span></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span> Object[] element;    <span class="comment">//把元素的类型定义为Object</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RawArrayList</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123; <span class="comment">//构造函数</span></span><br><span class="line">      <span class="keyword">this</span>.length=length;</span><br><span class="line">      <span class="keyword">this</span>.element=<span class="keyword">new</span> Object[length];  <span class="comment">//创建一个长度为length的Object数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;   <span class="comment">//get方法</span></span><br><span class="line">      <span class="keyword">return</span> element[index];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,Object element)</span></span>&#123;  <span class="comment">//个下标位置为index的元素赋值为element</span></span><br><span class="line">      elements[index]=element;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RawTypeDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           RawArrayList rawArrayList = <span class="keyword">new</span> RawArrayList(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">           rawArrayList.add(<span class="string">"a"</span>);</span><br><span class="line">           rawArrayList.add(<span class="string">"b"</span>);</span><br><span class="line">           System.out.println(rawArrayList);</span><br><span class="line">           </span><br><span class="line">          String a=(String)rawArrayList.get(<span class="number">0</span>);</span><br><span class="line">          System.out.println(a);</span><br><span class="line">        </span><br><span class="line">          String b=(String)rawArrayList.get(<span class="number">1</span>);</span><br><span class="line">          System.out.println(b);</span><br><span class="line">          </span><br><span class="line">          rawArrayList.add(<span class="number">2</span>,<span class="number">200</span>);</span><br><span class="line">          rawArrayList.add(<span class="number">3</span>,<span class="number">300</span>);</span><br><span class="line">          System.out.println(rawArrayList)</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">int</span> c=(<span class="keyword">int</span>)rawArrayList.get(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">int</span> d=(<span class="keyword">int</span>)rawArrayList.get(<span class="number">3</span>);</span><br><span class="line">          System.out.println(c);</span><br><span class="line">          System.out.println(d);</span><br><span class="line">          </span><br><span class="line">          String x=(String)rawArrayList.get(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//上句报错:Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span></span><br><span class="line">        <span class="comment">//对于这行代码，编译时不会报错，但是运行时会抛出类型转换错误。</span></span><br><span class="line">          System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用原生态类型(rawtype) 实现的集合类中，我们使用的是Object[]数组。这种实现方式存在的问题有两个：</p>
<ul>
<li>向集合中添加对象元素的时候，没有对元素的类型进行检查。也就是说，我们向集合中添加任意对象，编译器都不会报错。</li>
<li>当我们从集合中获取一个值的时候，不能都使用Object类型，需要进行强制类型转换。而这个转换过程由于在添加元素的时候没有做任何的类型的限制与检查，所以容易出错。</li>
</ul>
<p>我们将这个元素类型String的信息存放到一个“类型参数”中，然后在编译器层面引入相应的类型检查和自动转换机制，这样就可以解决类型安全使用的问题了。这也正是引入泛型的基本思想。</p>
<p>也就是是说，在向rawArrayList添加元素的时候，就限定其元素类型只能为String，然后在后面获取元素的时候，自动强制转型为String。</p>
<ul>
<li>泛型最主要的优点就是让编译器追踪参数类型，执行类型检查和类型转换。为由编译器来保证类型转换不会失败，如果依赖程序员自己去追踪对象类型和执行转换，那么运行时产生的错误将很难去定位和调试。</li>
</ul>
<hr>
<h2 id="2-在类、接口和函数上使用泛型"><a href="#2-在类、接口和函数上使用泛型" class="headerlink" title="2.  在类、接口和函数上使用泛型"></a>2.  在类、接口和函数上使用泛型</h2><p>泛型类、泛型接口和泛型方法具备可重用性、类型安全和高效等优点。在集合类API中大量地使用了泛型。在Java中我们可以为类、接口和方法分别定义泛型参数，在Kotlin中也同样支持。</p>
<h3 id="2-1-泛型接口"><a href="#2-1-泛型接口" class="headerlink" title="2.1  泛型接口"></a>2.1  泛型接口</h3><p>下面先举一个简单的Kotlin泛型接口的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="type">T</span>&gt;</span>&#123;   <span class="comment">//类型参数放在接口名称后面:&lt;T&gt;</span></span><br><span class="line">   <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>:T  <span class="comment">//接口函数中直接使用类型T</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testGenerator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> gen=<span class="keyword">object</span> : Generator&lt;<span class="built_in">Int</span>&gt;&#123;  <span class="comment">//对象表达式</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Random().nextInt(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(gen.next())   <span class="comment">//打印结果：(1-10)之间的一个Int类型的数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">      textGenerator()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-泛型类"><a href="#2-2-泛型类" class="headerlink" title="2.2 泛型类"></a>2.2 泛型类</h3><p>声明一个带类型参数的Container类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span>&lt;<span class="type">K,V</span>&gt;</span>(<span class="keyword">var</span> key:K,<span class="keyword">var</span> value:V)&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Container(Key=<span class="variable">$key</span>,value=<span class="variable">$value</span>)"</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testContainer</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> container=Container&lt;<span class="built_in">Int</span>,String&gt;(<span class="number">3</span>,<span class="string">"Kotlin"</span>)<span class="comment">//&lt;K,V&gt;被具体化为&lt;Int,String&gt;</span></span><br><span class="line">   println(container)  <span class="comment">//打印结果：Container(Key=3,value=Kotlin)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-泛型函数"><a href="#2-3-泛型函数" class="headerlink" title="2.3 泛型函数"></a>2.3 泛型函数</h3><p>在泛型接口和泛型类中，我们都在类名和接口名后面声明了泛型参数。而实际上也可以直接在类或接口中的函数声明泛型参数或者在包级中直接声明泛型参数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span></span>&#123;   <span class="comment">//类中的泛型函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">console</span><span class="params">(t:<span class="type">T</span>)</span></span>&#123;</span><br><span class="line">       println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span></span>&#123; <span class="comment">//接口中的泛型函数</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">console</span><span class="params">(t:<span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span><span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">gt</span><span class="params">(x:<span class="type">T</span>,y:<span class="type">T</span>)</span></span>:<span class="built_in">Boolean</span>&#123; <span class="comment">//包中的泛型函数</span></span><br><span class="line">     <span class="keyword">return</span> x&gt;y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-类型上界"><a href="#3-类型上界" class="headerlink" title="3.  类型上界"></a>3.  类型上界</h2><p>gt(x:T,y:T)函数的签名中有个T:Comparable<T>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T:Comparable&lt;T&gt;</span>&gt; <span class="title">gt</span><span class="params">(x:<span class="type">T</span>,y:<span class="type">T</span>)</span></span>:<span class="built_in">Boolean</span></span><br><span class="line"><span class="comment">//T的类型上界是Comparable&lt;T&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的T:Comparable,，表示Comparable是类型T的上界。也就是告诉编译器，类型参数T代表的都是实现了Comparable接口的类，这样等于告诉编译器它们都实现了CompareTo方法。如果没有在这个类型上界进行声明，就无法直接使用CompareTo  “&gt;” 操作符。 也就是说，下面的代码编译不通过</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> <span class="title">gt</span><span class="params">(x:<span class="type">T</span>,y:<span class="type">T</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x&gt;y  <span class="comment">//编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-协变和逆变"><a href="#4-协变和逆变" class="headerlink" title="4. 协变和逆变"></a>4. 协变和逆变</h2><p>首先有下面存在父子关系的类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 类的继承关系</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span></span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>:<span class="type">Food</span></span>()  <span class="comment">//Fruit继承Food</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:<span class="type">Fruit</span></span>()      <span class="comment">//Apple继承Fruit</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span>:<span class="type">Fruit</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grape</span>:<span class="type">Fruit</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.有如下两个函数</span></span><br><span class="line"><span class="keyword">object</span> GenericTypeDemo&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addFruit</span><span class="params">(fruit:<span class="type">MutableList</span>&lt;<span class="type">Fruit</span>&gt;)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFruit</span><span class="params">(fruit:<span class="type">MutableList</span>&lt;<span class="type">Fruit</span>&gt;)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用上面两个函数</span></span><br><span class="line"><span class="keyword">val</span> fruits: MutableList&lt;Fruit&gt;=mutableListOf(Fruit(),Fruit(),Fruit())</span><br><span class="line">GenericTypeDemo.addFruit(fruits)</span><br><span class="line">GenericTypeDemo.getFruit(fruits)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.现在又有一个存放Apple的List：</span></span><br><span class="line"><span class="keyword">val</span> apples:MutableList&lt;Fruit&gt;=mutableListOf(Apple(),Apple(),Apple())</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5.由于Kotlin中的泛型与Java一样是非协变的，因此下面调用是编译不通过的*/</span></span><br><span class="line">GenericTypeDemo.addFruit(apples)  <span class="comment">//type mismatch</span></span><br><span class="line">GenericTypeDemo.getFruit(apples)  <span class="comment">//type mismatch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.如果没有协变，那么我们不得不再添加两个函数：</span></span><br><span class="line"><span class="keyword">object</span> GenericTypeDemo&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addFruit</span><span class="params">(fruit:<span class="type">MutableList</span>&lt;<span class="type">Fruit</span>&gt;)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFruit</span><span class="params">(fruit:<span class="type">MutableList</span>&lt;<span class="type">Fruit</span>&gt;)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addFruit</span><span class="params">(fruit:<span class="type">MutableList</span>&lt;<span class="type">Fruit</span>&gt;)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFruit</span><span class="params">(fruit:<span class="type">MutableList</span>&lt;<span class="type">Fruit</span>&gt;)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一眼就能看出，这是重复的样板代码。那么能不能让MutableList成为MutableList的父类型呢？Java泛型中引入了类型通配符的概念来解决这个问题。</p>
<hr>
<h3 id="4-1-Java泛型的通配符有两种形式："><a href="#4-1-Java泛型的通配符有两种形式：" class="headerlink" title="4.1 Java泛型的通配符有两种形式："></a>4.1 Java泛型的通配符有两种形式：</h3><ul>
<li>子类型上界限定符?extendsT指定类型参数的上限(该类型必须是类型T或者是它的子类型)。也就是说MutableList&lt;?extends Fruit&gt;是MutableList的父类型。Kotlin中使用MutableList来表示。</li>
</ul>
<ul>
<li><p>超类型下界限定符?superT指定类型参数的下限(该类型必须是类型T或者它的父类型)。 也就是说MutableList&lt;? super Fruit&gt;是MutableList的父类型。Kotlin中使用MutableList来表示。</p>
<p>*这里的问号”?”，称之为类型通配符(Type Wildcard)。通配符在类型系统中具有重要的意义，它们为一个泛型类所指定的类型集合提供一个有用的类型范围。</p>
</li>
</ul>
<hr>
<h3 id="4-2-C-gt-F-C继承F"><a href="#4-2-C-gt-F-C继承F" class="headerlink" title="4.2 C=&gt;F(C继承F)"></a>4.2 C=&gt;F(C继承F)</h3><p>Number类型(简记为F) 是Integer类型(简记为C)的父类型，我们把这种父子类型关系简记为C=&gt;F(C继承F)；而List代表的泛型类型信息分别简记为f(F)，f(C)。</p>
<hr>
<h3 id="4-3-协变和逆变的描述："><a href="#4-3-协变和逆变的描述：" class="headerlink" title="4.3  协变和逆变的描述："></a>4.3  协变和逆变的描述：</h3><ul>
<li>当C=&gt;F时，如果有f(C)=&gt;f(F)，那么f叫做协变；</li>
<li>当C=&gt;F时，如果有f(F)=&gt;f(C)，那么f叫做逆变，如果上面两种关系都不成立则叫做不变。</li>
</ul>
<p>协变与逆变可以用下图来说明。</p>
<img src="https://s1.ax1x.com/2020/05/02/JxpoC9.jpg" style="zoom:50%;" />

<hr>
<h4 id="4-3-1-协变"><a href="#4-3-1-协变" class="headerlink" title="4.3.1  协变"></a>4.3.1  协变</h4><p>Java中的数组是协变的，下面的代码是可以正确编译运行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] ints =<span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">ints[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">ints[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">ints[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">Number[] numbers=<span class="keyword">new</span> Number[<span class="number">3</span>];</span><br><span class="line">numbers=ints;    <span class="comment">//数组是协变的，可以正确赋值</span></span><br><span class="line"><span class="keyword">for</span>(Number n: numbers)&#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中，因为Integer是Number的子类型，数组类型Integer[] 也是Number[]的子类型，因此在任何需要Number[]值得地方都可以提供一个Integer[]值。Java中数组协变的意思可以用下图来说明。</p>
<img src="C:\Users\PXN\AppData\Roaming\Typora\typora-user-images\image-20200502201703005.png" style="zoom:50%;" />



<p>Java中的泛型是非协变的。也就是说，List<Integer>不是List<Number>的子类型，在要求List<Number>的位置提供List<Integer>会提示类型错误。下面代码，编译器是会直接报错的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">integerList.add(<span class="number">0</span>);</span><br><span class="line">integerList.add(<span class="number">1</span>);</span><br><span class="line">integerList.add(<span class="number">2</span>);</span><br><span class="line">List&lt;Number&gt; numberList= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">numberList=integerLsit; <span class="comment">//编译错误；类型不兼容</span></span><br></pre></td></tr></table></figure>

<p>Java中的泛型是非协变的：</p>
<img src="https://s1.ax1x.com/2020/05/02/JxiciF.jpg" style="zoom:50%;" />



<p>Java中泛型和数组的不同行为的确引起了许多混乱，就算我们使用通配符这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list=<span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">1</span>)); <span class="comment">//errror 报类型不兼容的错误信息</span></span><br></pre></td></tr></table></figure>

<p>那为什么Number的对象可以由Integer实例化，而ArrayList<Number>的对象却不能由ArrayList<Integer>实例化？list中的&lt;? extends Number&gt;声明其元素是Number或Number的派生类，为什么补鞥呢add Integer?为了弄清楚这些问题，我们需要了解Java中的逆变和协变及泛型中通配符的用法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>这里的子类型C就是Number类及其子类(如Number、Integer、Float等)，表示是Number类或其子类。父类F就是上界通配符？extends Number。</p>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list1= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;? extends Number&gt; list2= <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br></pre></td></tr></table></figure>

<p>但是这里不能向list、list2添加除null以外的任意对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list1.add(<span class="keyword">null</span>);          <span class="comment">//ok</span></span><br><span class="line">list2.add(<span class="keyword">null</span>);          <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">list1.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));  <span class="comment">//error</span></span><br><span class="line">list2.add(<span class="keyword">new</span> Float(<span class="number">1.1f</span>)); <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>List<Integer>可以添加Integer及其子类；List<Float>可以添加Float及其子类；List<Integer>、List<Float>等都是List&lt;? extends Number&gt;的子类型。</p>
<p>现在问题来了，如果能将Float的子类添加到List&lt;? extends Number&gt;中，也能将Integer的子类添加到List&lt;? extends Number&gt;中，那么List&lt;? extends Number&gt;里面将会持有各种Number子类型的对象(如Byte、Integer、Float、Double等)。而这个时候，当我们再使用这个List的时候，元素的类型就会混乱，我们不知道哪个元素是Integer或者Float。Java为了保护其类型一致，禁止向List&lt;? extends Number&gt;添加任意Number子类型的对象，不过可以添加空对象null。</p>
<hr>
<h4 id="4-3-2-逆变"><a href="#4-3-2-逆变" class="headerlink" title="4.3.2  逆变"></a>4.3.2  逆变</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list= <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>

<p>这里的子类型C是 “? super Number”，父类型F是Number的父类型(如 Object类)。</p>
<img src="https://s1.ax1x.com/2020/05/02/JxmaDJ.jpg" style="zoom:50%;" />

<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();   <span class="comment">//Java中的&lt;? super Number&gt;通配符</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; lsit4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">list3.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));     <span class="comment">//可以添加Integer类型的元素</span></span><br><span class="line">list4.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>在逆变类型中，我们可以向其中添加元素。例如，可以向List&lt;? super Number&gt; list4 变量中添加Number及其子类对象。</p>
<hr>
<h4 id="4-3-3-PECS"><a href="#4-3-3-PECS" class="headerlink" title="4.3.3   PECS"></a>4.3.3   PECS</h4><p>我们什么时候用extends，什么时候用super呢？</p>
<p>Effective Java给出了答案：</p>
<p>PECS (Producer- Extends,Consumer-super)</p>
<p>Naftalin 与 Wadler 将PECS称为 Get and Put Principle。</p>
<p>在 java.util.Collections的copy()方法中(JDK1.7)完美地诠释了PECS，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> srcSize =src.size();</span><br><span class="line">       <span class="keyword">if</span>(srcSize&gt;dest.size())</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source does not fit in dest"</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(srcSize&lt;copy_THRESHOLD ||</span><br><span class="line">          (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dext <span class="keyword">instanceof</span> RandomAccess))&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;srcSize;i++)</span><br><span class="line">               dest.set(i,src.get(i));</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             ListIterator&lt;? <span class="keyword">super</span> T&gt; di=dest.listIterator(); <span class="comment">//in T,写入dest数据</span></span><br><span class="line">             ListIterator&lt;? extends T&gt; si=src.listIterator(); <span class="comment">//out T, 读取src数据</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize;i++)&#123;</span><br><span class="line">                   di.next();</span><br><span class="line">                   di.set(si.next());</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-outT-与inT"><a href="#5-outT-与inT" class="headerlink" title="5. outT 与inT"></a>5. outT 与inT</h2><p>正如前面所讲的，在Java泛型里有通配符这个东西，我们要用？extends T指定类型参数的上界，用？super T指定类型参数的下界。</p>
<p>而Kotlin 抛弃了这个通配符，直接实现了前面所讲的PECS规则。Kotlin中引入了投射类型outT代表生产者对象，使用投射类型in T代表消费者对象，使用投射类型(projected type)out T 和 in T来实现与类型通配符同样的功能。</p>
<p>下面通过代码示例简单讲解一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest,List&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ListIterator&lt;? <span class="keyword">super</span> T&gt; di =dest.listIterator();    <span class="comment">//in T，写入dest数据</span></span><br><span class="line">    ListIterator&lt;? extends T&gt; si = src.listIterator();  <span class="comment">//out T,读取src数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>List&lt;? super T&gt;dest是消费数据的对象，数据会被写入dest对象中，这些数据对象被”消费者吞进肚子里”了(Kotlin 中 叫 in T)。</p>
<p>List&lt;? extends T&gt;src是生产提供数据的对象。src会 “产出” 数据(Kotlin 中叫 out T).</p>
<p>在Kotlin中，我们把只能保证数据时类型安全的对象叫做生产者，用out T标记；把只能保证写入数据时类型安全的对象叫做消费者，用 in T标记。</p>
<p>可以这么记：</p>
<p>out T 等价于？extends T</p>
<p>in T 等价于？super T</p>
<hr>
<h2 id="6-类型擦除"><a href="#6-类型擦除" class="headerlink" title="6. 类型擦除"></a>6. 类型擦除</h2><p>Java和Kotlin的泛型实现，都是采用了运行时类型擦除的方式。也就是说，在运行时，这些类型参数的信息将会被擦除。</p>
<p>泛型是在编译器层次上实现的，生成的class字节码文件中是不包含泛型中的类型信息的。例如，在代码中定义的List<Object>和List<String>等类型，在编译之后都会变成List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。</p>
<p>关于泛型的很多奇怪特性都与这个类型擦除的存在有关，如泛型类并没有自己独有的Class类对象。比如Java中并不存在List<String>.class或是List<Integer>.class，而只有List.class。对应地在Kotlin中并不存在MutableList<Fruit>::class，而只有MutableList::class 。</p>
<p>类型擦除的基本过程也比较简单：</p>
<ul>
<li>首先，找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。</li>
<li>其次，把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉&lt;&gt;的内容。例如，Tget()就变成了Objectget()，List<String>就变成了List。</li>
<li>最后，根据需要生成一些桥接方法。这是由于擦除了类型之后的可能缺少某些必须的方法。这个时候就由编译器来动态生成这些方法。</li>
</ul>
<p>当了解了类型擦除机制之后，我们就会明白是编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，也正是为了确保类型的安全性。</p>
]]></content>
      <categories>
        <category>kotlin学习</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin函数与函数式编程</title>
    <url>/2020/04/23/Kotlin%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Kotlin函数与函数式编程"><a href="#Kotlin函数与函数式编程" class="headerlink" title="Kotlin函数与函数式编程"></a>Kotlin函数与函数式编程</h1><a id="more"></a>

<h2 id="1-函数式编程与命令式编程"><a href="#1-函数式编程与命令式编程" class="headerlink" title="1. 函数式编程与命令式编程"></a>1. 函数式编程与命令式编程</h2><p>函数式编程与命令式编程最大的不同是：函数式编程的焦点在于数据的映射，命令式编程(imperative programming)的焦点是解决问题的步骤。</p>
<p>函数式编程的本质是函数的组合。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    println(list.filter&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;)   <span class="comment">//过滤函数，参数是一个Lambda表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-函数式编程的特点："><a href="#1-1-函数式编程的特点：" class="headerlink" title="1.1 函数式编程的特点："></a>1.1 函数式编程的特点：</h3><p>函数式编程简单、自然、直观易懂且美丽、“优雅”的编程风格。函数式编程语言中通常都会提供常用的map、reduce、filter等基本函数，这些函数是对List、Map集合等基本数据结构的常用操作的高层次封装，就像一个更加智能、好用的工具箱。</p>
<hr>
<h2 id="2-函数式编程简介"><a href="#2-函数式编程简介" class="headerlink" title="2. 函数式编程简介"></a>2. 函数式编程简介</h2><p>函数式编程是关于不变性和函数组合的编程范式。函数式编程有如下特征：</p>
<ul>
<li>一等函数支持(first-class function)：函数也是一种数据类型，可以作为参数传入另一个函数中，同时函数也可以返回一个函数。</li>
<li>纯函数(pure function)和不变性(immutable)：纯函数值指的是没有副作用的函数(函数不去改变外部的数据状态)。例如，一个编译器就是一个广义上的纯函数。在函数式编程中。正因为纯函数不会去修改数据，同时又使用不可变的数据，所以程序不会去修改一个已经存在的数据结构，而是根据一定的映射逻辑创建一份新的数据。函数式编程是转换数据而非修改原始数据。</li>
<li>函数的组合(compose function)：在面向对象编程中是通过对象之间发送消息来构建程序逻辑的；</li>
</ul>
<p>而在函数式编程中是通过不同函数的组合来构建程序逻辑的。</p>
<hr>
<h2 id="3-声明函数"><a href="#3-声明函数" class="headerlink" title="3. 声明函数"></a>3. 声明函数</h2><p>Kotlin中使用fun关键字声明函数为了更加直观地表现函数也可以当做变量来使用、声明一个函数类型的变量sum</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>&#123;<span class="keyword">return</span> x+y&#125;  <span class="comment">//sum的类型是一个函数类型的变量</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> sum=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    &#125;</span><br><span class="line">    println(sum)   <span class="comment">//打印 (kotlin.Int, kotlin.Int) -&gt; kotlin.Int，表面sum是一个函数类型变量</span></span><br><span class="line">    <span class="comment">//这个带箭头 “-&gt;”的表达式就是一个函数类型表示一个输入两个Int类型值、输出一个Int类型值的函数</span></span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"x+y="</span>+sum(<span class="number">1</span>,<span class="number">3</span>))    <span class="comment">//打印  x+y=4</span></span><br><span class="line">    <span class="keyword">val</span> temp=sum(<span class="number">1</span>,<span class="number">5</span>)     <span class="comment">//调用sum函数，将返回值赋值给temp变量</span></span><br><span class="line">    println(temp)    <span class="comment">//打印结果   6</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Lambda表达式"><a href="#4-Lambda表达式" class="headerlink" title="4. Lambda表达式"></a>4. Lambda表达式</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">list.filter&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这里的filter()函数的入参{it%2==1}就是一段Lambda表达式。因为filter()函数只有一个参数，所以括号被省略了。因此，filter()函数调用的完整写法是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.filter(&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>filter()函数的入参是一个函数 predicate:(T)-&gt;Boolean</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;it%<span class="number">2</span>==<span class="number">1</span>&#125;   <span class="comment">//简写的Lambda表达式</span></span><br></pre></td></tr></table></figure>

<p>是一种简写的语法，完整的Lambda表达式是这样写的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#123;it-&gt;it%<span class="number">2</span>==<span class="number">1</span>&#125;    <span class="comment">//实际的Lambda表达式</span></span><br></pre></td></tr></table></figure>

<p>如果拆开来写，就更加容易理解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line"> <span class="keyword">val</span> isOdd=&#123;it:<span class="built_in">Int</span>-&gt;it%<span class="number">2</span>==<span class="number">1</span>&#125;  <span class="comment">//直接使用Lambda表达式声明一个函数，这个函数判断输入的Int是不是奇数</span></span><br><span class="line">    println(isOdd)            <span class="comment">//打印结果： (kotlin.Int) -&gt; kotlin.Boolean</span></span><br><span class="line">    <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    println(list.filter(isOdd))  <span class="comment">//直接传入isOdd函数 打印结果： [1, 3, 5, 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-高阶函数"><a href="#5-高阶函数" class="headerlink" title="5. 高阶函数"></a>5. 高阶函数</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> strList=listOf(<span class="string">"a"</span>,<span class="string">"ab"</span>,<span class="string">"abc"</span>,<span class="string">"abcd"</span>,<span class="string">"abcde"</span>,<span class="string">"abcdef"</span>,<span class="string">"abcdefg"</span>)</span><br><span class="line"><span class="keyword">val</span> f=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>)</span></span>=x%<span class="number">2</span>==<span class="number">1</span>        <span class="comment">//判断输入的Int是否奇数</span></span><br><span class="line"><span class="keyword">val</span> g=<span class="function"><span class="title">fun</span><span class="params">(s:<span class="type">String</span>)</span></span>=s.length   <span class="comment">//返回输入的字符串参数的长度</span></span><br><span class="line"><span class="keyword">val</span> h=<span class="function"><span class="title">fun</span><span class="params">(g:(<span class="type">String</span>)-&gt;<span class="type">Int</span>,f:(<span class="type">Int</span>)-&gt;<span class="type">Boolean</span>:(<span class="type">String</span>)-&gt;<span class="type">Boolean</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;f(g(it))&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个h函数的声明有些长了，尤其是3个函数类型声明的箭头表达式，显得不够简洁。不过不用担心，Kotlin中有简单好用的Kotlin类型别名，我们使用G、F、H来声明3个函数类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> G=(String)-&gt;<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">typealias</span> F=(<span class="built_in">Int</span>)-&gt;<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">typealias</span> H=(String)-&gt;<span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> h=<span class="function"><span class="title">fun</span><span class="params">(g:<span class="type">G</span>,f:<span class="type">F</span>)</span></span>:H&#123;</span><br><span class="line">   <span class="keyword">return</span>&#123; f(g(it))&#125;   <span class="comment">//需要注意的是，这里的&#123;&#125;是不能省略的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个h函数的映射关系可用下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JBVycQ.jpg" alt="img"></p>
<p>在函数体的代码 return{f(g(it))} 中，{}代表这是一个Lambda表达式。返回的是一个(String)-&gt;Boolean函数类型。如果没有{},那么返回值就是一个布尔类型Boolean了。</p>
<p>综合该例子为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> f=<span class="function"><span class="title">fun</span><span class="params">(x:<span class="type">Int</span>)</span></span>=x%<span class="number">2</span>==<span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> g=<span class="function"><span class="title">fun</span><span class="params">(s:<span class="type">String</span>)</span></span>=s.length</span><br><span class="line"><span class="keyword">typealias</span> G=(String)-&gt;<span class="built_in">Int</span>      <span class="comment">//typealias--Kotlin类型别名的关键字，声明时应放在main函数之外</span></span><br><span class="line"><span class="keyword">typealias</span> F=(<span class="built_in">Int</span>)-&gt;<span class="built_in">Boolean</span></span><br><span class="line"><span class="keyword">typealias</span> H=(String)-&gt;<span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> h=<span class="function"><span class="title">fun</span><span class="params">(g:<span class="type">G</span>,f:<span class="type">F</span>)</span></span>:H&#123;      <span class="comment">//高阶函数</span></span><br><span class="line">    <span class="keyword">return</span>&#123;f(g(it))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=listOf(<span class="string">"a"</span>,<span class="string">"ab"</span>,<span class="string">"abc"</span>,<span class="string">"abcd"</span>,<span class="string">"abcde"</span>,<span class="string">"abcdef"</span>,<span class="string">"abcdefg"</span>)</span><br><span class="line">   println(list.filter(h(g,f)))     <span class="comment">//打印结果为：[a, abc, abcde, abcdefg]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-Kotlin中的特殊函数"><a href="#6-Kotlin中的特殊函数" class="headerlink" title="6. Kotlin中的特殊函数"></a>6. Kotlin中的特殊函数</h2><p>我们介绍Kotlin中的run()、apply()、let()、also()和with()这5个特殊的函数。</p>
<h3 id="6-1-run-函数"><a href="#6-1-run-函数" class="headerlink" title="6.1 run()函数"></a>6.1 run()函数</h3><p>run()函数的定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block:()-&gt;<span class="type">R</span>)</span></span>:R&#123;</span><br><span class="line">     contract&#123;</span><br><span class="line">        callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行代码block()，其实就是调用传入的block参数，一般情况下是一个Lambda代码块。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myfun</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">   println(<span class="string">"执行了myfun函数"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"这是myfun的返回值"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testRunFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  myfun()           <span class="comment">//直接在代码行调用函数</span></span><br><span class="line">  run(&#123;myfun()&#125;)    <span class="comment">//使用run()函数调用myfun()函数</span></span><br><span class="line">  run&#123;myfun()&#125;      <span class="comment">//run()函数的括号“()”可以省略，因为只有一个参数</span></span><br><span class="line">  run&#123;println(<span class="string">"A"</span>)&#125; <span class="comment">//等价于println("A")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">执行了myfun函数</span></span><br><span class="line"><span class="comment">执行了myfun函数</span></span><br><span class="line"><span class="comment">执行了myfun函数</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-2-apply-函数"><a href="#6-2-apply-函数" class="headerlink" title="6.2  apply()函数"></a>6.2  apply()函数</h3><p>apply()函数的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span>T.<span class="title">apply</span><span class="params">(block:<span class="type">T</span>.()-&gt;<span class="type">Unit</span>():<span class="type">T</span>)</span></span>&#123;</span><br><span class="line">    contract&#123;</span><br><span class="line">      callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后两行代码，先是调用了block()函数，然后返回当前的调用者对象this。意思是执行完block()代码块逻辑后，再次返回当前的调用者对象。测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testApply</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=mutableListOf&lt;String&gt;()</span><br><span class="line">   list.add(<span class="string">"A"</span>)</span><br><span class="line">   list.add(<span class="string">"B"</span>)</span><br><span class="line">   list.add(<span class="string">"C"</span>)</span><br><span class="line">   println(<span class="string">"普通写法list=<span class="variable">$list</span>"</span>)   <span class="comment">//普通写法    打印结果普通写法list=[A,B,C]</span></span><br><span class="line">   println(list)                  <span class="comment">//打印 [A,B,C]</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用apply()函数的写法</span></span><br><span class="line">   <span class="keyword">val</span> a =ArrayList&lt;String&gt;().apply()&#123;    <span class="comment">//这里的调用者是AR让List数组</span></span><br><span class="line">        add(<span class="string">"A"</span>)</span><br><span class="line">        add(<span class="string">"B"</span>)</span><br><span class="line">        add(<span class="string">"C"</span>)</span><br><span class="line">       println(<span class="string">"使用apply函数写法this=<span class="variable">$this</span>"</span>)  <span class="comment">//使用apply函数写法this=[A,B,C]</span></span><br><span class="line">   &#125;</span><br><span class="line">    println(a)    <span class="comment">//打印[A,B,C]</span></span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    a.let&#123;println(it)&#125;  <span class="comment">//打印[A,B,C]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testApply()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-let-函数"><a href="#6-3-let-函数" class="headerlink" title="6.3  let()函数"></a>6.3  let()函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T,R&gt;</span>T.<span class="title">let</span><span class="params">(block:(<span class="type">T</span>)-&gt;<span class="type">R</span>)</span></span>:R&#123;</span><br><span class="line">   contract&#123;</span><br><span class="line">       callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是重点看最后一行代码block(this)，意思是把当前调用对象作为参数传入block()代码块中。测试代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">myfun</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">   println(<span class="string">"执行了myfun函数"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"这是myfun的返回值"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testLetFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="number">1</span>.let&#123;println(it)&#125;    <span class="comment">//输出1，其中it就是调用者1</span></span><br><span class="line">   <span class="string">"ABC"</span>.let&#123;println(it)&#125;  <span class="comment">//输出ABC，其中it就是调用者ABC</span></span><br><span class="line">   <span class="comment">//执行完函数myfun()，返回值传给let()函数</span></span><br><span class="line">   myfun().let&#123;          <span class="comment">//执行了myfun函数</span></span><br><span class="line">      println(it)        <span class="comment">//it是myfun()函数--这是myfun的返回值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   testLetFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-also-函数"><a href="#6-4-also-函数" class="headerlink" title="6.4  also()函数"></a>6.4  also()函数</h3><p>also()函数的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span>T.<span class="title">also</span><span class="params">(block:(<span class="type">T</span>)-&gt;<span class="type">Unit</span>)</span></span>:T&#123;</span><br><span class="line">   contract&#123;</span><br><span class="line">      callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">   &#125;</span><br><span class="line">   block(<span class="keyword">this</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还是看最后两句，首先是调用了block(this)，类似let()函数的逻辑，但是最后返回的值是this，也就是当前的调用者。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testAlsoFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> a=<span class="string">"ABC"</span>.also&#123;</span><br><span class="line">       println(it)  <span class="comment">//输出：ABC</span></span><br><span class="line">   &#125;</span><br><span class="line">   println(a)   <span class="comment">//输出：ABC</span></span><br><span class="line">   a.let&#123;</span><br><span class="line">      println(it)  <span class="comment">//输出：ABC</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   testAlsoFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>6.5  with()函数</p>
<p>with()函数的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T,R&gt;</span><span class="title">with</span><span class="params">(receiver:<span class="type">T</span>,block:<span class="type">T</span>.()-&gt;<span class="type">R</span>)</span></span>:R&#123;</span><br><span class="line">    contract&#123;</span><br><span class="line">        callsInPlace(block,InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with()函数传入了一个接受者对象receiver，然后使用该对象receiver去调用传入的Lambda代码块receiver.block()，测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWithFun</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=mutableListOf&lt;String&gt;()</span><br><span class="line">   list.add(<span class="string">"A"</span>)</span><br><span class="line">   list.add(<span class="string">"B"</span>)</span><br><span class="line">   list.add(<span class="string">"C"</span>)</span><br><span class="line">   println(<span class="string">"常规写法list=<span class="variable">$list</span>"</span>)     <span class="comment">//常规写法list=[A,B,C]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用with()函数写法</span></span><br><span class="line">    with(ArrayList&lt;String&gt;())&#123;</span><br><span class="line">        add(<span class="string">"A"</span>)</span><br><span class="line">        add(<span class="string">"B"</span>)</span><br><span class="line">        add(<span class="string">"C"</span>)</span><br><span class="line">        println(<span class="string">"使用with函数写法this=<span class="variable">$this</span>"</span>) <span class="comment">//使用with函数写法this=[A,B,C]</span></span><br><span class="line">    &#125;.let&#123;println(it)&#125;   <span class="comment">//Kotlin.Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testWithFun()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin类的学习</title>
    <url>/2020/04/22/Kotlin%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Kotlin类的学习"><a href="#Kotlin类的学习" class="headerlink" title="Kotlin类的学习"></a>Kotlin类的学习</h1><a id="more"></a>

<h2 id="1-oo编程的基本概念"><a href="#1-oo编程的基本概念" class="headerlink" title="1. oo编程的基本概念"></a>1. oo编程的基本概念</h2><p>类是对象的抽象化，而对象则是类的实例化。</p>
<img src="https://s1.ax1x.com/2020/04/22/JYTxYR.jpg" alt="img" style="zoom:50%;" />

<p>oo编程的基本概念</p>
<img src="https://s1.ax1x.com/2020/04/22/JYhWX4.jpg" alt="img" style="zoom:33%;" />



<hr>
<h2 id="2-声明类"><a href="#2-声明类" class="headerlink" title="2. 声明类"></a>2. 声明类</h2><h3 id="2-1-空类"><a href="#2-1-空类" class="headerlink" title="2.1 空类"></a>2.1 空类</h3><p>使用class关键字声明类。我们可以声明一个什么都不干的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnEmptyClass</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> anEmtyClass=AnEmptyClass()   <span class="comment">//kotlin中不需要使用new</span></span><br><span class="line">    println(anEmtyClass <span class="keyword">is</span> AnEmtyClass) <span class="comment">//结果打印为 truezai</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，我们可以在声明类的时候同时声明构造函数，语法格式是在类的后面使用括号包含构造函数的参数列表</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name:String, <span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> sex:String)&#123;</span><br><span class="line">        <span class="comment">//声明类和构造函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;    <span class="comment">//override关键字，用来重写toString()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person(name='<span class="variable">$name</span>',age=<span class="variable">$age</span>,sex='<span class="variable">$sex</span>')"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> person=Person(<span class="string">"kim"</span>,<span class="number">29</span>,<span class="string">"M"</span>)</span><br><span class="line">    println(<span class="string">"person=<span class="subst">$&#123;person&#125;</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*打印结果为：</span></span><br><span class="line"><span class="comment">    person=Person(name='jack',age=29,sex='M')</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-11-lateinit-关键字延迟属性初始化"><a href="#2-11-lateinit-关键字延迟属性初始化" class="headerlink" title="2.11 lateinit 关键字延迟属性初始化"></a>2.11 lateinit 关键字延迟属性初始化</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String  <span class="comment">//lateinit关键字表示该属性延迟初始化</span></span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">0</span>  <span class="comment">//lateinit关键字不能修饰primitive类型</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"Person(name=<span class="variable">$name</span>,age=<span class="variable">$age</span>,sex=<span class="variable">$sex</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果使用2.1中的例子Person类，用以下方式调用Person类</span></span><br><span class="line"><span class="comment">val person=Person()</span></span><br><span class="line"><span class="comment">person.name="jack"</span></span><br><span class="line"><span class="comment">person.age=29</span></span><br><span class="line"><span class="comment">person.sex="M"</span></span><br><span class="line"><span class="comment">println("person=$&#123;person&#125;")</span></span><br><span class="line"><span class="comment">则会报以下错误</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'name'</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'age'</span></span><br><span class="line"><span class="comment">Error:(112, 23) Kotlin: No value passed for parameter 'sex'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-constructor关键字声明具有多种构造方式的类"><a href="#3-constructor关键字声明具有多种构造方式的类" class="headerlink" title="3. constructor关键字声明具有多种构造方式的类"></a>3. constructor关键字声明具有多种构造方式的类</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>()&#123;         <span class="comment">//</span></span><br><span class="line">   <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String):<span class="keyword">this</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,sex:String):<span class="keyword">this</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">        <span class="keyword">this</span>.age=age</span><br><span class="line">        <span class="keyword">this</span>.sex=sex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person(name='<span class="variable">$name</span>',age=<span class="variable">$age</span>,sex='<span class="variable">$sex</span>')"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有一些样板代码，其实在IDEA中，上面的代码只需要下面3行代码即可替换，剩下的就交给IDEA自动生成了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>&#123;</span><br><span class="line">   <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String </span><br><span class="line">    <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> sex:String</span><br><span class="line">   <span class="comment">//剩下的在IDEA中自动生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IDEA中自动的步骤</p>
<ol>
<li><p>在当前类中右击，在弹出的快捷菜单中选择Generate命令</p>
</li>
<li><p>之后，弹出生成次级构造函数对话框，在其中选择Secondary Constructor命令，</p>
</li>
<li><p>选择构造函数的参数。选中相应的属性，单击OK按钮即可生成构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如上面的例子</span></span><br><span class="line"><span class="keyword">constructor</span>() <span class="comment">//一个属性都不选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String)&#123; <span class="comment">//选择一个name属性，生成带name参数的构造函数</span></span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">&#125;         </span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>):<span class="keyword">this</span>(name)&#123;<span class="comment">//选择name和age属性，生成带name，age参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(name:String,age:<span class="built_in">Int</span>,sex:String):<span class="keyword">this</span>(name,age)&#123;<span class="comment">//选择全部属性，生成带有全部参数的构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>当然用到最多的构造函数还是：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name:String,<span class="keyword">var</span> age:<span class="built_in">Int</span>, <span class="keyword">var</span> sex:String)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-抽象类与接口"><a href="#4-抽象类与接口" class="headerlink" title="4. 抽象类与接口"></a>4. 抽象类与接口</h2><p>抽象类表示”is-a“的关系，而接口所代表的是”has-a”的关系。</p>
<p>抽象类用来表征问题领域的抽象概念。</p>
<p>所有编程语言都提供抽象机制。机器语言是对机器的模仿抽象。汇编语言是对机器语言的高层次抽象，高级语言是对汇编语言的高层次抽象。而面向对象编程语言是对过程函数的高层次封装。如下图 </p>
<p><img src="https://s1.ax1x.com/2020/04/22/JN7Y9A.jpg" alt="img"></p>
<p>抽象类和接口是Kotlin语言中两种不同的抽象概念，它们的存在对多态提供了非常好的支持。这个机制与java相同</p>
<hr>
<h3 id="4-1-抽象类与抽象成员"><a href="#4-1-抽象类与抽象成员" class="headerlink" title="4.1 抽象类与抽象成员"></a>4.1 抽象类与抽象成员</h3><p>以抽象类Shape为例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span>    //声明抽象父类<span class="title">Shape</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>: <span class="type">Shape</span></span>()  <span class="comment">//继承类的语法是使用冒号":",父类需要在这里使用构造函数进行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="type">Shape</span></span>()   <span class="comment">//Circle继承Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>: <span class="type">Shape</span></span>()    <span class="comment">//Tirangle继承Shape类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> s=Shape()    <span class="comment">//编译不通过，不能实例化抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> r=Rectangle()</span><br><span class="line">println(r <span class="keyword">is</span> Shape())   <span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<p>一个类的成员包括属性和函数。抽象类的成员也必须是抽象的，需要使用abstract关键字修饰。下面声明一个带有成员的Shape抽象类.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> width:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> height:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，继承抽象类Shape的方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">                <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>): Shape()&#123;  <span class="comment">//声明类的同时声明了构造函数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123; <span class="comment">//override是覆盖父类属性和函数的关键字</span></span><br><span class="line">        <span class="keyword">return</span> height*width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">             <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>):Shape()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span>*radius*radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> rectangle=Rectangle(<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> circle=Circle(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">2.0</span>)</span><br><span class="line">    println(<span class="string">"area=<span class="subst">$&#123;rectangle.area()&#125;</span>"</span>)  <span class="comment">//结果为： area=12.0</span></span><br><span class="line">    println(<span class="string">"area=<span class="subst">$&#123;circle.area()&#125;</span>"</span>)   <span class="comment">//结果为： area=12.56</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中可以有带实现的函数，例如在抽象类Shape中添加一个函数onClick():</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"I am a student"</span>) <span class="comment">//在抽象类中可以添加实现的函数，如onClick()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r=Rectangle(<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">0.0</span>)</span><br><span class="line">    r.onClick()     <span class="comment">//输出 I am a student</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类Shape中的onClick()函数默认是final的，不可以被覆盖重写。如果想要开放给子类重新实现这个函数，可以在前面加上open关键字：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>()&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;   <span class="comment">//在函数onClick加上open关键字</span></span><br><span class="line">         println(<span class="string">"I am a student"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类中覆盖重写onClick函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> width:<span class="built_in">Double</span>,<span class="keyword">override</span> <span class="keyword">var</span> height:<span class="built_in">Double</span>,</span><br><span class="line">               <span class="keyword">override</span> <span class="keyword">var</span> radius:<span class="built_in">Double</span>):Shape()&#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>:<span class="built_in">Double</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> height*width</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;    <span class="comment">//此处的Unit可以不用添加，当函数没有返回值时，默认为Unit相当于java中的void，这里添加当然就是为了再次复习一下。</span></span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;this::class.simpleName&#125;</span> is a teacher"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r=Rectangel()   <span class="comment">//Kotlin中，创建一个新对象时，不添加new</span></span><br><span class="line">    r.onClick()   <span class="comment">//打印结果为  Rectangle is a teacher</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 this::class.simpleName 是 Kotlin 中反射的API，在Gradle工程的 build.gradle 中需要添加依赖compile：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">compile<span class="string">"org.jetbrains.kotlin:kotlin-reflect:<span class="variable">$kotlin_version</span>"</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-类继承的规则"><a href="#4-2-类继承的规则" class="headerlink" title="4.2 类继承的规则"></a>4.2 类继承的规则</h3><p>当子类继承了某个类之后，便可以使用父类中的成员变量，但并不是完全继承父类的所有成员变量。</p>
<ul>
<li>能够继承父类的public 和 protected 成员变量</li>
<li>不能继承父类的private类型的成员变量</li>
<li>对于父类的包访问权限成员变量，如果子类和父类在同一个包下，则子类能够继承；否则，子类不能继承。</li>
<li>对于子类可以继承的父类成员变量，如果在子类中出现了同名称的成员变量，则会发生隐藏现象，即子类的成员变量会屏蔽掉父类的同名变量。如果要在子类中访问父类中的同名成员变量，需要使用super关键字进行引用。</li>
</ul>
<hr>
<h2 id="5-接口"><a href="#5-接口" class="headerlink" title="5. 接口"></a>5. 接口</h2><p>接口是一种比抽象类更加抽象的 ”类“。接口本身代表的是一种”类型“的概念。但在语法层面，接口本身不是类，不能实例化接口，只能实例化它的实现类。</p>
<p>接口是用来建立类与类之间的协议。实现接口的实现类必须要实现该接口的所有方法。在Java8和Kotlin中，接口可以实现一些通用的方法。</p>
<p>接口是抽象类的延伸。在Kotlin和Java中一个类，不支持同时继承多个父类，也就是说一个类只能存在一个父类(单继承).</p>
<p>但是接口不同，一个类可以同时实现多个接口(多组合),无论这些接口之间有没有关系。这样可以实现多重继承。</p>
<p>与Java类似，Kotlin 使用interface作为接口的关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">projectService</span>    //<span class="title">Java</span>中使用<span class="title">interface</span>声明接口</span></span><br></pre></td></tr></table></figure>

<p>接口和抽象类都可以包含抽象的方法和实现的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">projectService</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> name:String</span><br><span class="line">   <span class="keyword">val</span> owner:String</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">save</span><span class="params">(project:<span class="type">Project</span>)</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">" I am project"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口是没有构造函数的，使用冒号 ”:“ 语法来实现一个接口，如果有多个接口， 用 “,” 逗号隔开：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectServiceImpl</span> : <span class="type">ProjectService //与继承抽象类语法一样，使用冒号</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectMilestoneServiceImpl</span> : <span class="type">ProjectService</span>, <span class="type">MilestoneService  //实现多个接口使用逗号 "</span>,<span class="type">" 隔开</span></span></span><br></pre></td></tr></table></figure>

<p>假如说在 ProjectMilestoneServiceImpl 类中要重写print()方法时，该类继承的两个接口类  ProjectService，MilestoneService 中都有一个print()方法。当直接使用super.print() 函数时，编译器无法知道我们想要调用的是哪个print函数，我们把这种现象叫做覆盖冲突。</p>
<p>这个时候，我们可以使用下面的语法来调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>&lt;ProjectService&gt;.print()  <span class="comment">//使用super&lt;ProjectService&gt;指定调用的是ProjectService接口中的print()函数</span></span><br><span class="line"><span class="keyword">super</span>&lt;MilestoneService&gt;.print() <span class="comment">//使用super&lt;MilestoneService&gt;指定调用的是MilestoneService接口中的print()函数</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-object对象"><a href="#6-object对象" class="headerlink" title="6. object对象"></a>6. object对象</h2><p>单例模式是一种常用的软件设计模式。例如，Spring中的Bean默认就是单例。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p>
<p>Kotlin中没有静态属性和方法，但是可以使用关键字object声明一个object单例对象：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> User&#123;   <span class="comment">//声明对象类型User</span></span><br><span class="line">    <span class="keyword">val</span> username:String = <span class="string">"admin"</span></span><br><span class="line">    <span class="keyword">val</span> password:String = <span class="string">"admin"</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"Hello, object!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    println(User.username)    <span class="comment">//与Java静态类的调用形式一样</span></span><br><span class="line">    println(User.password)    </span><br><span class="line">    User.hello()              <span class="comment">//与Java静态方法的调用方式一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-Kotlin中还提供了伴生对象，用companion-object关键字声明："><a href="#7-Kotlin中还提供了伴生对象，用companion-object关键字声明：" class="headerlink" title="7. Kotlin中还提供了伴生对象，用companion object关键字声明："></a>7. Kotlin中还提供了伴生对象，用companion object关键字声明：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> DataProcessor&#123; <span class="comment">//使用companion object声明DataProcessor的伴生对象</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> process&#123;</span></span><br><span class="line">            println(<span class="string">"I am processing data..."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    DataProcessor.process()   <span class="comment">//I am processing data...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类只能有一个伴生对象</p>
<hr>
<h2 id="8-数据类"><a href="#8-数据类" class="headerlink" title="8. 数据类"></a>8. 数据类</h2><p>数据类就只存储数据，不包含操作行为的类。Kotlin中的数据类可以为我们节省大量的样板代码(Java中强制我们要去写一堆getter、setter代码，而实际上这些方法都是“不言而明”的)，这样最终的代码更易于理解，便于维护。</p>
<h3 id="8-1-创建数据类"><a href="#8-1-创建数据类" class="headerlink" title="8.1 创建数据类"></a>8.1 创建数据类</h3><p>使用关键字为data class创建一个只包含数据的类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span></span>(<span class="keyword">val</span> username:String,<span class="keyword">val</span> password:String)</span><br></pre></td></tr></table></figure>

<p>在IDEA中提供了方便的Kotlin工具箱，我们可以把上面的代码反编译成等价的Java代码。</p>
<hr>
<h3 id="8-2-数据类自动创建的函数"><a href="#8-2-数据类自动创建的函数" class="headerlink" title="8.2 数据类自动创建的函数"></a>8.2 数据类自动创建的函数</h3><ul>
<li>equals()/hashCode()函数toString()格式为“LoginUser(username=”this.username+”,password=”+this.password+”)”;</li>
<li>component1()和component2()函数返回对应下标的属性值，按声明顺序排列;</li>
<li>copy()函数：根据旧对象属性重新newLoginUser(username,password)一个对象出来。</li>
</ul>
<p>如果这些函数在类中已经被明确定义了，或者从超类中继承而来，编译器就不再生成。</p>
<hr>
<h3 id="8-3-数据类的语法限制"><a href="#8-3-数据类的语法限制" class="headerlink" title="8.3 数据类的语法限制"></a>8.3 数据类的语法限制</h3><p>数据类有如下限制：</p>
<ul>
<li>主构造函数至少包含一个参数；</li>
<li>参数必须标识为val或者var；</li>
<li>不能为abstract、open、sealed或者inner；</li>
<li>不能继承其他类(但可以实现接口)</li>
</ul>
<p>另外，数据类可以在解构声明中使用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginUser</span></span>(<span class="keyword">val</span> username:String,<span class="keyword">val</span> password:String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> loginUser=LoginUser(<span class="string">"admin"</span>,<span class="string">"admin"</span>)</span><br><span class="line">    <span class="keyword">val</span>(username,password)=loginUser<span class="comment">//解构声明(username,password)</span></span><br><span class="line">    println(<span class="string">"username=<span class="subst">$&#123;username&#125;</span>,password=<span class="subst">$&#123;password&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">//username=admin,password=admin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-4-Pair和Triple"><a href="#8-4-Pair和Triple" class="headerlink" title="8.4 Pair和Triple"></a>8.4 Pair和Triple</h3><p>Kotlin标准库提供了Pair和Triple数据类，分别表示二元组和三元组对象。它们的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="type">out A,out B</span>&gt;</span>(</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> first:A,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> second:B):Serializable&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String=<span class="string">"&#123;<span class="variable">$first</span>,<span class="variable">$second</span>&#125;"</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;A,B&gt;</span>A.<span class="title">to</span><span class="params">(that:<span class="type">B</span>)</span></span>:Pair&lt;A,B&gt;=Pair(<span class="keyword">this</span>,that)<span class="comment">// 中缀函数to()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Triple</span>&lt;<span class="type">out A,out B, out C</span>&gt;</span>(</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> first:A,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> second:B,</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> third:C): Serializable&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String=<span class="string">"&#123;<span class="variable">$first</span>,<span class="variable">$second</span>,<span class="variable">$third</span>&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Pair和Triple这两个函数系统已经定义好了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"A"</span>,<span class="number">2</span> to <span class="string">"B"</span>,<span class="number">3</span> to <span class="string">"C"</span>)</span><br><span class="line">    println(map)   <span class="comment">//结果打印&#123;1=A, 2=B,3=C&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-枚举类-enum-class…"><a href="#9-枚举类-enum-class…" class="headerlink" title="9. 枚举类(enum class…)"></a>9. 枚举类(enum class…)</h2><p>Kotlin中使用enum class关键字来声明一个枚举类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span></span>&#123;   <span class="comment">//使用enum class声明一个Direction枚举类型</span></span><br><span class="line">  NORTH,SOUTH,WEST,EAST  <span class="comment">//每个枚举常量都是一个对象，用逗号隔开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于字符串常量，使用枚举能够实现类型安全。枚举类有两个内置的属性：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">val</span> name:String   <span class="comment">//枚举对象的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">val</span> ordinal:<span class="built_in">Int</span>   <span class="comment">//枚举对象的下标位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> north=Direction.NORTH</span><br><span class="line">    println(north.name)   <span class="comment">//打印NORTH</span></span><br><span class="line">    println(north.ordinal) <span class="comment">//打印下标为：0</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个枚举类都是枚举类的实例，它们可以被初始化：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> rgb:<span class="built_in">Int</span>)&#123; <span class="comment">//声明一个带构造函数 rgb:Int的枚举类，RED，GREEN，BLUE都是该枚举类的实例</span></span><br><span class="line">   RED(<span class="number">0xFF0000</span>),</span><br><span class="line">   GREEN(<span class="number">0x00FF00</span>),</span><br><span class="line">   BLUE(<span class="number">0x0000FF</span>)     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> c=Color.GREEN          <span class="comment">//访问Color枚举类型中的GREEN元素</span></span><br><span class="line">    println(c)                  <span class="comment">//打印结果：GREEN</span></span><br><span class="line">    println(c.rgb)             <span class="comment">//访问GREEN枚举的rgb参数值  打印结果：65280</span></span><br><span class="line">    println(c.ordinal)         <span class="comment">//GREEN枚举的ordinal属性 打印结果：1</span></span><br><span class="line">    println(c.name)            <span class="comment">//GREEN枚举的name属性   打印结果：GREEN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-内部类"><a href="#10-内部类" class="headerlink" title="10. 内部类"></a>10. 内部类</h2><p>Kotlin的内部类包括普通嵌套类、内部嵌套类和匿名内部类。</p>
<h3 id="10-1-普通嵌套类"><a href="#10-1-普通嵌套类" class="headerlink" title="10.1 普通嵌套类"></a>10.1 普通嵌套类</h3><p>Kotlin中，类可以嵌套。一个类可以嵌套在其他类中，而且可以嵌套多层。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> zeror:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> one:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getTwo</span><span class="params">()</span></span>=<span class="number">2</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nested1</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> three=<span class="number">3</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">getFour</span><span class="params">()</span></span>=<span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当调用某个类的成员时，该类用过的是对象即"类名()",否则其他的类则只是用类名调用</span></span><br><span class="line">    <span class="keyword">val</span> one=NestedClassDemo.Outer().one</span><br><span class="line">    <span class="keyword">val</span> two=NestedClassDemo.Nested().getTwo()</span><br><span class="line">    <span class="keyword">val</span> three=NestedClassDemo.Nested.Nested1().three</span><br><span class="line">    <span class="keyword">val</span> four=NestedClassDemo.Nested.Nested1().getFour()</span><br><span class="line">     println(<span class="string">"<span class="variable">$one</span>+<span class="variable">$two</span>+<span class="variable">$three</span>+<span class="variable">$four</span>"</span>)   <span class="comment">//打印结果为 1+2+3+4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*注：普通嵌套类没有持有外部类的引用，所以是无法访问外部类变量的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;   <span class="comment">//Nested类是Outer类的内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> zero:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> one:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getTow</span><span class="params">()</span></span>=<span class="number">2</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">accessOuter</span><span class="params">()</span></span>=&#123;</span><br><span class="line">            println(zero)    <span class="comment">//IDEA报错：Kotlin:Unresolved reference:zero</span></span><br><span class="line">            println(one)     <span class="comment">//IDEA报错：Kotlin:Unresolved reference:one</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-2-嵌套内部类"><a href="#10-2-嵌套内部类" class="headerlink" title="10.2  嵌套内部类"></a>10.2  嵌套内部类</h3><p>如果一个类 Inner想要访问外部类Outer中的成员，可以在这个类前面添加修饰符inner。内部类会带有一个对外部类的对象引用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;      <span class="comment">//Inner类是Outer类的内部类</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">val</span> zero:<span class="built_in">Int</span>=<span class="number">0</span></span><br><span class="line">      <span class="keyword">val</span> one:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">      </span><br><span class="line">       <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;    <span class="comment">//使用inner关键字声明内部类，来访问外部类的成员</span></span><br><span class="line">         <span class="function"><span class="keyword">fun</span> <span class="title">accessOuter</span><span class="params">()</span></span>=&#123;</span><br><span class="line">             println(zero)</span><br><span class="line">             println(one)</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> innerClass=NestedClassDemo.Outer().Inner().accessOuter()</span><br><span class="line">    println(innerClass)   <span class="comment">//打印结果：()-&gt;Kotlin.Unit，代表是个innerClass变量是个函数类型，且无参数，无返回</span></span><br><span class="line">    innerClass()  </span><br><span class="line">    <span class="comment">/*以函数形式调用，打印结果为：</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="10-3-匿名内部类"><a href="#10-3-匿名内部类" class="headerlink" title="10.3 匿名内部类"></a>10.3 匿名内部类</h3><p>匿名内部类就是没有名字的内部类。匿名内部类也可以访问外部类的变量。下面使用对象表达式创建一个匿名内部类，实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedClassDemo</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClassDemo</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> isRunning=<span class="literal">false</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Thread(<span class="keyword">object</span> :Runnable&#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    TODO(<span class="string">"Not yet implemented"</span>)</span><br><span class="line">                    isRunning=<span class="literal">true</span></span><br><span class="line">                    println(<span class="string">"doRun : i am running,isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*注：如果对象是函数式子Java接口，即具有单个抽象方法的Java接口的实例，例如上面例子中的Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>                   <span class="comment">//Java 8 中引入的函数式接口注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;       <span class="comment">//函数式接口只有一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用Lambda表达式实现Runnable接口。下面几种写法都是可以的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isRunning=<span class="literal">true</span></span><br><span class="line">  Thread(&#123;    <span class="comment">//直接使用Lambda表达式</span></span><br><span class="line">      isRunning =<span class="literal">false</span></span><br><span class="line">      println(<span class="string">"doStop: i am not running,isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">  &#125;).start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRunning=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> wait=Runnable&#123; <span class="comment">//使用匿名内部类的方式，使用Lambda表达式实现run接口</span></span><br><span class="line">        isRunning=<span class="literal">false</span></span><br><span class="line">        println(<span class="string">"doWait:i am waiting,isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread(wait).start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doNotify</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRunning=<span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> wait=&#123;       <span class="comment">//直接声明一个Lambda函数</span></span><br><span class="line">        isRunning=<span class="literal">false</span></span><br><span class="line">        println(<span class="string">"doNotify:i notify, isRunning=<span class="variable">$isRunning</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread(wait).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux指令</title>
    <url>/2020/09/20/Linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Kotlin扩展函数与扩展属性</title>
    <url>/2020/05/03/Kotlin%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E4%B8%8E%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="kotlin扩展函数与扩展属性"><a href="#kotlin扩展函数与扩展属性" class="headerlink" title="kotlin扩展函数与扩展属性"></a>kotlin扩展函数与扩展属性</h1><a id="more"></a>

<p>(近期在学kotlin和vue希望可以慢慢掌握吧—小小白)</p>
<h2 id="1-给String类扩展firstChar-函数和lastChar-函数"><a href="#1-给String类扩展firstChar-函数和lastChar-函数" class="headerlink" title="1. 给String类扩展firstChar()函数和lastChar()函数"></a>1. 给String类扩展firstChar()函数和lastChar()函数</h2><p>扩展函数与扩展属性可以在不修改原来类的条件下自定义函数和属性，使它们表现得就像是属于这条个类一样。例如，我们给String类型扩展一个返回字符串最后一个字符的firstChar()函数，然后在main函数中调用。代码十分简洁。(kotlin中使用fun来声明函数)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">     &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.length-<span class="number">1</span>].toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">firstChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">ArrayList</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=<span class="string">"abc"</span></span><br><span class="line">    println(<span class="string">"lastChar: "</span>+str.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果非常明显，会打印出 (上例中的this值得就是调用lastChar函数的对象实例):</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lastChar: c</span><br></pre></td></tr></table></figure>

<p>注：kotlin中println函数是封装了java中的System.out.println()函数。</p>
<p>*扩展函数的语法可用下图概括：</p>
<img src="https://s1.ax1x.com/2020/04/29/JHJqpT.jpg" style="zoom:50%;" />



<p>如果在其他的package路径下面，则需要import导入扩展函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.easy.Kotlin.tutorial   <span class="comment">//与扩展函数不在同一个包路径下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.easy.Kotlin.firstChar   <span class="comment">//导入扩展函数firstChar()</span></span><br><span class="line"><span class="keyword">import</span> com.easy.Kotlin.lastChar    <span class="comment">//导入扩展函数lastChar()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> str=<span class="string">"Hello"</span></span><br><span class="line">    println(str.lastChar())   <span class="comment">//打印结果：o</span></span><br><span class="line">    println(<span class="string">"abc"</span>.firstChar()) <span class="comment">//打印结果：a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-给List类扩展一个过滤函数"><a href="#2-给List类扩展一个过滤函数" class="headerlink" title="2. 给List类扩展一个过滤函数"></a>2. 给List类扩展一个过滤函数</h2><p>如果我们要给List类自定义一个扩展过滤函数，应该怎样去做呢？</p>
<h3 id="2-1-用Java给list类扩展一个过滤函数"><a href="#2-1-用Java给list类扩展一个过滤函数" class="headerlink" title="2.1 用Java给list类扩展一个过滤函数"></a>2.1 用Java给list类扩展一个过滤函数</h3><p>为了让读者能更加深刻地体会到Kotlin扩展功能的简单、优雅性，我们先看在Java中是怎样实现的吧！首先，我们会声明一个ListUtil类，里面实现一个List filter(List,list Predicatep)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUtil</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *根据谓词p过滤list中的元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt;filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">        List&lt;T&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//新建一个List链表，用来存放满足predicate条件的值</span></span><br><span class="line">        <span class="keyword">for</span>(T t:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.predicate(t))&#123;        <span class="comment">//判断t是否满足predicate条件</span></span><br><span class="line">            result.add(t);         <span class="comment">//要是满足则添加到result中</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         List&lt;Integer&gt; list=Arrays.asList(<span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;); <span class="comment">//创建一个Integer类型的链表</span></span><br><span class="line">         ListUtil&lt;Integer&gt; listUtil=<span class="keyword">new</span> ListUtil();  <span class="comment">//声明ListUtil类的实例对象</span></span><br><span class="line">         List&lt;Integer&gt; result=listUtil.filter(list,(it)-&gt;it%<span class="number">2</span>==<span class="number">1</span>); <span class="comment">//Lambdab表达式  </span></span><br><span class="line">         out.println(result);  <span class="comment">//打印结果：[1,3,5,7]  </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Predicate接口声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="function">Boolean <span class="title">predicate</span><span class="params">(T t)</span></span>;   <span class="comment">//返回布尔值的谓词函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-用Kotlin给list扩展一个过滤函数"><a href="#2-2-用Kotlin给list扩展一个过滤函数" class="headerlink" title="2.2 用Kotlin给list扩展一个过滤函数"></a>2.2 用Kotlin给list扩展一个过滤函数</h3><p>下面我们就来使用Kotlin中的扩展函数为List扩展一个filter()函数</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JHdKl6.jpg" alt=""></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> T List<span class="type">&lt;T&gt;</span><span class="title">filter</span><span class="params">(predicate:(<span class="type">T</span>)-&gt;<span class="type">Boolean</span>)</span></span>:MutableList&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">val</span> result=ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">this</span>.forEach&#123;               <span class="comment">//这里的this，指调用者</span></span><br><span class="line">        <span class="keyword">if</span>(predicate(it))&#123;      <span class="comment">//如果满足谓词判断条件</span></span><br><span class="line">            result.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=mutableListOf&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">    <span class="keyword">val</span> result=list.filter&#123;</span><br><span class="line">        it%<span class="number">2</span>==<span class="number">1</span>           <span class="comment">//这是一个Lambda表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)     <span class="comment">//打印结果：[1,3,5,7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin的标准库API中使用了扩展的功能，通过扩展Java的API，提供了大量使用且简单的函数。</p>
<h2 id="3-扩展属性"><a href="#3-扩展属性" class="headerlink" title="3.  扩展属性"></a>3.  扩展属性</h2><p>除了扩展一个类的函数，还可以扩展类的属性。例如，给MutableList扩展两个属性：firstElement和lastElement</p>
<p>*语法：</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JHwpAH.jpg" alt=""></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &lt;T&gt;MutableList&lt;T&gt;.firstElement:T</span><br><span class="line">    <span class="keyword">get</span>()&#123;                         <span class="comment">//扩展属性firstElement的get()函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>]             <span class="comment">//返回第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;                    <span class="comment">//扩展属性firstElement的set()函数</span></span><br><span class="line">        <span class="keyword">this</span>[<span class="number">0</span>]=value              <span class="comment">//设置第一个元素为value</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> &lt;T&gt;MutableList&lt;T&gt;.lastElement:T</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.size-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="keyword">this</span>.size-<span class="number">1</span>]=value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=mutableListOf&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">    println(<span class="string">"list=<span class="subst">$&#123;list&#125;</span>"</span>)  <span class="comment">//打印[1,2,3,4,5,6,7]</span></span><br><span class="line">    println(list.firstElement) <span class="comment">//打印：1</span></span><br><span class="line">    println(list.lastElement) <span class="comment">//打印：7</span></span><br><span class="line">    </span><br><span class="line">    list.firstElement=-<span class="number">1</span></span><br><span class="line">    list.lastElement=-<span class="number">7</span></span><br><span class="line">    println(<span class="string">"list=<span class="subst">$&#123;list&#125;</span>"</span>)  <span class="comment">//打印[-1,2,3,4,5,6,-7]</span></span><br><span class="line">    println(list.firstElement) <span class="comment">//打印：-1</span></span><br><span class="line">    println(list.lastElement) <span class="comment">//打印：-7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-扩展的实现原理"><a href="#4-扩展的实现原理" class="headerlink" title="4.  扩展的实现原理"></a>4.  扩展的实现原理</h2><p>扩展属性和扩展函数的本质是以静态导入的方式来实现的。其背后的实现原理可以通过Kotlin代码的ByteCode来理解。</p>
<p>例如给String类型扩展的firstChar()函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">firstChar</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>].toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面对应的JVM代码反编译成java代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">firstChar</span><span class="params">(@NotNull String $receiver)</span></span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull($receiver,<span class="string">"$receiver"</span>);</span><br><span class="line">    <span class="keyword">return</span> $receiver.length()==<span class="number">0</span> ? <span class="string">""</span> : String.valueOf($receiver.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-扩展中的this关键字"><a href="#5-扩展中的this关键字" class="headerlink" title="5. 扩展中的this关键字"></a>5. 扩展中的this关键字</h2><p>Kotlin中使用this表达式：</p>
<ul>
<li>在类的成员函数中，this指向这个类的当前对象实例；</li>
<li>在扩展函数中，或带接收者的函数字面值(function literal)中，this代表调用函数时，在点号左侧传递的接收者参数；</li>
<li>如果this没有限定符，那么它指向包含当前代码的最内层范围。如果想要指向其他范围内的this，需要使用标签限定符。</li>
</ul>
<p>*编程技巧提示：可以新建一个公共资源文件，把自定义的扩展属性和扩展函数都放到包中，作为一个通用工具类来使用。</p>
]]></content>
      <categories>
        <category>kotlin学习</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库</title>
    <url>/2020/09/20/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring与String boot</title>
    <url>/2020/09/20/Spring%E4%B8%8EString-boot/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring基于Annotation的装配</title>
    <url>/2020/05/05/Spring%E5%9F%BA%E4%BA%8EAnnotation%E7%9A%84%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>go语言中链表的使用</title>
    <url>/2020/09/20/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="go语言中链表的使用"><a href="#go语言中链表的使用" class="headerlink" title="#go语言中链表的使用"></a>#go语言中链表的使用</h1><a id="more"></a>

<p>（1）通过 container/list包的New()函数初始化list</p>
<p>​      b:=list.New()</p>
<p>​    (2)通过var关键字声明初始化list</p>
<p>​     var b list.List</p>
<p>​     (3) list 添加元素：</p>
<p>​      </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b:=list.New()</span><br><span class="line"></span><br><span class="line">b.PushBack(<span class="string">"fist"</span>)</span><br><span class="line">b.PushFront(<span class="number">85</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//PushBack是从列表的尾部插入</span></span><br><span class="line"><span class="comment">//PushFront是从列表的前面插入</span></span><br><span class="line"><span class="comment">//故85应在"fist"之前</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InsertAfter(v interface{}, mark*Element) *Element</td>
<td>在mark点之后插入元素，mark点由其他插入函数提供</td>
</tr>
<tr>
<td align="center">InsertBefore(v interface{},makr*Element) *Element</td>
<td>在mark点之前插入元素，mark点由其他插入函数提供</td>
</tr>
<tr>
<td align="center">PushBackList(other *List)</td>
<td>添加other列表元素到尾部</td>
</tr>
<tr>
<td align="center">PushFrontList(other*List)</td>
<td>添加other列表元素到头部</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   b:=list.New()</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//尾部添加</span></span><br><span class="line">   b.PushBack(<span class="string">"canon"</span>)</span><br><span class="line">   <span class="comment">//头部添加</span></span><br><span class="line">   b.PushFront(<span class="number">76</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//尾部添加后保存元素句柄</span></span><br><span class="line">   element:=b.PushBack(<span class="string">"fist"</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//在fiist之前添加noon</span></span><br><span class="line">   b.InsertBefore(<span class="string">"noon"</span>,element)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用</span></span><br><span class="line">   b.Remove(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历列表   访问列表的每一个元素</span></span><br><span class="line"><span class="keyword">for</span> i:= b.Front();i!=<span class="literal">nil</span>;i=i.Next&#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin集合类</title>
    <url>/2020/04/30/Kotlin%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Kotlin集合类"><a href="#Kotlin集合类" class="headerlink" title="Kotlin集合类"></a>Kotlin集合类</h1><a id="more"></a>

<p>在Java类库中有一套相当完整的容器集合类来持有对象。Kotlin没有去重复造轮子(Scala则是自己实现了一套集合类框架)，而是在Java类库的基础上进行改造和扩展，引入了不可变集合类，同时扩展了大量方便实用的功能，这些功能的API都在Kotlin.collections包下面</p>
<p>另外，在Kotlin的集合类中不仅仅能持有普通对象，而且能够持有函数类型的变量。例如下面是一个持有两个函数的集合类：</p>
<p>其中，(Int) -&gt;Boolean 是一个从Int映射到Boolean的函数，而这个时候，我们可以在代码里选择调用哪个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> funlist:List&lt;(<span class="built_in">Int</span>)-&gt;<span class="built_in">Boolean</span>&gt;=  <span class="comment">//声明一个持有类型为函数(Int) -&gt;Boolean的List</span></span><br><span class="line">listOf(&#123;it-&gt;it%<span class="number">2</span>==<span class="number">0</span>&#125;,   <span class="comment">//第1个函数为&#123;it-&gt;it%2==0&#125;</span></span><br><span class="line">       &#123;it-&gt;it%<span class="number">2</span>==<span class="number">1</span>&#125;)   <span class="comment">//第2个函数为&#123;it-&gt;it%2==1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">     list.filter(funlist[<span class="number">0</span>]) <span class="comment">//传入第1个函数funlist[0]，返回[2,4,6]</span></span><br><span class="line">     list.filter(funlist[<span class="number">1</span>]) <span class="comment">//传入第2个函数funlist[1]，返回[1,3,5,7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="1-集合类概述"><a href="#1-集合类概述" class="headerlink" title="1. 集合类概述"></a>1. 集合类概述</h2><p>集合类存放的都是对象的引用，而非对象本身，我们通常说的集合中的对象指的是集合中对象的引用(reference)。</p>
<p>Kotlin的集合类分为：可变集合类(Mutable)与不可变集合类(Immutable)</p>
<hr>
<h3 id="1-1-常用的三种集合类"><a href="#1-1-常用的三种集合类" class="headerlink" title="1.1  常用的三种集合类"></a>1.1  常用的三种集合类</h3><p>集合类主要有3种：List(列表)、Set(集)和Map(映射)。</p>
<ul>
<li>List容器中的元素以线性方式存储，集合中可以存放重复对象。列表中的元素是有序地排列。</li>
<li>Set集容器的元素无序、不重复。</li>
<li>Map映射中持有的是”键值对” 对象，每个对象都包含一对键值K-V对象。Map映射容器中存储的每个对象都有一个相关的关键字(Key)对象，关键字决定对象在映射中的存储位置。关键字是唯一的。其实关键字本身并不能决定对象的存储位置，它通过散列(hashing)产生一个被称作散列码(hash code)的整数值，这个散列码对应值(Value)的存储位置。</li>
</ul>
<p>如果我们从数据结构的本质上来看，其实List中的下标就是Key，只不过Key是有序的Int类型，所以说List也可以说是一种特殊的Map数据结构。而Set也是Key为Int类型，但是Value值是不能重复的特殊Map。</p>
<p>下面是Kotlin中集合类接口的结构层次：</p>
<img src="https://s1.ax1x.com/2020/04/30/Jq4MGt.jpg" style="zoom: 33%;" />

<p>其中，各个接口说明如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/30/Jq4rsU.jpg" alt=""></p>
<hr>
<h3 id="1-2-不可变集合类"><a href="#1-2-不可变集合类" class="headerlink" title="1.2  不可变集合类"></a>1.2  不可变集合类</h3><ul>
<li>List列表分为只读不可变的List和可变MutableList(可写入、删除数据)。List列表的类型层次结构如下：</li>
</ul>
<img src="https://s1.ax1x.com/2020/04/30/JqoIyV.jpg" style="zoom: 50%;" />



<ul>
<li>Set集也分为不可变Set和可变MutableSet(可写入、删除数据)。Set集合的类型层次结构如下图：</li>
</ul>
<p>  <img src="https://s1.ax1x.com/2020/04/30/JqbkY4.jpg" alt=""></p>
<ul>
<li>Kotlin中的Map与List、Set一样，Map也分为只读Map和可变MutableMap(可写入、删除数据)</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/04/30/JqbW7T.jpg" alt=""></p>
<hr>
<h3 id="1-3-创建集合类"><a href="#1-3-创建集合类" class="headerlink" title="1.3  创建集合类"></a>1.3  创建集合类</h3><ul>
<li>不可变集合类的创建</li>
</ul>
<p>​       Kotlin中分别使用listOf()、setOf()、mapOf()函数创建不可变的List列表容器、Set容器、Map映射容器；</p>
<ul>
<li><p>可变集合类的创建</p>
<p>使用mutableListOf()、mutableSet()、mutableMapOf()函数来创建可变的MutableList列表容器、MutableSet集容器、MutableMap映射容器</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/04/30/JqO3hF.jpg" alt=""></p>
<p>​                                                                               图7.3.1 创建List</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JqO2nI.jpg" alt=""></p>
<p>​                                                                              图7.3.2 创建Set</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JqOx4U.jpg" alt=""></p>
<p>​                                                                              图7.3.3 创建Map</p>
<p>代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mian</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> list1=listOf(<span class="string">"a"</span>,<span class="string">"d"</span>,<span class="string">"m"</span>,<span class="string">"i"</span>,<span class="string">"n"</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableList=mutableListOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">    mutableList.add(<span class="string">"d"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span>=setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> set1= setOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableset=mutableSetOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line">    mutableset.add(<span class="string">"e"</span>)</span><br><span class="line">    mutableset.remove(<span class="string">"c"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"a"</span>,<span class="number">2</span> to <span class="string">"b"</span>,<span class="number">3</span> to <span class="string">"c"</span>)</span><br><span class="line">    <span class="keyword">val</span> mutableMap=mutableMapOf(<span class="number">1</span> to <span class="string">"X"</span>,<span class="number">2</span> to <span class="string">"Y"</span>,<span class="number">3</span> to <span class="string">"Z"</span>)</span><br><span class="line">    mutableMap.<span class="keyword">set</span>(<span class="number">2</span>,<span class="string">"spring"</span>)</span><br><span class="line">    mutableMap.replace(<span class="number">3</span>,<span class="string">"boot"</span>)</span><br><span class="line">    mutableMap.put(<span class="number">4</span>,<span class="string">"C"</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"list="</span>+list)   <span class="comment">//打印 list=[1,2,3,4,5,6,7]</span></span><br><span class="line">    println(<span class="string">"list1=<span class="variable">$list1</span>"</span>)  <span class="comment">//打印 list1=[a,d,m,i,n]</span></span><br><span class="line">    println(<span class="string">"mutableList=<span class="variable">$mutableList</span>"</span>) <span class="comment">//打印  mutableList=[a,b,c,d]</span></span><br><span class="line">    println(<span class="string">"set="</span>+<span class="keyword">set</span>)   <span class="comment">//打印  set=[1,2,3,4,5,6,7]</span></span><br><span class="line">    println(<span class="string">"set1=<span class="variable">$set1</span>"</span>)  <span class="comment">//打印 set1=[a,b,c,d]</span></span><br><span class="line">    println(<span class="string">"mutableset=<span class="variable">$mutableset</span>"</span>)  <span class="comment">//打印 mutableset=[a,b,d,e]</span></span><br><span class="line">    </span><br><span class="line">    println(mutableMap.[<span class="number">2</span>]) <span class="comment">//打印  Y</span></span><br><span class="line">    println(mutableMap.<span class="keyword">get</span>(<span class="number">2</span>)) <span class="comment">//打印 Y   =&gt; println(mutableMap.[2])</span></span><br><span class="line">    println(<span class="string">"map=<span class="variable">$map</span>"</span>)  <span class="comment">//打印  map=[1=a,2=b,3=c]</span></span><br><span class="line">    println(<span class="string">"mutableMap=<span class="variable">$mutableMap</span>"</span>) <span class="comment">//打印 mutableMap=[1=X,2=spring,3=boot,4=C]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果创建没有元素的空List，使用listOf()即可。不过这个时候，变量的类型不能省略，需要显示声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;<span class="built_in">Int</span>&gt; = listOf() <span class="comment">//这样显示声明一个元素类型为Int，并切为空的List是错误的</span></span><br><span class="line"><span class="comment">//原因是Kotlin中变量要是想为空，必须声明为可空变量</span></span><br><span class="line"><span class="keyword">val</span> emptyList: List&lt;<span class="built_in">Int</span>&gt; ? =listOf() <span class="comment">//这样声明才不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> emptySet: Set&lt;<span class="built_in">Int</span>&gt; ? =setOf()   <span class="comment">//显示声明Set的元素类型为Int</span></span><br><span class="line"><span class="keyword">val</span> emptyMap: Map&lt;<span class="built_in">Int</span>,String&gt; ? =mapOf() <span class="comment">//显示声明Map的元素类型为Int，String键值对</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">listOf</span><span class="params">()</span></span>: List&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 fun <T> 泛型参数T编译器无法推断出来。setOf()、mapOf()分析同理。</p>
<hr>
<h3 id="1-4-遍历集合中的元素"><a href="#1-4-遍历集合中的元素" class="headerlink" title="1.4 遍历集合中的元素"></a>1.4 遍历集合中的元素</h3><p>List、Set类继承了Iterable接口，里面扩展了forEach函数来迭代遍历元素；同样，Map接口中也扩展了forEach函数来迭代遍历元素。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEach&#123;             <span class="comment">//List中的forEach</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>.forEach&#123;              <span class="comment">//Set中的forEach</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line">map.forEach&#123;</span><br><span class="line">  println(<span class="string">"k=<span class="subst">$&#123;it.key&#125;</span>,V=<span class="subst">$&#123;it.value&#125;</span>"</span>)  <span class="comment">//Map里面的对象是Map。Entry&lt;K,V&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，forEach()函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(action:(<span class="type">T</span>)-&gt;<span class="type">Unit</span>)</span></span>:<span class="built_in">Unit</span> <span class="comment">//List和Set的forEach()函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K,V&gt;</span> Map<span class="type">&lt;out K,V&gt;</span>.<span class="title">forEach</span><span class="params">(action:(<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;)-&gt;<span class="type">Unit</span>)</span></span>:<span class="built_in">Unit</span></span><br><span class="line"><span class="comment">//Map的forEach()函数</span></span><br></pre></td></tr></table></figure>



<ul>
<li>另外，如果我们想在迭代遍历元素的时候访问index下标，在List和Set中可以使用下面的forEachIndexed函数</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list.forEachIndexed&#123; index,value-&gt;     <span class="comment">//带下标index来遍历List</span></span><br><span class="line">  println(<span class="string">"list index=<span class="subst">$&#123;index&#125;</span>, value=<span class="subst">$&#123;value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEachIndexed&#123; index,value-&gt;     <span class="comment">//带下标index来遍历set</span></span><br><span class="line">  println(<span class="string">"set index=<span class="subst">$&#123;index&#125;</span>,value=<span class="subst">$&#123;value&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，第一个参数是index，第2个参数是value。这里的forEachIndexed函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEachIndexed</span><span class="params">(action:(<span class="type">index</span>:<span class="type">Int</span>,<span class="type">T</span>)-&gt;<span class="type">Unit</span>)</span></span>:<span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>Map的元素是Entry类型，由entries属性特有。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> entries:Set&lt;Entry&lt;K,V&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这个Entry类型定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="type">out K,out V</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> key:K     <span class="comment">//键值对的Key</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">val</span> Value:V   <span class="comment">//键值对的Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以直接访问entries属性获取该Map中的所有键值对的Set。代码实例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> map=mapOf(<span class="string">"x"</span> to <span class="number">1</span>,<span class="string">"y"</span> to <span class="number">2</span>,<span class="string">"z"</span> to <span class="number">3</span>)</span><br><span class="line">    println(map)    <span class="comment">//打印结果：&#123;x=1,y=2,z=3&#125;</span></span><br><span class="line">    println(<span class="string">"entries=<span class="subst">$&#123;map.entries&#125;</span>"</span>) <span class="comment">//打印结果：[x=1,y=2,z=3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以遍历这个Entry的Set了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">map.entries.forEach(&#123;println(<span class="string">"key="</span>+it.key+<span class="string">" value="</span>+it.value)&#125;)  <span class="comment">//遍历entries中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印结果：</span></span><br><span class="line"><span class="comment">key=x value=1</span></span><br><span class="line"><span class="comment">key=y value=2</span></span><br><span class="line"><span class="comment">key=z value=3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<h3 id="1-5-映射函数"><a href="#1-5-映射函数" class="headerlink" title="1.5  映射函数"></a>1.5  映射函数</h3><p>使用map函数，可以把集合中的元素依次使用给定的转换函数进行映射操作，元素映射之后的新值会存入一个新的集合中，并返回这个新集合。</p>
<p>在List、Set继承Iterable接口和Map接口中，都提供了这个map函数。使用map函数的代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">   <span class="keyword">val</span> <span class="keyword">set</span>=setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">   <span class="keyword">val</span> map=mapOf(<span class="number">1</span> to <span class="string">"a"</span>, <span class="number">2</span> to <span class="string">"b"</span>, <span class="number">3</span> to <span class="string">"c"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下都没有使用println函数,因此不会被打印出来</span></span><br><span class="line">    list.map&#123;it*it&#125;  <span class="comment">//map函数对每个元素进行乘方操作，返回[1,4,9,16,25,36,49]</span></span><br><span class="line">    <span class="keyword">set</span>.map&#123;it+<span class="number">1</span>&#125;    <span class="comment">//set函数对每个元素进行加1操作，返回[2,3,4,5,6,7,8]</span></span><br><span class="line">    map.map&#123;it.value+<span class="string">"$"</span>&#125;  <span class="comment">//map函数对每个元素后加上字符$，返回[a$,b$,c$]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map函数的签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T,R&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">map</span><span class="params">(transform:(<span class="type">T</span>)-&gt;<span class="type">R</span>)</span></span>:List&lt;R&gt;  <span class="comment">//这个是List和Set的map函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;K,V,R&gt;</span>Map<span class="type">&lt;K,V&gt;</span>.<span class="title">map</span><span class="params">(transform:(<span class="type">Map</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>)-&gt;<span class="type">R</span>)</span></span>:List&lt;R&gt; <span class="comment">//Map的map函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的R类型是映射之后的数据类型，我们也可以传入一个List：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> strlist=listOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">    strlist.map&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125; <span class="comment">//map函数，每个it映射之后返回一个List，这个List中有4个元素，分别是it+1，it+2，it+3，it+4</span></span><br><span class="line">    </span><br><span class="line">    println(strlist.map&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125;) </span><br><span class="line">    <span class="comment">/* 返回的类型是List，也就是一个List里嵌套一个List</span></span><br><span class="line"><span class="comment">    打印结果：[[a1,a2,a3,a4],[b1,b2,b3,b4],[c1,c2,c3,c4]]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Kotlin中还提供了一个flatten()函数，效果是把嵌套的List结构“平铺”，变成一层的结构</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(strlist.map&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125;.flatten())<span class="comment">//"平铺"函数，把嵌套在List中的元素“平铺”成一层List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打入结果：[a1,a2,a3,a4,b1,b2,b3,b4,c1,c2,c3,c4]</span></span><br></pre></td></tr></table></figure>



<p>flatMap函数式map和flat两个函数的“复合逻辑”，代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(strlist.flatMap&#123;it-&gt;listOf(it+<span class="number">1</span>,it+<span class="number">2</span>,it+<span class="number">3</span>,it+<span class="number">4</span>)&#125;)</span><br><span class="line"><span class="comment">//打印结果：[a1,a2,a3,a4,b1,b2,b3,b4,c1,c2,c3,c4]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-6-过滤函数"><a href="#1-6-过滤函数" class="headerlink" title="1.6  过滤函数"></a>1.6  过滤函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">var</span> id:<span class="built_in">Long</span>,<span class="keyword">var</span> name:String,<span class="keyword">val</span> age:<span class="built_in">Int</span>,<span class="keyword">var</span> score:<span class="built_in">Int</span>)&#123;</span><br><span class="line">         <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>:String&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"Student(id=<span class="variable">$id</span>,name=<span class="variable">$name</span>,age=<span class="variable">$age</span>,score=<span class="variable">$score</span>)"</span></span><br><span class="line">             <span class="comment">//重写toString()函数，是为了看到打印信息</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> studentList=listOf(</span><br><span class="line">        Student(<span class="number">1</span>,<span class="string">"Jack"</span>,<span class="number">18</span>,<span class="number">90</span>),</span><br><span class="line">        Student(<span class="number">2</span>,<span class="string">"Kim"</span>,<span class="number">19</span>,<span class="number">89</span>),</span><br><span class="line">        Student(<span class="number">3</span>,<span class="string">"Alice"</span>,<span class="number">17</span>,<span class="number">88</span>)</span><br><span class="line">    )</span><br><span class="line">    println(studentList.filter&#123;it-&gt;it.age&gt;<span class="number">18</span>&#125;)</span><br><span class="line">    <span class="comment">//打印结果：[Student(id=2,name=Kim,age=19,score=89)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>另外，如果想要通过访问下标来过滤，可以使用filterIndexed()函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">println(list.filterIndexed&#123;index, it-&gt;index%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;it&gt;<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">/*带下标过滤List中的元素</span></span><br><span class="line"><span class="comment">打印结果：[5,7]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>filterIndexed()函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">filterIndexed</span><span class="params">(predicate:(<span class="type">index</span>:<span class="type">Int</span>,<span class="type">T</span>)-&gt;<span class="type">Boolean</span>)</span></span>:List&lt;T&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-7-排序函数"><a href="#1-7-排序函数" class="headerlink" title="1.7  排序函数"></a>1.7  排序函数</h3><h4 id="1-7-1-Kotlin-集合类中提供了倒序列集合类元素的函数reversed-，代码示例如下："><a href="#1-7-1-Kotlin-集合类中提供了倒序列集合类元素的函数reversed-，代码示例如下：" class="headerlink" title="1.7.1 Kotlin 集合类中提供了倒序列集合类元素的函数reversed()，代码示例如下："></a>1.7.1 Kotlin 集合类中提供了倒序列集合类元素的函数reversed()，代码示例如下：</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="keyword">set</span>=setOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">list.reversed()   <span class="comment">//倒序函数，返回[7,6,5,4,3,2,1]</span></span><br><span class="line"><span class="keyword">set</span>.reversed()    <span class="comment">//倒序函数，返回[2,3,1]</span></span><br><span class="line"><span class="comment">//这里的倒序函数，指的是index下标的倒序，而不是value的倒序</span></span><br></pre></td></tr></table></figure>

<p>这个Iterable的扩展函数reversed()是直接调用的java.util.Collection.reverse()方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span><span class="type">&lt;T&gt;</span>Iterable<span class="type">&lt;T&gt;</span>.<span class="title">reversed</span><span class="params">()</span></span>:List&lt;T&gt;&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">is</span> Collection &amp;&amp; size&lt;=<span class="number">1</span>) <span class="keyword">return</span> toList()</span><br><span class="line">   <span class="keyword">val</span> list = toMutableList()</span><br><span class="line">   list.reverse()  <span class="comment">//调用Java中List类型的reverse()方法</span></span><br><span class="line">   <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">()</span></span>:<span class="built_in">Unit</span>&#123;</span><br><span class="line">    java.util.Collection.reverse(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-7-2-升序排序函数sorted"><a href="#1-7-2-升序排序函数sorted" class="headerlink" title="1.7.2  升序排序函数sorted()"></a>1.7.2  升序排序函数sorted()</h4><p>升序排序函数sorted()，是对List、Set进行value值的升序排序。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(list.sorted())  <span class="comment">//打印结果：[1,2,3,4,5,6,7]</span></span><br><span class="line">println(<span class="keyword">set</span>.sorted())   <span class="comment">//打印结果：[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>Kotlin中的这个sorted()函数也是直接调用Java的API来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> fun &lt;T :Comparable&lt;T&gt;&gt;Iterable&lt;T&gt;.sorted():List&lt;T&gt;&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span> is Collection)&#123;</span><br><span class="line">        <span class="keyword">if</span>(size&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.toList()</span><br><span class="line">        <span class="meta">@Suppress</span>(<span class="string">"UNCHECKED_CAST"</span>)</span><br><span class="line">        <span class="keyword">return</span>(toTypeArray&lt;Comparable&lt;T&gt;&gt;()as Array&lt;T&gt;).apply&#123;sort()&#125;.asList()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> toMutableList().apply&#123;sort()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其背后调用的是Java.util.Arrays.sort()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> fun&lt;T&gt;Array&lt;out T&gt;.sort():Unit&#123;</span><br><span class="line">   it(size&gt;<span class="number">1</span>)</span><br><span class="line">   java.util.Arrays.sort(<span class="keyword">this</span>)  <span class="comment">//调用Java中Arrays类型的sort方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-8-元素去重"><a href="#1-8-元素去重" class="headerlink" title="1.8  元素去重"></a>1.8  元素去重</h3><p>如果我们想对一个List列表进行元素去重，可以直接调用distinct()函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dupList=listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">dupList.distinct()   <span class="comment">//去重函数，返回[1,2,3]</span></span><br></pre></td></tr></table></figure>

<p>Kotlin的集合类中还提供了许多功能丰富的API，此处不再一一介绍。更多内容可以参考官方API文档。</p>
<p>http:// kotlinlang.org/ api/ latest/ jvm/ stdlib/ kotlin.collections/ index.html</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo错误解决</title>
    <url>/2020/04/04/hexo%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="今天遇到的hexo错误，记录下以免以后遇到忘记。"><a href="#今天遇到的hexo错误，记录下以免以后遇到忘记。" class="headerlink" title="今天遇到的hexo错误，记录下以免以后遇到忘记。"></a>今天遇到的hexo错误，记录下以免以后遇到忘记。</h1><a id="more"></a>

<h2 id="1-当执行新建文章命令时："><a href="#1-当执行新建文章命令时：" class="headerlink" title="1. 当执行新建文章命令时："></a>1. 当执行新建文章命令时：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"text"</span></span><br></pre></td></tr></table></figure>

<p>默认[layout]为post。布局.md文件都在scaffolds文件夹下，共有post、draft、page三种。</p>
<p>执行完命令报错：</p>
<table>
<thead>
<tr>
<th>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<p>该错误的原因：是文章或文章布局中的属性: 后面没有空格。当然要是一些配置文件：后面没有空格的话肯定也会报错误。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line">copyright: </span><br><span class="line">--------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>后面发现后加了空格，但是不小心又点击了哪里把格式给弄乱了，虽然：后面都有空格，但是用Typora工具查看是下面少了一行虚线，于是就报了如下错误：</p>
<table>
<thead>
<tr>
<th>Cannot read property ‘replace’ of undefined</th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<p>看了很多帖子也没有太好的解决办法，于是我猜想就跟那一行虚线有关，其他layout文件用Typora工具打开后是有虚线的，于是我就复制了page.md, 更名为post.md。于是重新执行hexo new命令，结果就解决问题了</p>
<p>归根结底还是冒号(:)后面没有加空格的原因。希望以后多多注意！！！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery-find函数</title>
    <url>/2020/04/15/jQuery-find%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>jQuery.find()函数</p>
<a id="more"></a>

<h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>find()函数用于选取每个匹配元素的符合指定表达式的后代元素，并以JQuery对象的方式返回。这里的表达式包括：选择器(字符串)、DOM元素(Element)、jQuery对象。该函数属于JQuery对象(实例)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQueryObject.find(expr)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>expr</td>
<td>String/Element/jQuery类型指定的表达式</td>
</tr>
</tbody></table>
<p>find()函数将在当前JQuery对象每个匹配元素的所有后代元素中筛选符合指定表达式的元素。如果expr参数为字符串，则将其视作jQuery选择器，用以表示该选择器所匹配的元素。jQuery1.6新增支持：参数expr可以为DOM元素(Element)或jQuery对象。</p>
<h2 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h2><p>find()函数的返回值为jQuery类型，返回一个新的jQuery对象，该对象封装了当前jQuery对象匹配元素的所有符合指定选择器的后代元素。</p>
<p>如果没有匹配的元素，则返回空 的jQuery对象。</p>
<h2 id="示例-amp-说明："><a href="#示例-amp-说明：" class="headerlink" title="示例&amp;说明："></a>示例&amp;说明：</h2>]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin文件I/O操作、正则表达式与多线程</title>
    <url>/2020/05/03/Kotlin%E6%96%87%E4%BB%B6I-O%E6%93%8D%E4%BD%9C%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Kotlin文件I-O操作、正则表达式与多线程"><a href="#Kotlin文件I-O操作、正则表达式与多线程" class="headerlink" title="Kotlin文件I/O操作、正则表达式与多线程"></a>Kotlin文件I/O操作、正则表达式与多线程</h1><a id="more"></a>

<h2 id="1-文件I-O操作"><a href="#1-文件I-O操作" class="headerlink" title="1. 文件I/O操作"></a>1. 文件I/O操作</h2><p>Kotlin I/O操作的API在kotlin.io包下。Kotlin的原则就是Java已经有的好用的类就直接使用，没有的或者不好用的类，就在原有类的基础上进行功能扩展。Kotlin的序列化直接采用了Java序列化类的类型别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">internal typealias Serializable = java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>下面来简单介绍一下Kotlin文件的读写操作。Kotlin中常用的文件读写API如下表：</p>
<p><img src="https://s1.ax1x.com/2020/05/03/JzEbaq.jpg" alt=""></p>
<hr>
<h3 id="1-1-读文件"><a href="#1-1-读文件" class="headerlink" title="1.1  读文件"></a>1.1  读文件</h3><ol>
<li><p>readText：获取文件全部内容字符串</p>
<p>如果简单读取一个文件，可以使用readText()方法，它直接返回整个文件内容</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFileContent</span><span class="params">(filename:<span class="type">String</span>)</span></span>:String&#123;</span><br><span class="line">   <span class="keyword">var</span> f=File(filename)</span><br><span class="line">   <span class="keyword">return</span> f.readText(Charset.forName(<span class="string">"UTF-8"</span>))  <span class="comment">//获取整个文件的内容，以UTF-8编码格式的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们直接使用File对象来调用readText()函数即可获得该文件的全部内容，它返回一个字符串。如果指定字符编码，可以通过传入参数Charset来指定，默认是UTF-8编码。</p>
</li>
</ol>
<ol start="2">
<li><p>readLines：获取文件每行的内容</p>
<p>如果想要获得文件中每行的内容，可以简单通过split(“\n”)来获得一个每行内容的数组。我们一可以直接调用Kotlin封装好的readLines()函数，获得文件中每行的内容。readLines()函数返回一个持有每行内容的字符串List。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFileLines</span><span class="params">(filename:<span class="type">String</span>)</span></span>:List&lt;String&gt;&#123;   <span class="comment">//返回一个持有这个文件中每行内容的字符串List</span></span><br><span class="line">    <span class="keyword">return</span> File(filename).readLines(Charset.forName(<span class="string">"UTF-8"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>readBytes：读取字节流数组</p>
<p>如果希望直接操作文件的字节数组，可以使用readBytes()函数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取为bytes数组</span></span><br><span class="line"><span class="keyword">val</span> bytes:ByteArray = f.readBytes() <span class="comment">//返回这个文件的字节数组</span></span><br><span class="line">println(bytes.joinToString(separator=<span class="string">""</span>))</span><br><span class="line"><span class="comment">//与Java互操作，直接调用Java中的InputStream和InputStream类</span></span><br><span class="line"><span class="keyword">val</span> reader.Reader=f.reader()</span><br><span class="line"><span class="keyword">val</span> inputStream:InputStream=f.inputStream()</span><br><span class="line">al bufferedReader:BufferedReader = f.bufferedReader()</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>bufferedReader：获取文件的方法签名</p>
<p>获取文件的bufferedReader()方法签名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">bufferedReader</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    charset: <span class="type">Charset</span> = Charset.UTF_8,</span></span></span><br><span class="line"><span class="function"><span class="params">    bufferSize: <span class="type">Int</span> = DEFAULT_BUFFER_SIZE</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>:BufferedReader</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="1-2-写文件"><a href="#1-2-写文件" class="headerlink" title="1.2  写文件"></a>1.2  写文件</h3><p>使用Kotlin扩展的函数，写入文件也变得相当简单。与读取文件类似，我们可以写入字符串，也可以写入字节流，还可以直接调用Java的Write或者OutputStream类。写文件通常分为覆盖写(一次性写入) 和追加写两种情况。</p>
<ol>
<li><p>writeText：覆盖写文件</p>
<p>我们使用writeText()函数直接向一个文件中写入字符串text的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeFile</span><span class="params">(text:<span class="type">String</span>,destFile:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">     <span class="keyword">val</span> f=File(destFile)</span><br><span class="line">     <span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">         f.createNewFile()</span><br><span class="line">     &#125;</span><br><span class="line">     f.writeText(text.Charset.defaultCharset())   <span class="comment">//覆盖写入字符串text的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，destFile参数是目标文件名(带目录)。</p>
</li>
</ol>
<ol start="2">
<li><p>appendFile：末尾追加写文件</p>
<p>使用appendFile()函数向一个文件的末尾追加写入内容text</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appendFile</span><span class="params">(text:<span class="type">String</span>,destFile:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> f=File(destFile)</span><br><span class="line">    <span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">        f.createNewFile()</span><br><span class="line">    &#125;</span><br><span class="line">    f.appendText(text,Charset.defaultCharset())  <span class="comment">//追加写入内容text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>appendBytes：追加吸入字节数组</p>
<p>追加字节数组到该文件中方法签名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">appendBytes</span><span class="params">(array.ByteArray)</span></span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>bufferedWriter：获取缓存区写对象</p>
<p>获取该文件的bufferedWriter()方法签名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">bufferedWriter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   charset: <span class="type">Charset</span> =Charset.UTF_8,</span></span></span><br><span class="line"><span class="function"><span class="params">   bufferSize: <span class="type">Int</span> =DEFAULT_BUFFER_SIZE</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>:BufferedWriter</span><br></pre></td></tr></table></figure>

<p>*提示：可以参考 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/" target="_blank" rel="noopener">kotlin对File的扩展函数API文档</a></p>
</li>
</ol>
<hr>
<h3 id="1-3-遍历文件树"><a href="#1-3-遍历文件树" class="headerlink" title="1.3 遍历文件树"></a>1.3 遍历文件树</h3><p>Kotlin中提供了方便的功能来遍历文件树。</p>
<ol>
<li><p>walk函数：遍历文件树</p>
<p>下面的例子遍历了指定文件夹下的所有文件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">traverseFileTree</span><span class="params">(filename:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> f =File(filename)</span><br><span class="line">    <span class="keyword">val</span> fileTreeWalk = f.walk()</span><br><span class="line">    fileTreeWalk.iterator().forEach&#123;println(it.absolutePath)&#125;</span><br><span class="line">    <span class="comment">//遍历指定文件夹下的所有文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">KFileUtil。traverseFileTree(<span class="string">"."</span>)</span><br></pre></td></tr></table></figure>

<p>上面的测试代码将输出当前目录下的所有子目录及其文件。我们还可以遍历当前文件下所有的子目录文件，将其存入一个Iterator中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFileIterator</span><span class="params">(filename:<span class="type">String</span>)</span></span>:Iterator&lt;File&gt;&#123;</span><br><span class="line">    <span class="keyword">val</span> f =File(filename)</span><br><span class="line">    <span class="keyword">val</span> fileTreeWalk = f.walk()</span><br><span class="line">    <span class="keyword">return</span> fileTreeWalk.iterator()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们遍历当前文件下的所有子目录文件，还可以根据条件进行过滤，并把结果存入一个Sequence中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getFileSequenceBy</span><span class="params">(filename:<span class="type">String</span>,p:(<span class="type">File</span>)-&gt;<span class="type">Boolean</span>)</span></span>:Sequence&lt;File&gt;&#123;</span><br><span class="line">     <span class="keyword">val</span> f=File(filename)</span><br><span class="line">     <span class="keyword">return</span> f.walk().filter(p)  <span class="comment">//根据条件p过滤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历文件树需要调用扩展方法walk(), 它会返回一个FileTreeWalk对象，它有一些方法用于设置遍历方向和深度详情参见FileTreeWalk API文档说明。</p>
<p>*提示：<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/-file-tree-walk/" target="_blank" rel="noopener">FileTreeWalk API文档</a></p>
</li>
</ol>
<ol start="2">
<li><p>递归复制文件</p>
<p>复制该文件或者递归复制该目录及其所有子文件到指定路径下，如果指定路径下的文件不存在，会自动创建。</p>
<p>copyRecursively函数签名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">copyRecursively</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   target: <span class="type">File</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   overwirte: <span class="type">Boolean</span> =<span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   onError: (<span class="type">File</span>,<span class="type">IOException</span>)-&gt;<span class="type">onErrorAction</span>=&#123;_,exception-&gt;<span class="keyword">throw</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                              exception&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>:<span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
</ol>
<h2 id="2-网络I-O"><a href="#2-网络I-O" class="headerlink" title="2. 网络I/O"></a>2. 网络I/O</h2><p> Kotlin为Java SDK中的java.net.URL类增加了两个扩展方法，即readBytes和readText(Kotlin对Java已有的API做了许多这样的功能扩展与封装)。我们可以方便地使用这两个方法配合正则表达式实现网络爬虫的功能。</p>
<p>根据URL获取该URL的响应HTML函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUrlContent</span><span class="params">(url:<span class="type">String</span>)</span></span>:String&#123;</span><br><span class="line">     <span class="keyword">return</span> URL(url).readText(Charset.defaultCharset())  <span class="comment">//获取该URL的响应HTML文本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUrlBytes</span><span class="params">(url:<span class="type">String</span>)</span></span>:ByteArray&#123;</span><br><span class="line">    <span class="keyword">return</span> URL(url).readBytes()   <span class="comment">//获取该URL的响应ByteArray</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">writeUrlBytesTo</span><span class="params">(filename:<span class="type">String</span>,url:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">     <span class="keyword">val</span> bytes=URL(url).readBytes()</span><br><span class="line">     File(filename).writeBytes(bytes)  <span class="comment">//写入文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     getUrlContent(<span class="string">"https://www.baidu.com"</span>) <span class="comment">//获取了百度首页的源代码</span></span><br><span class="line">     writeUrlBytesTo(<span class="string">"图片.jpg"</span>,<span class="string">"https://s1.ax1x.com/2020/05/03/JzEbaq.jpg"</span>)</span><br><span class="line">    <span class="comment">//以“图片.jpg”的形式保存url中的图片，先获取一张图片的比特流，然后调用readBytes()方法读取字节流并写入文件中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-执行Shell命令"><a href="#3-执行Shell命令" class="headerlink" title="3.  执行Shell命令"></a>3.  执行Shell命令</h2><p>在Kotlin中，目前还没有对String类和Process类扩展这样的函数。其实扩展这样的函数非常简单，我们为完全可以自己去扩展。</p>
<p>首先我们来扩展String的execute()函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">execute</span><span class="params">()</span></span>:Proces&#123;   <span class="comment">//给String扩展execute()函数</span></span><br><span class="line">    <span class="keyword">val</span> runtime = Runtime.getRuntime()</span><br><span class="line">    <span class="keyword">return</span> runtime.exec(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后给Process类扩展一个text()函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Process.<span class="title">text</span><span class="params">()</span></span>:String()&#123;</span><br><span class="line">    <span class="keyword">var</span> output=<span class="string">""</span></span><br><span class="line">    <span class="keyword">val</span> inputStream = <span class="keyword">this</span>.inputStream</span><br><span class="line">    <span class="keyword">val</span> isr = InputStreamReader(inputStream)</span><br><span class="line">    <span class="keyword">val</span> reader = BufferedReader(isr)</span><br><span class="line">    <span class="keyword">var</span> line:String?=<span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span>(line!=<span class="literal">null</span>)&#123;</span><br><span class="line">       line = reader.readLine()</span><br><span class="line">       output+ = line+<span class="string">"\n"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了上面两个简单的扩展函数之后，就可以在下面的测试代码中像Groovy一样执行终端命令了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> p =<span class="string">"ls-al"</span>.execute()</span><br><span class="line"><span class="keyword">val</span> exitCode = p.waitFor()</span><br><span class="line"><span class="keyword">val</span> text = p.text()</span><br><span class="line">println(exitCode)</span><br><span class="line">println(text)</span><br></pre></td></tr></table></figure>

<p>实际上，通过前面多个实例的学习，我们可以看出Kotlin的扩展函数相当实用。Kotlin语言本身提供的SDK标准库API中其实也大量使用了扩展功能。</p>
<hr>
<h2 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4. 正则表达式"></a>4. 正则表达式</h2><p>我们在Kotlin中除了仍然可以使用Java中的Pattern、Matcher等类之外，Kotlin还提供了一个正则表达式类kotlin\text\regex\Regex.kt，我们通过Regex的构造函数来创建一个正则表达式。</p>
<h3 id="4-1-构造Regex表达式"><a href="#4-1-构造Regex表达式" class="headerlink" title="4.1 构造Regex表达式"></a>4.1 构造Regex表达式</h3><p>使用Regex构造函数如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> r1=Regex(<span class="string">"[a-z]+"</span>)   <span class="comment">//创建一个Regex对象，匹配的正则表达式是[a-z]+</span></span><br><span class="line"><span class="keyword">val</span> r2=Regex(<span class="string">"[a-z]+"</span>,RegexOption.IGNORE_CASE)</span><br></pre></td></tr></table></figure>

<p>其中的匹配选项RegexOption是直接使用的Java类Pattern中的正则匹配选项。</p>
<p>使用String的toRegex()扩展函数如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> r3=<span class="string">"[A-Z]+"</span>.<span class="keyword">to</span><span class="constructor">Regex()</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-Regex-函数"><a href="#4-2-Regex-函数" class="headerlink" title="4.2 Regex 函数"></a>4.2 Regex 函数</h3><p>Regex里面提供了丰富的简单而使用的函数</p>
<p><img src="https://s1.ax1x.com/2020/05/04/Y9DDWn.jpg" alt=""></p>
<hr>
<h4 id="4-2-1-matches-函数"><a href="#4-2-1-matches-函数" class="headerlink" title="4.2.1  matches()函数"></a>4.2.1  matches()函数</h4><p>如果输入的字符串全部匹配正则表达式则返回true，否则返回false。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">([qq args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> r1=Regex(<span class="string">"[a-z]+"</span>)</span><br><span class="line">    r1.matches(<span class="string">"ABCzxc"</span>)  <span class="comment">//其中大写的ABC不匹配，所以返回false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> r2 = Regex(<span class="string">"[a-z]+"</span>,RegexOption.IGNORE_CASE) <span class="comment">//正则表达式，忽略大小写</span></span><br><span class="line">    r2.matches(<span class="string">"ABCzxc"</span>)  <span class="comment">//都是大写字母，满足[A-Z]正则表达式，所以返回true</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> r3=<span class="string">"[A-Z]+"</span>.toRegex()</span><br><span class="line">    r3.matches(<span class="string">"GGMM"</span>)    <span class="comment">//都是大写字母，满足[A-Z]正则表达式，所以返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-containsMatchIn-函数"><a href="#4-2-2-containsMatchIn-函数" class="headerlink" title="4.2.2 containsMatchIn()函数"></a>4.2.2 containsMatchIn()函数</h4><p>如果输入字符串中至少有一个匹配就返回true，如没有匹配就返回false</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> re =Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">   re.containsMatchIn(<span class="string">"012Abc"</span>) <span class="comment">//包含满足条件的就返回true，012满足[0-9]+正则匹配，所以返回true</span></span><br><span class="line">    re.containsMatchIn(<span class="string">"Abc"</span>)  <span class="comment">//没有任何字符满足[0-9]+正则表达式，所欲返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-3-matchEntire-函数"><a href="#4-2-3-matchEntire-函数" class="headerlink" title="4.2.3 matchEntire()函数"></a>4.2.3 matchEntire()函数</h4><p>如果输入字符串全部匹配正则表达式则返回一个MatcherMatchResult对象，否则返回null。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> re=Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">   re.matchEntire(<span class="string">"1234567890"</span>)<span class="comment">//全部满足匹配条件  则返回：kotlin.text.MatcherMatchResult@34d713a2</span></span><br><span class="line">   </span><br><span class="line">   re.matchEntire(<span class="string">"1234567890!"</span>)  <span class="comment">//不全部满足匹配条件，则返回：null</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们可以访问MatcherMatchResult的value属性来获得匹配的值</span></span><br><span class="line">    re.matchEntire(<span class="string">"1234567890"</span>)?.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于matchEntire()函数的返回是MatchResult?可空对象，所以这里使用了安全调用符号 “?.” 。</p>
<hr>
<h4 id="4-2-4-relace-input-CharSequence-replacement-String-String函数"><a href="#4-2-4-relace-input-CharSequence-replacement-String-String函数" class="headerlink" title="4.2.4    relace(input:CharSequence, replacement:String):String函数"></a>4.2.4    relace(input:CharSequence, replacement:String):String函数</h4><p>把输入字符串中匹配的部分替换成replacement的内容。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> re=Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">    println(re.replace(<span class="string">"123456XYZ"</span>,<span class="string">"abc"</span>))  <span class="comment">//将123456替换成abc，打印结果：abcXYZ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-replace-input-CharSequence-transform-MatchResult-gt-CharSequence-String函数"><a href="#4-2-5-replace-input-CharSequence-transform-MatchResult-gt-CharSequence-String函数" class="headerlink" title="4.2.5  replace(input:CharSequence,transform:(MatchResult)-&gt;CharSequence):String函数"></a>4.2.5  replace(input:CharSequence,transform:(MatchResult)-&gt;CharSequence):String函数</h4><p>replace()函数签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">replace(input:CharSequence,transform:(MatchResult)-&gt;CharSequence):String</span><br></pre></td></tr></table></figure>

<p>replace()函数的功能是把输入字符串中匹配到的值，用函数transform()映射之后的新值进行替换.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(agrs:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> re=Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">    println(re.replace(<span class="string">"9XYZ8"</span>,&#123;(it.value.toInt()*it.value.toInt()).toString()&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9XYZ8中数字9和8是匹配正则表达式[0-9]+的内容，它们分别被transform()函数映射(it.value.Int()*it.value.Int())的新值81和64所替换。(在IDEA中跑上段程序，发现特别的慢，没有看到最终结果)</p>
<hr>
<h4 id="4-2-6-find-函数"><a href="#4-2-6-find-函数" class="headerlink" title="4.2.6   find()函数"></a>4.2.6   find()函数</h4><p>返回输入字符串中第一个匹配的MatcherMatchResult对象。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">      <span class="keyword">val</span> re = Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">      println(re.find(<span class="string">"123XYZ987abcd7777"</span>)?.value)  <span class="comment">//打印结果：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-7-findAll-函数"><a href="#4-2-7-findAll-函数" class="headerlink" title="4.2.7  findAll()函数"></a>4.2.7  findAll()函数</h4><p>返回输入字符串中所有匹配值得MatchResult的序列。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     <span class="keyword">val</span> re=Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">     re.findAll(<span class="string">"123XYZ987abcd7777"</span>)</span><br><span class="line">     re.findAll(<span class="string">"123XYZ987abcd7777"</span>).forEach&#123;print(it.value+<span class="string">"\n"</span>)&#125;</span><br><span class="line">    <span class="comment">/*打印结果：</span></span><br><span class="line"><span class="comment">    123</span></span><br><span class="line"><span class="comment">    987</span></span><br><span class="line"><span class="comment">    7777*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-使用Java的正则表达式类"><a href="#4-3-使用Java的正则表达式类" class="headerlink" title="4.3  使用Java的正则表达式类"></a>4.3  使用Java的正则表达式类</h3><p>除了前面Kotlin提供的函数之外，在Kotlin中仍然可以使用Java正则表达式的API。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;    <span class="comment">//在kotlin文件中使用Java的正则表达式</span></span><br><span class="line">    <span class="keyword">val</span> re =Regex(<span class="string">"[0-9]+"</span>)</span><br><span class="line">    <span class="keyword">val</span> p=re.toPattern()</span><br><span class="line">    <span class="keyword">val</span> m=p.matcher(<span class="string">"888ABC999"</span>)</span><br><span class="line">    <span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">        <span class="keyword">val</span> d=m.group()</span><br><span class="line">        println(d)   <span class="comment">//输出 888  999</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-多线程编程"><a href="#5-多线程编程" class="headerlink" title="5. 多线程编程"></a>5. 多线程编程</h2><p>Kotlin中没有synchronized、volatile关键字。Kotlin类的Any类似于Java的Object，但是没有wait()、notify()和notifyAll()方法。</p>
<p>那么并发如何在Kotlin中工作呢？放心，Kotlin既然是站在Java的肩膀上，当然少不了对多线程编程的支持–Kotlin通过封装Java中的线程类，建华路我们的编码。同时我们也可以使用一些特定的注解，直接使用Java中的同步关键字等。</p>
<hr>
<h3 id="5-1-创建线程"><a href="#5-1-创建线程" class="headerlink" title="5.1 创建线程"></a>5.1 创建线程</h3><p>我们在Java中通常有两种方法创建线程：</p>
<p>扩展Thread类或者进行实例化并通过构造函数传递一个Runnable。因为我们可以很容易地在Kotlin中使用Java类，所以这个两个方式都可以使用。</p>
<ol>
<li><p>使用对象表达式创建</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span>:Thread()&#123;   <span class="comment">//object对象表达式</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">         println(<span class="string">"A使用Thread对象表达式：<span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用Lambda表达式</p>
<p>下面是如何将一个Runnable传递给一个新创建的Thread实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Thread(&#123;   <span class="comment">//Lambda表达式</span></span><br><span class="line">      Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">      println(<span class="string">"B使用Lambda表达式：<span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure>

<p>我们在这里看不到Runnable，在Kotlin中可以直接使用上面的Lambda表达式来表达。</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>使用Kotlin封装的Thread()函数</p>
<p>例如，我们写了下面一段线程的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> t=Thread(&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">    println(<span class="string">"C使用Lambda表达式:<span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">t.isDaemon=<span class="literal">false</span></span><br><span class="line">t.name=<span class="string">"CThread"</span></span><br><span class="line">t.priority=<span class="number">3</span></span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p>后面的四行可以说是样板化的代码。在Kotlin中把这样的操作封装简化了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">thread(start=<span class="literal">true</span>,isDaemon=<span class="literal">false</span>,name=<span class="string">"DTread"</span>,priority=<span class="number">3</span>)&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">"D使用Kotlin封装的函数thread():<span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码显得更加简洁了。事实上，Thread()函数就是对我们编程实践中经常用到的样板化的代码进行了抽象封装，它的实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">thread</span><span class="params">(start:<span class="type">Boolean</span>=<span class="literal">true</span>,isDaemon:<span class="type">Boolean</span>=<span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">contextClassLoader:</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="type">ClassLoder</span>?=<span class="literal">null</span>,name:<span class="type">String</span>?=<span class="literal">null</span>,priority:<span class="type">Int</span>=<span class="number">-1</span>,block:()</span></span></span><br><span class="line"><span class="function"><span class="params">-&gt;<span class="type">Unit</span>():<span class="type">Thread</span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="type">val</span> <span class="type">thread</span> = <span class="keyword">object</span>:<span class="type">Thread</span>()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="type">public</span> <span class="type">override</span> <span class="type">fun</span> <span class="type">run</span>()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="type">block</span>()</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="type">if</span>(<span class="type">isDaemon</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="type">thread</span>.<span class="type">isDaemon</span>=<span class="literal">true</span></span></span></span><br><span class="line"><span class="function"><span class="params">      </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">if</span>(priority&gt;<span class="number">0</span>)</span></span></span><br><span class="line">      thread.priority=priority</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(name!=<span class="literal">null</span>)</span><br><span class="line">     thread.name=name</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(contextClassLoader!=<span class="literal">null</span>)</span><br><span class="line">     thread.contextClassLoader = contextClassLoader</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span>(start())</span><br><span class="line">     thread.start()</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> thread</span><br><span class="line">      </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这只是一个使用非常方便的包装函数，简单、使用。从上面的例子中可以看出，Kotlin通过扩展Java的线程API，简化了样板化代码</p>
</li>
</ol>
<hr>
<h3 id="5-2-同步方法和块"><a href="#5-2-同步方法和块" class="headerlink" title="5.2  同步方法和块"></a>5.2  同步方法和块</h3><p>synchronized不是Kotlin中的关键字，它替换为@Synchronized注解。Kotlin中的同步方法的声明如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="function"><span class="keyword">fun</span> <span class="title">appendFile</span><span class="params">(text:<span class="type">String</span>,dextFile:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">val</span> f = File(destFile)</span><br><span class="line">      <span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">          f.createNewFile()</span><br><span class="line">      &#125;</span><br><span class="line">     f.appendText(text,Charset.defaultCharset())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Synchronized注解与Java中的synchronized具有相同的效果，即会将JVM方法标记为同步。</p>
<p>对于同步块，我们使用synchronized()函数，它使用锁作为参数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appendFileSync</span><span class="params">(text:<span class="type">String</span>,destFile:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> f = File(destFile)</span><br><span class="line">    <span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">         f.createNewFile()</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">        f.appendText(text,Charset.defaultCharset())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized()函数与Java的语法基本一样，大家用起来会觉得很熟悉。</p>
<hr>
<h3 id="5-3-可变字段"><a href="#5-3-可变字段" class="headerlink" title="5.3   可变字段"></a>5.3   可变字段</h3><p>同样地，Kotlin中没有volatile关键字，但是有@Volatile注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> running = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">   running = <span class="literal">true</span> </span><br><span class="line">   thread(start=<span class="literal">true</span>)&#123;</span><br><span class="line">       <span class="keyword">while</span>(running)&#123;</span><br><span class="line">           println(<span class="string">"Still running: <span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">     running=<span class="literal">false</span></span><br><span class="line">     println (<span class="string">"Stopped:<span class="subst">$&#123;Thread.currentThread()&#125;</span>"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-Kotlin-Spring-Boot-爬虫Web应用"><a href="#6-Kotlin-Spring-Boot-爬虫Web应用" class="headerlink" title="6.  Kotlin+Spring Boot 爬虫Web应用"></a>6.  Kotlin+Spring Boot 爬虫Web应用</h2><p><a href="https://gihub.com/AK-47-D/cms-spider" target="_blank" rel="noopener">可参考源码 </a></p>
]]></content>
      <categories>
        <category>kotlin学习</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin操作符与重载</title>
    <url>/2020/04/18/kotlin%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="Kotlin操作与重载"><a href="#Kotlin操作与重载" class="headerlink" title="Kotlin操作与重载"></a>Kotlin操作与重载</h1><a id="more"></a>

<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="left">标题</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最高级</td>
<td align="left">后缀(Postfix)</td>
<td>++，–，.，?.，？</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">前缀(Prefix)</td>
<td>-，+，++，–，！，labelDefinition@</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">右手类型运算(Type RHS，right-hand side class type (RHS))</td>
<td>:，as，as?</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">乘除取余(Multiplicative)</td>
<td>*，/，%</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">加减(Additive)</td>
<td>+，-</td>
</tr>
<tr>
<td align="center">(优先级往下依次递减)</td>
<td align="left">区间范围(Range)</td>
<td>..</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">Infix 函数</td>
<td>例如，给Int定义扩展 infix fun Int.shl(x:Int):Int{…}，这样调用      1 shl 2，等同于1.shl(2)</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">Elvis操作符</td>
<td>?:</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">命名检查符(Named checks)</td>
<td>in，!in，is，!is</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">比较大小(Comparison)</td>
<td>&lt;，&gt;，&lt;=，&gt;=</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">相等性判断(Equality)</td>
<td>==，!=，===，!==</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">与(Conjunction)</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">或(Disjunction)</td>
<td>||</td>
</tr>
<tr>
<td align="center">最低</td>
<td align="left">赋值(Assignment)</td>
<td>=，+=，-=，*=，/=，%=</td>
</tr>
</tbody></table>
<p>kotlin重载操作符的函数需要使用operator修饰符标记，中缀操作符函数使用infix修饰符标记。</p>
<h2 id="1-1-一元操作符"><a href="#1-1-一元操作符" class="headerlink" title="1.1 一元操作符"></a>1.1 一元操作符</h2><p>一元操作符有前缀操作符、递增和递减操作符等。</p>
<h3 id="1-1-1-前缀操作符"><a href="#1-1-1-前缀操作符" class="headerlink" title="1.1.1 前缀操作符"></a>1.1.1 前缀操作符</h3><p>前缀操作符放在操作数的前面，分别如表所示。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
</tbody></table>
<p>一下是重载一元减运算符的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x:<span class="built_in">Int</span>,<span class="keyword">val</span> y:<span class="built_in">Int</span>)          <span class="comment">//声明数据类Point</span></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span>=Point(-x,-y)  <span class="comment">//operator修饰符修饰一个重载操作符函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPointUnaryMinus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p=Point(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> np=-p                <span class="comment">//直接使用unaryMinus()重载函数操作符"-"</span></span><br><span class="line">    println(np)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testPointUnaryMinus()   <span class="comment">//调用函数</span></span><br><span class="line">    <span class="comment">/*输出 Point(x=-1,y=-1)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-递增和递减操作符"><a href="#1-1-2-递增和递减操作符" class="headerlink" title="1.1.2 递增和递减操作符"></a>1.1.2 递增和递减操作符</h3><p>inc()和dec()函数必须返回一个值，它用于赋值给使用++或–操作的变量。前缀和后缀的表达式的返回值是不同的。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a++</td>
<td align="center">a.inc()返回值是a</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()返回值是a</td>
</tr>
<tr>
<td align="center">_</td>
<td align="center">a.inc()返回值是a+1</td>
</tr>
<tr>
<td align="center">–a</td>
<td align="center">a.dec()返回值是a-1</td>
</tr>
</tbody></table>
<h2 id="2-二元操作符"><a href="#2-二元操作符" class="headerlink" title="2. 二元操作符"></a>2. 二元操作符</h2><p>Kotlin中的二元操作符有算术运算符、索引访问操作符、调用操作符、计算并赋值操作符、相等与不相等操作符、Elvis操作符、比较操作符、中缀操作符等。</p>
<h3 id="2-1-算数运算符"><a href="#2-1-算数运算符" class="headerlink" title="2.1 算数运算符"></a>2.1 算数运算符</h3><p>Kotlin算数运算符有加、减、乘、除、取余、范围操作符等。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a+b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a-b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a*b</td>
<td align="center">a.temes(b)</td>
</tr>
<tr>
<td align="center">a/b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a%b</td>
<td align="center">a.rem(b)、a.mod(b)</td>
</tr>
<tr>
<td align="center">a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
</tbody></table>
<h3 id="2-2-字符串的”-”运算符重载"><a href="#2-2-字符串的”-”运算符重载" class="headerlink" title="2.2 字符串的”+”运算符重载"></a>2.2 字符串的”+”运算符重载</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">""</span>+<span class="number">1</span>    <span class="comment">//String 类型重载了加法操作符</span></span><br><span class="line"><span class="number">1</span>+<span class="string">""</span>   <span class="comment">//Int类型没有重载操作符 plus(other:String) 这种形式会报错</span></span><br><span class="line"><span class="number">1</span>.toString()+<span class="string">""</span>  <span class="comment">//先把Int类型的1转换成String再相加1，显示调用toString()函数</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-自定义重载的”-”运算符"><a href="#2-3-自定义重载的”-”运算符" class="headerlink" title="2.3 自定义重载的”+”运算符"></a>2.3 自定义重载的”+”运算符</h3><p>下面使用一个计数类Counter重载的”+”运算符来增加index的计数值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>(<span class="keyword">var</span> index:<span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Counter.<span class="title">plus</span><span class="params">(increment:<span class="type">Int</span>)</span></span>:Counter&#123;</span><br><span class="line">         <span class="keyword">return</span> Counter(index+increment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testCounterIndexPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> a=Counter(<span class="number">1</span>)  <span class="comment">//声明一个Counter对象，初始化为1</span></span><br><span class="line">  <span class="keyword">val</span> ap=a+<span class="number">12</span>       <span class="comment">//调用自定义重载"+"运算符</span></span><br><span class="line">  println(ap)       <span class="comment">//打印变量ap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testCounterIndexPlus()   <span class="comment">//调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：Counter(13)*/</span></span><br></pre></td></tr></table></figure>



<h3 id="2-4-in操作符"><a href="#2-4-in操作符" class="headerlink" title="2.4 in操作符"></a>2.4 in操作符</h3><p>in操作符等价于contains()函数</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a in b</td>
<td align="center">b.contains(a)</td>
</tr>
<tr>
<td align="center">a !in b</td>
<td align="center">!b.contains(a)</td>
</tr>
</tbody></table>
<h3 id="2-5-索引访问操作符"><a href="#2-5-索引访问操作符" class="headerlink" title="2.5  索引访问操作符"></a>2.5  索引访问操作符</h3><p>索引访问操作符方括号[]转换为调用带有适当数量参数的get和set</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a[i]</td>
<td align="center">a.get(i)</td>
</tr>
<tr>
<td align="center">a[i]=b</td>
<td align="center">a.set(i,b)</td>
</tr>
</tbody></table>
<h3 id="2-6-调用操作符"><a href="#2-6-调用操作符" class="headerlink" title="2.6 调用操作符"></a>2.6 调用操作符</h3><p>小括号调用符()转换为调用invoke()，同样带参数调用也会转换为invoke()函数中的参数。</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a()</td>
<td align="center">a.invoke()</td>
</tr>
<tr>
<td align="center">a(i)</td>
<td align="center">a.invoke(i)</td>
</tr>
</tbody></table>
<h3 id="2-7-计算并赋值操作符"><a href="#2-7-计算并赋值操作符" class="headerlink" title="2.7 计算并赋值操作符"></a>2.7 计算并赋值操作符</h3><p>对于赋值操作，例如a+=b，编译器会试着生成a=a+b的代码(这里包含类型检查：a+b的类型必须是a的子类型)。计算并赋值操作符对应的重载函数</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">翻译为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a+=b</td>
<td align="center">a.plusAssign(b)</td>
</tr>
<tr>
<td align="center">a-=b</td>
<td align="center">a.minusAssign(b)</td>
</tr>
<tr>
<td align="center">a*=b</td>
<td align="center">a.timesAssign(b)</td>
</tr>
<tr>
<td align="center">a/=b</td>
<td align="center">a.divAssign(b)</td>
</tr>
<tr>
<td align="center">a%=b</td>
<td align="center">a.modAssign(b)</td>
</tr>
</tbody></table>
<h3 id="2-8-相等与不相等操作符"><a href="#2-8-相等与不相等操作符" class="headerlink" title="2.8 相等与不相等操作符"></a>2.8 相等与不相等操作符</h3><p>Kotlin中 有两种类型的相等性：</p>
<ul>
<li><p>引用相等===！==(两个引用指向同一对象)；</p>
</li>
<li><p>结构相等==!=(使用equals()判断)</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a==b</td>
<td>a?.equals(b)?:(b=null)</td>
</tr>
<tr>
<td>a!=b</td>
<td>!(a?.equals(b)?:(b==null))</td>
</tr>
</tbody></table>
<p>“==” 操作符有些特殊：它被翻译成一个复杂的表达式，用于筛选null值。意思是：如果a不是null则调用equals(Any?)函数并返回其值；否则(即a===null)就计算b===null的值并返回。</p>
<p>注意：===和 !==不可重载</p>
</li>
</ul>
<h3 id="2-9-Elvis-操作符？"><a href="#2-9-Elvis-操作符？" class="headerlink" title="2.9 Elvis 操作符？"></a>2.9 Elvis 操作符？</h3><p>在kotlin中，Elvis操作符特定是跟null进行比较。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">y=x?:<span class="number">0</span>    <span class="comment">//使用Elvis操作符?:</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">val</span> y=<span class="keyword">if</span>(x!==<span class="literal">null</span>)x <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>主要用来作null安全性检查。</p>
<p>Kotlin中没有这样的三元符号true?1:0取而代之的是if(true)1 else 0. 而Elvis操作符算是精简版的三元运算符。</p>
<p>在java中使用的三元运算符的语法通常要重复变量两次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">"Elvis Presley"</span>;</span><br><span class="line">String displayName=(name!=<span class="keyword">null</span>)name:<span class="string">"Unknown"</span> <span class="comment">//java中的三元操作符</span></span><br></pre></td></tr></table></figure>

<p>可以使用Elvis操作符取而代之：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"Elvis Presley"</span></span><br><span class="line"><span class="keyword">val</span> displayName=name?:<span class="string">"Unknown"</span> <span class="comment">//使用Elvis操作符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> x=<span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> y=x?:<span class="number">0</span>    <span class="comment">//使用Elvis操作符</span></span><br><span class="line">println(y)    <span class="comment">//等价逻辑：if(x!==null) x else 0，此处x===null, 所以选择else分支，返回0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x=<span class="literal">false</span></span><br><span class="line"><span class="keyword">val</span> y=x?:<span class="number">0</span></span><br><span class="line">println(y) <span class="comment">//x!==null,所以y的值为x，即为false</span></span><br></pre></td></tr></table></figure>



<h3 id="2-10-比较操作符"><a href="#2-10-比较操作符" class="headerlink" title="2.10 比较操作符"></a>2.10 比较操作符</h3><p>Kotlin中所有的比较表达式都转换为对compareTo()函数的调用，这个函数需要返回Int值。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>翻译为</th>
</tr>
</thead>
<tbody><tr>
<td>a&gt;b</td>
<td>a.compareTo(b)&gt;0</td>
</tr>
<tr>
<td>a&lt;b</td>
<td>a.compareTo(b)&lt;0</td>
</tr>
<tr>
<td>a&gt;=b</td>
<td>a.compareTo(b)&gt;=0</td>
</tr>
<tr>
<td>a&lt;=b</td>
<td>a.compareTo(b)&lt;=0</td>
</tr>
</tbody></table>
<h3 id="2-11-用infix函数自定义中缀操作符"><a href="#2-11-用infix函数自定义中缀操作符" class="headerlink" title="2.11 用infix函数自定义中缀操作符"></a>2.11 用infix函数自定义中缀操作符</h3><p>我们可以通过自定义infix函数来实现中缀操作符。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> age:<span class="built_in">Int</span>)  <span class="comment">//声明Person数据类</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Person.<span class="title">grow</span><span class="params">(years:<span class="type">Int</span>)</span></span>:Person&#123; <span class="comment">//声明Person类型的中缀操作符函数</span></span><br><span class="line">    <span class="keyword">return</span> Person(name,age+years)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> person=Person(<span class="string">"kim"</span>,<span class="number">20</span>)</span><br><span class="line">    println(person.grow(<span class="number">5</span>))  <span class="comment">//直接调用函数</span></span><br><span class="line">    println(person grow <span class="number">5</span>)   <span class="comment">//中缀表达式调用方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    testPerson()</span><br><span class="line">    <span class="comment">/*结果为Person(name=kim,age=25)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin知识点记录</title>
    <url>/2020/04/04/kotlin%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>kotlin学习记录</p>
<a id="more"></a>

<p>kotlin和java的使用方法有所区别。Kotlin下载Android Studio后就可以使用。<a href="https://developer.android.com/kotlin/learn" target="_blank" rel="noopener">kotlin文档</a></p>
<p>kotlin使用两个不同的关键字（即val和var）来声明变量。</p>
<ol>
<li>val 用于值从不更改的变量。不能使用val声明的变量重新赋值。就相当于java中的final。</li>
<li>var 用于可以更改的变量。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp: <span class="built_in">Int</span>=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，count是一个Int类型的变量，为其赋予的初始值为10：</p>
<p>Kotlin出了Int类型的，还有Byte、Short、Long、Float和Double、String类型的变量。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name1: String =<span class="string">"kotlin"</span></span><br><span class="line">name1=<span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name2: String =<span class="string">"kotlin"</span></span><br><span class="line">name2=<span class="string">"helloworld"</span></span><br></pre></td></tr></table></figure>

<p>如上例，name1为val，因此name1被赋值后仍是”kotlin”。而name2是var，被赋值后可以改变，因此name2的值变更为”helloword”。</p>
<p>（注：kotlin编译器可根据所赋值的类型来推断类型，kotlin是一种静态类型的语言。String类型的变量也只能调用String类型的函数）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">num.inc()     <span class="comment">//num.inc()的结果为2，但是num的值并不会变，且num++这种方式kotlin不支持</span></span><br><span class="line">num+=<span class="number">1</span>    <span class="comment">//这种方式kotlin是支持的，执行完后，num=2</span></span><br></pre></td></tr></table></figure>

<h2 id="Null安全"><a href="#Null安全" class="headerlink" title="Null安全"></a>Null安全</h2><p>在某些语言中，可以声明引用类型变量而不明确提供初始值。在这些情况下，变量通常包含null值。默认情况下，Kotlin变量不能持有null。下段代码无效：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String =<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>要使变量持有null值，它必须是为null类型。可以在变量类型后面加上？后缀，可以将变量指定为null</p>
<p>如下所示:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String?=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>指定String?类型后，可以将name赋值为null或具体的字符串。</p>
<p>当变量被声明为可空类型后，并不能像非空变量那样被调用。可空类型String？只有使用安全调用符(?.)和非空断言调用符(?)才允许调用其方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: String?=<span class="string">"abc"</span> <span class="comment">//声明一个可以为空的字符串变量name，且是var类型的变量，即后面可以更改其值。</span></span><br><span class="line">name.length    <span class="comment">//以这种形式调用声明的可空变量则是错误的，系统会提示报错</span></span><br><span class="line">name?.length  <span class="comment">//使用安全调用符</span></span><br><span class="line"></span><br><span class="line">name=<span class="literal">null</span>   <span class="comment">//将var可空String变量name赋值为null</span></span><br><span class="line">name?.length <span class="comment">//再次安全调用length方法时，结果将返回null</span></span><br></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在kotlin中，必须在声明对象时初始化对象的属性。这意味着，当获取类的实例时，立即引用它的任何可访问属性。当调用Fragment#onCreateView之前，Fragment中的View对象尚未准备好进行扩充，所以要推迟View的属性初始化。可以使用 lateinit 推迟属性初始化。使用lateinit时，应尽快初始化属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> usernameEditText: EditText</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> passwordEditText: EditText</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> loginButton: Button</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> statusTextView: TextView</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">            usernameEditText = view.findViewById(R.id.username_edit_text)</span><br><span class="line">            passwordEditText = view.findViewById(R.id.password_edit_text)</span><br><span class="line">            loginButton = view.findViewById(R.id.login_button)</span><br><span class="line">            statusTextView = view.findViewById(R.id.status_text_view)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> String accessId;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当变量带有@Nullable注解时，表示它可空，kotlin会将accessId视为String？</p>
<p>要指明变量绝不能为null，则使用@NonNull注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="title">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> String name;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果要修剪name以使其值不包含前导或尾随空格，则可以使用Kotlin的 trim函数。通过几种不同的方式安全地修剪String？。其中一种方式是使用非null断言预算符！！，如下示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name!!.trim()</span><br></pre></td></tr></table></figure>

<p>！！运算符将其左侧的所有内容视为非null，一次，在本例中，将name视为非null String。 如果它左侧表达式的结果为null，则应用会抛出NullPointerException。</p>
<p>更安全的选择是使用安全调用运算符?.   ，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name?.trim()</span><br></pre></td></tr></table></figure>

<p>使用安全调用运算符时，如果 <code>name</code> 不为 null，则 <code>name?.trim()</code> 的结果是一个不带前导或尾随空格的名称值。如果 <code>name</code> 为 null，则 <code>name?.trim()</code> 的结果为 <code>null</code>。这意味着，在执行此语句时，您的应用永远不会抛出 <code>NullPointerException</code>。</p>
<p>虽然安全调用运算符可使您避免潜在的 <code>NullPointerException</code>，但它会将 null 值传递给下一个语句。您可以使用 Elvis 运算符 (<code>?:</code>) 来紧接着处理 null 值的情况，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> account = Account(<span class="string">"name"</span>, <span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">val</span> accountName = account.name?.trim() ?: <span class="string">"Default name"</span></span><br></pre></td></tr></table></figure>

<p>如果 Elvis 运算符左侧表达式的结果为 null，则会将右侧的值赋予 <code>accountName</code>。此方法对于提供本来为 null 的默认值很有用。</p>
<p>您还可以使用 Elvis 运算符提前从函数返回结果，如以下示例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">validateAccount</span><span class="params">(account: <span class="type">Account</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> accountName = account?.name?.trim() ?: <span class="string">"Default name"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// account cannot be null beyond this point</span></span><br><span class="line">        account ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android-kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>spring之IoC(控制反转)和DI(依赖注入)</title>
    <url>/2020/04/28/spring%E4%B9%8BIoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="spring之IoC-控制反转-和DI-依赖注入"><a href="#spring之IoC-控制反转-和DI-依赖注入" class="headerlink" title="spring之IoC(控制反转)和DI(依赖注入)"></a>spring之IoC(控制反转)和DI(依赖注入)</h1><a id="more"></a>

<h2 id="1-什么是spring"><a href="#1-什么是spring" class="headerlink" title="1. 什么是spring"></a>1. 什么是spring</h2><p>  Spring是一个以IoC(Inversion of Control，控制反转)和AOP(Aspect Oriented Progromming)为内核的框架。IoC是Spring的基础。IoC实现的是一种控制，简单地说，就是以前调用new构造方法创建对象，现在变成了使用Spring来创建对象。DI(Dependency Inject，依赖注入)与IoC的含义相同，从两个角度描述同一个概念。简单地说，DI就是对象的属性，已经被注入相关值，直接使用即可。</p>
<h2 id="2-什么是IoC-控制反转"><a href="#2-什么是IoC-控制反转" class="headerlink" title="2. 什么是IoC(控制反转)"></a>2. 什么是IoC(控制反转)</h2><p>IoC(Inversion of control)，译为“控制反转” 或者 “控制倒置” 。</p>
<p>在面向对象传统编程方式中，获取对象的方式通常是用new关键字主动创建一个对象，Spring中的IoC方式对象的生命周期由Spring框架提供的IoC容器来管理，直接从IoC容器中获取一个对象，控制权从应用程序交给了IoC容器。</p>
<p>IoC理论上借助于“第三方” 实现具有依赖关系对象之间的解耦， 即把各个类封装之后，通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，而对象之间没有什么直接联系。</p>
<p>应用程序在没有引入IoC容器之前，对象A依赖对象B，那么A对象在实例化或者运行到某一点的时候。</p>
<p>A对象需要用new主动的来创建B对象。引入IoC之后，对象A获得依赖对象B的过程，由主动行为变为被动行为，即把创建对象的权利交给了IoC容器处理。控制权颠倒过来了，这就是所谓的控制反转。</p>
<p>个人认知：我们将需要的资源(Bean)描述出来，并传递给IoC容器，IoC容器便会自动的帮助我们找到需要的资源。将有依赖的Bean之间关系解耦。并且IoC也可以管理Bean的生命进程，可以延时加载，也可以在Bean定义时做某些事情.</p>
<h2 id="3-什么是DI-依赖注入"><a href="#3-什么是DI-依赖注入" class="headerlink" title="3. 什么是DI(依赖注入)"></a>3. 什么是DI(依赖注入)</h2><p>DI(Dependency Inject)，译为“依赖注入”。所谓依赖注入，就是由IoC容器在运行期间动态地将某种依赖关系注入对象之中。例如，将对象B注入(赋值)给对象A的成员变量。</p>
<p>事实上，依赖注入(DI)和控制反转(IoC)是对一个同一件事情的不同藐视，从某个方面将，就是它们描述的角度不同。依赖注入是从一个应用程序的角度描述，即应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度描述，即容器控制应用程序，由容器反向地向应用程序所需要的外部资源。这里说的外部资源可以是外部实例对象，也可以是外部文件对象等。</p>
<h2 id="4-使用IoC-DI给软件开发带来了多方面的益处。"><a href="#4-使用IoC-DI给软件开发带来了多方面的益处。" class="headerlink" title="4. 使用IoC/DI给软件开发带来了多方面的益处。"></a>4. 使用IoC/DI给软件开发带来了多方面的益处。</h2><p>(1) 可维护性比较好，便于单元测试、调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即，这就是组件(compont)之间低耦合或者无耦合带来的好处。</p>
<p>(2)每个开发团队的成员都只需要关注自己要实现的业务逻辑，完全不用关心其他人的工作进展，因为你的任务跟别人没有关系，你的任务可以单独测试，不用依赖于别人的组件，在也不会扯不清责任了。所以，在一个大中型项目中，团队成员分工明确，责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将地道大幅度的提高。</p>
<p>(3)可复用性好，我们可以把具有普遍性的常用组件独立出来，反复应用到项目中的其他部分，或者是其他项目，当然这也是面向对象的基本特征。显然，IoC更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现都可以插接到支持此标准的模块中。</p>
<p>(4) 生成对象的方式转为外置方式，就是把对象生成放在配置文件中进行定义。这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拔的特性。</p>
]]></content>
      <categories>
        <category>spring学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis下载和安装</title>
    <url>/2020/05/27/Redis%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Redis下载和安装"><a href="#Redis下载和安装" class="headerlink" title="Redis下载和安装"></a>Redis下载和安装</h1><a id="more"></a>

<h2 id="1-Redis-的下载"><a href="#1-Redis-的下载" class="headerlink" title="1. Redis 的下载"></a>1. Redis 的下载</h2><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">Redis下载地址</a></p>
<p>选择对应的版本下载和安装</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tAQ9oT.png" alt=""></p>
<h2 id="2-启动Redis"><a href="#2-启动Redis" class="headerlink" title="2. 启动Redis"></a>2. 启动Redis</h2><p>ctr+R键打开cmd窗口输入redis-server.exe(确保Redis环境变量已配置)，如果没有配置环境变量需要在cmd窗口中cd到相应的路径下后输入。</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tAQx9e.png" alt="启动Redis成功"></p>
<p>启动后切忌不要关闭启动的窗口，重新开一个cmd窗口进行连接，启动窗口关闭后Redis服务器也就会关闭。</p>
<h2 id="3-连接Redis"><a href="#3-连接Redis" class="headerlink" title="3.连接Redis"></a>3.连接Redis</h2><p>打开一个新的窗口，输入redis-cli.exe -h 127.0.0.1 -p 6379   </p>
<p><img src="https://s1.ax1x.com/2020/05/27/tA1pPU.png" alt=""></p>
<p>显示host和端口号即为成功，默认端口号为6379.</p>
<h2 id="4-java中利用jedis连接redis"><a href="#4-java中利用jedis连接redis" class="headerlink" title="4. java中利用jedis连接redis"></a>4. java中利用jedis连接redis</h2><p>maven依赖如下   此处为jdk1.7   redis3.2  jedis2.4是没有问题的(如有报错尝试更换版本)</p>
<p><img src="https://s1.ax1x.com/2020/05/27/tA1DLn.png" alt=""></p>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin流程控制语句</title>
    <url>/2020/04/16/kotlin%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="Kotlin流程控制语句"><a href="#Kotlin流程控制语句" class="headerlink" title="Kotlin流程控制语句"></a>Kotlin流程控制语句</h1><a id="more"></a>

<h2 id="1-if表达式"><a href="#1-if表达式" class="headerlink" title="1. if表达式"></a>1. if表达式</h2><p>if是一个表达式，即它会返回一个值(跟scala一样)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> max=<span class="keyword">if</span>(a&gt;b) a <span class="keyword">else</span> b  <span class="comment">//max定义为val类型，因为max后面不会被改变当a&gt;b时，max=a</span></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">     println(<span class="string">"max="</span>+max(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if的分支可以是代码块，最后一行的表达式作为该块的值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">   <span class="keyword">val</span> max=<span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">     println(<span class="string">"Max is a"</span>)</span><br><span class="line">     a</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">"Max is b"</span>)</span><br><span class="line">      b</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin没有类似true?1:0这样的三元表达式。对应的写法是使用if…else语句。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLeapYear</span><span class="params">(year:<span class="type">Int</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLeapYear:<span class="built_in">Boolean</span></span><br><span class="line">  <span class="keyword">if</span>((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))&#123;</span><br><span class="line">    isLeapYear=<span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     isLeapYear=<span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isLeapYear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  println(isLeapYear(<span class="number">2017</span>))</span><br><span class="line">  println(isLeapYear(<span class="number">2020</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-when表达式"><a href="#2-when表达式" class="headerlink" title="2. when表达式"></a>2. when表达式</h2><p>when 表达式类似于switch…case表达式。when会对所有的分支进行检查直到有一个条件被满足。但相比switch而言，when语句的功能要更加强大、灵活。when语句的每一个分支也可以是一个代码块，它的值是块中最后的表达式的值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">casesWhen</span><span class="params">(obj:<span class="type">Any</span>?)</span></span>&#123;</span><br><span class="line">    <span class="keyword">when</span>(obj)&#123;</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> -&gt;println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这是0-9之间的数字"</span>)<span class="comment">//若有多个分支条件放在一起，用逗号隔开</span></span><br><span class="line">        <span class="string">"hello"</span>-&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这个是字符串hello"</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Char</span> -&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;这个是Char类型数据"</span>)<span class="comment">//is是类型判断</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">"<span class="subst">$&#123;obj&#125;</span>===&gt;else类似于java中的case-swich中的default"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    casesWhen(<span class="number">6</span>)</span><br><span class="line">    casesWhen(<span class="string">"hello"</span>)</span><br><span class="line">    casesWhen(<span class="string">'X'</span>)</span><br><span class="line">    casesWhen(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以检测一个值在in或不在!in一个区间或者集合中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">casewhen</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> x=<span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> validNumbers = arrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">when</span>(x)&#123;</span><br><span class="line">     <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> -&gt;print(<span class="string">"x is in the range"</span>)  <span class="comment">//是否在范围1..10</span></span><br><span class="line">     <span class="keyword">in</span> validNumbers -&gt;print(<span class="string">"x is valid"</span>)   <span class="comment">//是否在数据arrayof(1,2,3)中</span></span><br><span class="line">     !<span class="keyword">in</span> <span class="number">10</span>..<span class="number">20</span> -&gt; print(<span class="string">"x is outside the range"</span>) <span class="comment">//不在范围10..20中</span></span><br><span class="line">     <span class="keyword">else</span> -&gt; print(<span class="string">"none of the above"</span>)  <span class="comment">//默认路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3. for循环"></a>3. for循环</h2><p>如果想要通过索引遍历一个数组或者一个list，可以这么做：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices)&#123;</span><br><span class="line"><span class="comment">//array.indices存储了数组array的下标序列</span></span><br><span class="line">  print(array[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，array.indices持有数组的下标列表。我们也可以使用函数withIndex()来遍历下标与对应的因素：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((index,value) <span class="keyword">in</span> array.withIndex())&#123;   <span class="comment">//带下标index来访问数据</span></span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另外，范围(Ranges)表达式也可用于循环中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>)&#123;  <span class="comment">//等同于1&lt;=i&amp;&amp;i&lt;=10</span></span><br><span class="line">  println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>..<span class="number">10</span>).forEach&#123;print(it)&#125;    <span class="comment">//上面代码简写</span></span><br></pre></td></tr></table></figure>

<h2 id="4-while循环"><a href="#4-while循环" class="headerlink" title="4. while循环"></a>4. while循环</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="number">10</span></span><br><span class="line">  <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    x-</span><br><span class="line">    println(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="number">10</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">     y=y+<span class="number">1</span></span><br><span class="line">     println(y)</span><br><span class="line">  &#125;<span class="keyword">while</span>(y&lt;<span class="number">20</span>)  <span class="comment">//while判断条件，y的作用域包含此处。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="5-return返回"><a href="#5-return返回" class="headerlink" title="5. return返回"></a>5. return返回</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=&#123;a+b&#125; <span class="comment">//直接使用表达式声明函数，注意到这里的&#123;&#125;表示</span></span><br><span class="line"><span class="comment">//当调用sumf(1,1)时，返回类型是一个函数()-&gt;kotlin.Int</span></span><br><span class="line"><span class="comment">//调用sumf(1,1).invoke()  返回的结果是2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">maxf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=&#123;<span class="keyword">if</span>(a&gt;b)a <span class="keyword">else</span> b&#125;</span><br><span class="line"><span class="comment">//maxf(2,6) 的返回类型也是一个函数</span></span><br><span class="line"><span class="comment">//使用invoke()函数调用maxf(2,6)函数，返回值为6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sumf(1,1).invoke()和sumf(1,1)()的调用方式是等价的</span></span><br><span class="line"><span class="comment">/*在Kotlin中，()操作符对应的是类的重载函数，如invoke()我们使用()运算符来调用函数*/</span></span><br></pre></td></tr></table></figure>



<p>kotlin中return语句会从最近的函数或匿名函数中返回，但是在Lambda表达式中遇到return语句时，则直接返回最近的外层函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = intArrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//声明一个Int数值</span></span><br><span class="line">intArray.forEach&#123;</span><br><span class="line">  <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span> <span class="comment">//在Lambda表达式中的return直接返回最近的外层函数</span></span><br><span class="line">  println(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因此，结果为：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">当it为3时就会return，类似于break的作用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> 当给forEach传入一个匿名函数fun(a:Int)，这个匿名函数里的return的语句不会跳出forEach循环，类似于continue语句的效果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = intArrayof(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//声明一个Int数值</span></span><br><span class="line">intArray.forEach&#123; <span class="function"><span class="title">fun</span><span class="params">(a:<span class="type">Int</span>)</span></span>&#123;  <span class="comment">//这是一个匿名函数</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">3</span>) <span class="keyword">return</span>   <span class="comment">//从最近的函数中返回，也就是上面的匿名函数fun(a:Int)，但是循环会继续，类似于continue语句。</span></span><br><span class="line">    println(a)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因此，结果为：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">当a为3时，从匿名函数中返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-1-标签-label"><a href="#5-1-标签-label" class="headerlink" title="5.1  标签(label)"></a>5.1  标签(label)</h2><p>在Kotlin中任何表达式都可以用标签(label)来标记。标签的格式为标识符后跟@符号，如abc@、——isOK@都是有效的标签。我们可以使用Label标签来控制return、break或continue语句的跳转(jump)行为。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array= intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    array.forEach <span class="symbol">here@</span>&#123; <span class="comment">//定义here@标签</span></span><br><span class="line">        <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@here</span> <span class="comment">//执行指令跳转到Lambda表达式标签here@处当it=3时，则会跳转下一个it=4的遍历循环。</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果则是输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>另外可以使用隐式标签、更加方便。该标签与接收该Lambda的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> array= intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    array.forEach&#123; </span><br><span class="line">        <span class="keyword">if</span>(it==<span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">//返回@forEach处继续下一个循环</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果则是输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>throw表达式</p>
<p>在kotlin中throw是表达式，它的类型是特殊类型Nothing。该类型没有值，与java中的void意思一样。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fail</span><span class="params">(msg:<span class="type">String</span>)</span></span>:<span class="built_in">Nothing</span>&#123;<span class="keyword">throw</span> IllegalArgumentException(msg)&#125;</span><br><span class="line"><span class="comment">//返回值为Nothing表示该函数永远不会返回值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">   fail(<span class="string">"nihao"</span>)  <span class="comment">//调用fail函数，将会直接抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.IllegalArgumentException: nihao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果把一个throw表达式的值赋给一个变量，需要显示声明类型为Nothing，代码示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ex=<span class="keyword">throw</span> Exception(<span class="string">"nihao"</span>) <span class="comment">//ex需要显示声明类型为Nothing，否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ex:<span class="built_in">Nothing</span>=<span class="keyword">throw</span> Exception(<span class="string">"nihao"</span>)</span><br><span class="line"><span class="comment">/*结果为：</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.Exception: nihao</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>计网+操作系统</title>
    <url>/2020/09/20/%E8%AE%A1%E7%BD%91-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2020/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据结构与算法-java"><a href="#数据结构与算法-java" class="headerlink" title="数据结构与算法(java)"></a>数据结构与算法(java)</h1><a id="more"></a>

<h2 id="字节跳动真题"><a href="#字节跳动真题" class="headerlink" title="*字节跳动真题"></a>*字节跳动真题</h2><h2 id="1题"><a href="#1题" class="headerlink" title="1题"></a>1题</h2><p>为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1&lt;=L2&lt;=R2&lt;=R1)。     </p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入： 第<span class="number">1</span>行为n代表用户的个数 第<span class="number">2</span>行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第<span class="number">3</span>行为一个正整数q代表查询的组数  第<span class="number">4</span>行到第（<span class="number">3</span>+q）行，每行包含<span class="number">3</span>个整数l,r,k代表一组查询，即标号为l&lt;=i&lt;=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n &lt;= <span class="number">300000</span>,q&lt;=<span class="number">300000</span> k是整型</span><br></pre></td></tr></table></figure>





<h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：一共q行，每行一个整数代表喜好值为k的用户的个数</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">样例解释:</span><br><span class="line">有<span class="number">5</span>个用户，喜好值为分别为<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">3</span>、<span class="number">5</span>，</span><br><span class="line">第一组询问对于标号[<span class="number">1</span>,<span class="number">2</span>]的用户喜好值为<span class="number">1</span>的用户的个数是<span class="number">1</span></span><br><span class="line">第二组询问对于标号[<span class="number">2</span>,<span class="number">4</span>]的用户喜好值为<span class="number">5</span>的用户的个数是<span class="number">0</span></span><br><span class="line">第三组询问对于标号[<span class="number">3</span>,<span class="number">5</span>]的用户喜好值为<span class="number">3</span>的用户的个数是<span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">       Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        <span class="comment">//定义一个map，将喜好值作为key，key对应的用户标号组成的链表作为value</span></span><br><span class="line">       <span class="keyword">int</span> users = scan.nextInt();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=users;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> fav = scan.nextInt();</span><br><span class="line">           <span class="keyword">if</span>(!map.containsKey(fav))&#123; <span class="comment">//判断输入的查找的key是否在map中，如果不在</span></span><br><span class="line">               List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">               <span class="comment">//新建一个链表，用来存放用户编号</span></span><br><span class="line">               list.add(i);  <span class="comment">//加入到链表中去</span></span><br><span class="line">               map.put(fav,list);  <span class="comment">//将编号放入到map中去</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               List&lt;Integer&gt; list = map.get(fav); </span><br><span class="line">               <span class="comment">//如果之前存在则，则将key对应的链表赋值给list变量，然后在添加新的用户标号</span></span><br><span class="line">               <span class="comment">//因为用户的标号都是按大小顺序的，所以不要对链表进行排序。</span></span><br><span class="line">               list.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> group = scan.nextInt();  <span class="comment">//获取查询数量</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;group;j++)&#123;</span><br><span class="line">           <span class="keyword">int</span> start = scan.nextInt();  <span class="comment">//查询起始编号</span></span><br><span class="line">           <span class="keyword">int</span> end = scan.nextInt();   <span class="comment">//查询结束编号</span></span><br><span class="line">           <span class="keyword">int</span> keynum = scan.nextInt();  <span class="comment">//查询关键key</span></span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           List&lt;Integer&gt; list = map.get(keynum);  <span class="comment">//查找到输入key对应的链表</span></span><br><span class="line">           <span class="keyword">if</span>(list!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(list.get(i)&gt;=start&amp;&amp;list.get(i)&lt;=end)&#123; </span><br><span class="line">                       <span class="comment">//确定查询区域范围，在该范围的则只需要count++</span></span><br><span class="line">                       count++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(count);  </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*说明下 list!=null,此处用null来判断是因为：</span></span><br><span class="line"><span class="comment">如果输入的key不存在链表中，则赋值后 list是未分配内存空间的，</span></span><br><span class="line"><span class="comment">1.list!=null,是没有分配空间的</span></span><br><span class="line"><span class="comment">2.list.isEmpty()则是分配了内存空间的，绝对的空，只是值为空，即(值=null)</span></span><br><span class="line"><span class="comment">3.list==""，分配了内存，只是相对的空，字符串为空，(值=空)</span></span><br><span class="line"><span class="comment">故很显然这里应当使用list!=null才是对的</span></span><br></pre></td></tr></table></figure>

<h2 id="字节跳动2018校招大数据方向-第一批-编程题2"><a href="#字节跳动2018校招大数据方向-第一批-编程题2" class="headerlink" title="*字节跳动2018校招大数据方向(第一批)[编程题2]"></a>*字节跳动2018校招大数据方向(第一批)[编程题2]</h2><p>给定一个数组序列，  给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个： </p>
<p>  区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列  [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">6</span>] = <span class="number">6</span> * <span class="number">6</span> = <span class="number">36</span>;</span><br><span class="line">[<span class="number">2</span>] = <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span>;</span><br><span class="line">[<span class="number">1</span>] = <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">[<span class="number">6</span>,<span class="number">2</span>] = <span class="number">2</span> * <span class="number">8</span> = <span class="number">16</span>;</span><br><span class="line">[<span class="number">2</span>,<span class="number">1</span>] = <span class="number">1</span> * <span class="number">3</span> = <span class="number">3</span>;</span><br><span class="line">[<span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>] = <span class="number">1</span> * <span class="number">9</span> = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>  从上述计算可见选定区间 [6] ，计算值为 36， 则程序输出为 36。  区间内的所有数字都在[0, 100]的范围内; </p>
<h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="*输入描述："></a>*输入描述：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一行输入数组序列长度n，第二行输入数组序列。</span><br><span class="line">对于 <span class="number">50</span>%的数据,  <span class="number">1</span> &lt;= n &lt;= <span class="number">10000</span>;</span><br><span class="line">对于 <span class="number">100</span>%的数据, <span class="number">1</span> &lt;= n &lt;= <span class="number">500000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="*输出描述："></a>*输出描述：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出数组经过计算后的最大值</span><br></pre></td></tr></table></figure>

<h3 id="输入例子："><a href="#输入例子：" class="headerlink" title="*输入例子："></a>*输入例子：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>*输出例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路-编程代码"><a href="#解题思路-编程代码" class="headerlink" title="*解题思路+编程代码"></a>*解题思路+编程代码</h3><p>这道题就是相当于固定最小值，然后找最小值的最长区间，那么以这个最小值所在的最长区间，就是该最小值对应计算后的最大值，然后再去比较，选出最大值输出：</p>
<p>本道题的话，我看有人说与letcode上的84题思路差不多，主要就是利用单调不减的”栈”的先入后出的特点： 去比较栈顶元素和当前元素的大小，如果栈顶元素大于当前元素，则出栈。并计算其对应的值，也就是栈中栈顶位置的下标对应的元素肯定比栈中左边的值都要大，如果也比当前值大的话，就可以确定以栈顶下标对应的元素为最小值的最大区间，然后计算出该最小值对应的最大值。</p>
<p>难点：就是在寻找最长区间时维护的栈stack的几种判断，</p>
<p>再就是计算最小值，最长区间时，怎样计算所有区间元素的和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一  用第二个栈来维护sum  时间复杂度最坏情况O(2n),空间复杂：O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//元素的相应位置不能变   </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            num[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        num[n] = <span class="number">0</span>; <span class="comment">// append 0 to the last position  这里相当于添加哨兵</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        int n = 5;</span></span><br><span class="line"><span class="comment">        int[] num = new int[n + 1];</span></span><br><span class="line"><span class="comment">        Random rand = new Random();</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">            num[i] = rand.nextInt(100) + 1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; sumstack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; num.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.size() == <span class="number">0</span> || num[i] &gt; stack.lastElement()) &#123;<span class="comment">// 如果数组的元素大于栈顶  put it into the stack</span></span><br><span class="line"> </span><br><span class="line">                stack.add(num[i]);</span><br><span class="line">                sumstack.add(tempsum); <span class="comment">// accumlate add</span></span><br><span class="line">                tempsum = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// small than top ele of stack; pop out, and cal the accumate result</span></span><br><span class="line">                <span class="keyword">int</span> temp = stack.pop(); <span class="comment">// the top ele</span></span><br><span class="line">                tempsum += (temp + sumstack.pop());  <span class="comment">// accumate add</span></span><br><span class="line">                result = Math.max(tempsum * temp, result); <span class="comment">// if the max one, otherwise swap</span></span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二 柱形面积求法(letcode-84)+一维前序和(虽然可以解题，但是空间换时间的效率较低 时间：O(n)，空间O(n))</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> len = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        ArrayList&lt;Integer&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">//将不能确定高度的值存入栈中</span></span><br><span class="line">        b.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>&lt;=temp&amp;&amp;temp&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">                array[i] = temp;</span><br><span class="line">                b.add(b.get(i-<span class="number">1</span>)+array[i]);  <span class="comment">//维护一维前序和</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; array[stack.peekLast()]&gt;array[i])&#123;  </span><br><span class="line">                <span class="comment">//当栈顶元素大于当前元素，说明以栈顶为高度的矩形确定，即以栈顶元素为最小值的最长区间已经确定了</span></span><br><span class="line">                temp = array[stack.removeLast()];</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                  sum = b.get(i-<span class="number">1</span>);  <span class="comment">//原来为 width = i;</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sum = b.get(i-<span class="number">1</span>)-b.get(stack.peekLast());  <span class="comment">//原来为 width = i-stack.peekLast()-1; </span></span><br><span class="line">                    <span class="comment">//stack.peekLast(),其中peekLast()返回栈顶元素的值，但不删除栈顶元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,temp*sum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; array[stack.peekLast()]==array[i])&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">             temp = array[stack.removeLast()];</span><br><span class="line">             <span class="keyword">if</span>(stack.isEmpty())&#123;   <span class="comment">//原来为 width = len;</span></span><br><span class="line">                 sum = b.get(len);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 sum = b.get(len)-b.get(stack.peekLast());  <span class="comment">//原来 width = len - stack.peekLast()-1;</span></span><br><span class="line">             &#125;</span><br><span class="line">            max = Math.max(max,temp*sum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="*前缀和"></a>*前缀和</h3><blockquote>
<p><a href="https://www.cnblogs.com/-Ackerman/p/11162651.html" target="_blank" rel="noopener">https://www.cnblogs.com/-Ackerman/p/11162651.html</a></p>
</blockquote>
<p>什么是前缀和？前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。设b[]为前缀和数组，a[]为原数组，根据这句话可以得到前缀和的定义式和递推式：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
<th align="center">递推</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一维前缀和</td>
<td><img src="file:///C:%5CUsers%5CPXN%5CAppData%5CLocal%5CTemp%5Cksohtml17480%5Cwps1.png" alt="img"></td>
<td align="center"><img src="file:///C:%5CUsers%5CPXN%5CAppData%5CLocal%5CTemp%5Cksohtml17480%5Cwps2.png" alt="img"></td>
</tr>
<tr>
<td align="center">二维前缀和</td>
<td><img src="file:///C:%5CUsers%5CPXN%5CAppData%5CLocal%5CTemp%5Cksohtml17480%5Cwps3.png" alt="img"></td>
<td align="center"><img src="file:///C:%5CUsers%5CPXN%5CAppData%5CLocal%5CTemp%5Cksohtml17480%5Cwps4.png" alt="img"></td>
</tr>
</tbody></table>
<h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="[一维前缀和]"></a>[一维前缀和]</h4><p>根据上面的定义，我们可以很容易得到sum[i] = sum[i-1]+a[i] 这样就可以得到前i个数的和  O(n) 前序预处理，O(m)查询</p>
<p>根据上述表达式我们可以以O(1)求出区间[i,j]的区间和</p>
<p>​                                              sum[i,j] = b[j]-b[i-1]</p>
<p>问题1：静态区间求和：</p>
<p>给定大小为n的数组(1&lt;=n&lt;=10^5) ,接下来读入n个数字表示A[i] (1&lt;=A[i]&lt;=10^9)接下来输入Q(1&lt;=Q&lt;=10^5),然后有Q行，表示Q次查询。每次查询，输入l,r(1&lt;=l&lt;=r&lt;=n),要求输出sum = A[l]+A[l+1]+A[l+2]+…+A[r-1]+A[r].</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];    <span class="comment">//固定长度的数组</span></span><br><span class="line">        ArrayList&lt;Integer&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//动态数组</span></span><br><span class="line">        b.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            array[i] = (<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>+<span class="number">1</span>);  </span><br><span class="line">            <span class="comment">//随机数200-300，(Math.random()*(max -min+1)+min)</span></span><br><span class="line">            System.out.println(array[i]+<span class="string">" "</span>);</span><br><span class="line">            b.add(b.get(i-<span class="number">1</span>)+array[i]);  <span class="comment">//计算数组，b[i]中存放的是前i个数的和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="keyword">int</span> Q = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = scan.nextInt();</span><br><span class="line">            <span class="keyword">int</span> r = scan.nextInt();</span><br><span class="line">            <span class="keyword">int</span> sum = b.get(r)-b.get(l-<span class="number">1</span>);  </span><br><span class="line">            <span class="comment">//计算array中，l-r范围中所有数的和 时间复杂度O(1), </span></span><br><span class="line">            <span class="comment">//b[r]=A[1]+A[2]+...+A[r] b[l]=A[1]+A[2]+...+A[l] b[l-1]=A[1]+A[2]+...+A[l-1]</span></span><br><span class="line">            <span class="comment">//故b[r]-b[l-1]=A[l]+A[l+1]+...+A[r-2]+A[r-1]+A[r]</span></span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="[二维前缀和]"></a>[二维前缀和]</h4><p>DP[i][j]表示（1,1）这个点与(i,j)这个点两个点分别为左上角和右下角所组成的矩阵内的数的和，状态转移方程，</p>
<p>DP [i] [j] = DP[i-1] [j] +DP[i] [j-1] - DP[i-1] [j-1] +map[i] [j]</p>
<p><img src="C:%5CUsers%5CPXN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908221224650.png" alt="image-20200908221224650"></p>
<p>这张图就知道了（i，j）可以由（i-1，j）和（i,j-1）两块构成，不过要注意两个点，1、有一块矩阵我们重复加了，也就是（i-1，j-1）这一块，所以我们要减去它。2、我们这个矩阵是不完整的，由图可知我们还有一块深蓝色的没有加，也就是（i，j）这一点，所以我们要再加上map[i][j]也就是题目给出的矩阵中这一格的数。</p>
<p>如果我们定义[x1,y1] 为所求矩阵左上角 [x2,y2] 为所求矩阵右下角  如何得到它们所围成矩阵的总和呢？</p>
<p><img src="C:%5CUsers%5CPXN%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200908222223292.png" alt="image-20200908222223292"></p>
<p>S  =DP[x2] [ y2] -DP[x1] [y2]-DP[x2] [y1] + DP[x1] [y1]</p>
<p>们可以通过DP[x2] [y2]来计算，我们通过图可以发现这个距离我们要的还差红色的部分看看怎么表示红色部分？我们可以分割成两块，分别是DP[x1] [y2]和DP[x2] [y1]我们发现有一块重复减了，所以我们再加上它即DP[x1] [y1]，有一点注意，因为画图和定义原因我们发现边界好像不对，我们来看看，我们定义的状态是整个矩阵包括边的和，而我们要求的也是要包括边的，所以我们要再改一下，把DP[x1] [y2]和DP[x2] [y1]和DP[x1] [y1]分别改成DP[x1-1] [y2]和DP[x2] [y1-1]和DP[x1-1] [y1-1]这样一减我们就可以得到自己想要的答案，整理可得公式，</p>
<p>DP[x2] [y2]-DP[x1-1] [y2]-DP[x2] [y1-1]+DP[x1-1] [y1-1]这样我们就可以做到O（1）之内查询</p>
<h1 id="回溯算法题"><a href="#回溯算法题" class="headerlink" title="*回溯算法题"></a>*回溯算法题</h1><h2 id="1-单词搜索-LetCode-79"><a href="#1-单词搜索-LetCode-79" class="headerlink" title="1. 单词搜索(LetCode 79)"></a>1. 单词搜索(LetCode 79)</h2><p>  <a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">题目</a>：给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用</p>
<p>提示：</p>
<p>1.board和word中只包含大写和小写英文字母</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;  <span class="comment">//上、右，下，左，便于board数组的指针移位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] marked; <span class="comment">//标记是否已经使用了board的当前元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board,String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">int</span> width = board[<span class="number">0</span>].length; <span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span> height = board.length;  <span class="comment">//行数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(height ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> word.isEmpty();  <span class="comment">//完善代码，判断特殊情况</span></span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[height][width];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dsf(i, j, <span class="number">0</span>,board,word))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return dsf(i,j,0,board,word); 不能这样写，因为这样写，会返回第一次dsf的回溯结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;  <span class="comment">//判断board指针移动的时候是否越界</span></span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;height&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dsf</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> start,<span class="keyword">char</span>[][] board,String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == word.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> word.charAt(start) == board[i][j];    <span class="comment">//防止字符串数组越界作出判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(word.charAt(start) == board[i][j])&#123;</span><br><span class="line">            marked[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            marked[i][j] = true 这里我觉得很重要，因为当这次标记为true后，开始i+1轮的回溯时，该位置不太会影响之前的marked是否会标记</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;  <span class="comment">//每个位置都有上，右，下，左四个方向的移动</span></span><br><span class="line">                <span class="keyword">int</span> new_X = i+direction[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_Y =j+direction[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(inArea(new_X,new_Y,board[<span class="number">0</span>].length,board.length)&amp;&amp;!marked[new_X][new_Y])&#123;  <span class="comment">//如果没有越界且没有使用过</span></span><br><span class="line">                    <span class="keyword">if</span>( dsf(new_X,new_Y,start+<span class="number">1</span>,board,word))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            marked[i][j] = <span class="keyword">false</span>;  <span class="comment">//不相等则 就不会使用该位置对应的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//这里不能直接使用maked[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                <span class="keyword">char</span>[][] board =</span><br><span class="line">                &#123;</span><br><span class="line">                        &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>&#125;,</span><br><span class="line">                        &#123;<span class="string">'S'</span>, <span class="string">'F'</span>, <span class="string">'C'</span>, <span class="string">'S'</span>&#125;,</span><br><span class="line">                        &#123;<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>&#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                String word = <span class="string">"ABCCEE"</span>;</span><br><span class="line">                test t = <span class="keyword">new</span> test();</span><br><span class="line">                <span class="keyword">boolean</span> ans = t.exist(board,word);</span><br><span class="line">                System.out.println(ans);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="*动态规划"></a>*动态规划</h1><h2 id="1-青蛙跳台阶"><a href="#1-青蛙跳台阶" class="headerlink" title="1. 青蛙跳台阶"></a>1. 青蛙跳台阶</h2><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">题目</a>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">  输入： n = <span class="number">2</span></span><br><span class="line">  输出： <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">  输入： n = <span class="number">7</span></span><br><span class="line">  输出： <span class="number">21</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)  <span class="comment">//先对特殊情况做判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]; <span class="comment">//这里记得数组的长度为n+1，因为下标要从1开始取，否则会越界</span></span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">           <span class="comment">//取模是题目的条件，估计是如果n比较大的时候，结果会越界吧</span></span><br><span class="line">           <span class="comment">//状态转移方程：dp[i] = dp[i-1]+dp[i-2];</span></span><br><span class="line">           <span class="comment">// 基本就是斐波那契数列的变种</span></span><br><span class="line">           <span class="comment">//斐波那契数列中，d[0] = 1, d[1] = 1; d[2] = 1;</span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：通过测评，方法二的形式占用空间更多</span></span><br><span class="line"><span class="comment">//方法二就是没有用数组，只是用值来不停迭代更新</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三 用递归的方法(HashMap优化递归)</span></span><br><span class="line"><span class="comment">//该种方法还是不如动态规划效率高，尤其在0&lt;n&lt;100的范围内</span></span><br><span class="line"><span class="comment">//空间上不如动态规划高效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(n))&#123;</span><br><span class="line">            <span class="comment">//优化递归方法，减少重复计算</span></span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(n,(numWays(n-<span class="number">1</span>)+numWays(n-<span class="number">2</span>))%<span class="number">1000000007</span>); </span><br><span class="line">    <span class="comment">//如果之前没有计算过，则计算后put进map中，结果取模</span></span><br><span class="line">    <span class="comment">//map.get(n)%1000000007 等价于 numWays(n-1)+numWays(n-2))%1000000007 </span></span><br><span class="line">    <span class="comment">//第二种取模方式占用内存空间少一些</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-连续子数组的最大和-带有非负数"><a href="#2-连续子数组的最大和-带有非负数" class="headerlink" title="2. 连续子数组的最大和(带有非负数)"></a>2. 连续子数组的最大和(带有非负数)</h2><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">题目：剑指Offer42</a></p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>: nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出： <span class="number">6</span></span><br><span class="line">解释：连续子数组[<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]的和最大，为<span class="number">6</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划1 ，时间复杂度O(n),空间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">       <span class="keyword">int</span> max = -<span class="number">101</span>;  <span class="comment">//题目要求nums[i]&lt;=100</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;dp[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             dp[i] = dp[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             dp[i] = nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           max = Math.max(max,dp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       retrun max;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划2，时间复杂度O(n),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            nums[i]+= Math.max(nums[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">            max = Math.max(max,num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-股票的最大利润"><a href="#3-股票的最大利润" class="headerlink" title="3.股票的最大利润"></a>3.股票的最大利润</h2><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指Offer 63.</a></p>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">	输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">	输出：<span class="number">5</span></span><br><span class="line">	解释：在第<span class="number">2</span>天(股票价格=<span class="number">1</span>)的时候买入，在第<span class="number">5</span>天(股票价格 = <span class="number">6</span>)的时候卖出，最大利润 = <span class="number">6</span>-<span class="number">1</span> =<span class="number">5</span>.</span><br><span class="line">	注意利润不能是  <span class="number">7</span>-<span class="number">1</span> = <span class="number">6</span> ，因为卖出价格需要大于买入价格。</span><br><span class="line">	</span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">	输入：[<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">	输出：<span class="number">0</span></span><br><span class="line">	解释：在这种情况下，没有交易完成，所以最大利润为<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>解题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.动态规划题</span></span><br><span class="line"><span class="comment">2.数组dp中存的是每个对应i对应的最小购入价格</span></span><br><span class="line"><span class="comment">3.动态规划转移方程：dp[i] = Math.min(minCost,prices[i])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.lenth&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            retrun <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minCost = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> mProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            minCost = Math.min(minCost,prices[i]);</span><br><span class="line">            mProfit = Math.max(mProfrt,prices[i]-minCost);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="*贪心算法"></a>*贪心算法</h1><h1 id="递归与非递归"><a href="#递归与非递归" class="headerlink" title="*递归与非递归"></a>*递归与非递归</h1><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="*HashMap"></a>*HashMap</h1><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="*红黑树"></a>*红黑树</h1><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="*最短路径"></a>*最短路径</h1><h1 id="队列的最大值-O-1-完成"><a href="#队列的最大值-O-1-完成" class="headerlink" title="*队列的最大值(O(1)完成)"></a>*队列的最大值(O(1)完成)</h1><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">题目</a></p>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>思路：</p>
<ol>
<li><p>就是在多维护一个数组，因为该题使用尾插法，所以我们需要再多维护一个单调不减的队列，队列不为空的情况下，即队首就是整个队列的最大值，所以求最大值只需要返回单调不减队列的队首即可</p>
</li>
<li><p>push_back 函数，先插入正常队列，为了维护单调不减队列，如果要插入的值，大于队尾的值，则将队尾的值pollLast()出去，直到一个不小于插入值的位置为止，然后尾插法，在单调不减队列中插入该值。</p>
</li>
<li><p>pop_Front 函数，首先当正常队列为空时，则返回-1，否则删除正常队列中队首的元素，然后在判断队首的元素是否与单调不减队列的队首相同，相同则说明，该元素即将被删除，如果单调队列不删除，则下次求队列的最大值时就会出现问题，简单来说，就是采用头删法，正常队列的队首与单调队列的队首相不相同，相同则同时则两个队列都删除队首，否则，只删除正常队列的队首。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">	输入: </span><br><span class="line">	[<span class="string">"MaxQueue"</span>,<span class="string">"push_back"</span>,<span class="string">"push_back"</span>,<span class="string">"max_value"</span>,<span class="string">"po	p_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">	[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">	输出: [<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">	输入: </span><br><span class="line">	[<span class="string">"MaxQueue"</span>,<span class="string">"pop_front"</span>,<span class="string">"max_value"</span>]</span><br><span class="line">	[[],[],[]]</span><br><span class="line">	输出: [<span class="keyword">null</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     1.java中用 Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();来声明定义一个队列</span></span><br><span class="line"><span class="comment">     2.q.peekFirst()函数返回队首元素的值，但不删除该元素</span></span><br><span class="line"><span class="comment">     3.q.addList()函数从队尾插入新元素</span></span><br><span class="line"><span class="comment">     4.q.pollList()函数删除队尾元素</span></span><br><span class="line"><span class="comment">     5.q.getLast()函数返回队列最后一个元素的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//正常队列</span></span><br><span class="line">    Deque&lt;Integer&gt; d = <span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//单调不减队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> d.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!d.isEmpty()&amp;&amp;d.peekLast()&lt;value)&#123;</span><br><span class="line">            d.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        q.addLast(value);</span><br><span class="line">        d.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = q.getFirst();</span><br><span class="line">        q.pollFirst();</span><br><span class="line">        <span class="keyword">if</span>(!d.isEmpty()&amp;&amp;temp==d.getFirst())&#123;</span><br><span class="line">            d.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="二叉树训练："><a href="#二叉树训练：" class="headerlink" title="*二叉树训练："></a>*二叉树训练：</h1><p>首先是自定义的二叉树：</p>
<h2 id="BinaryNode的类，节点类："><a href="#BinaryNode的类，节点类：" class="headerlink" title="+BinaryNode的类，节点类："></a>+BinaryNode的类，节点类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T data;  <span class="comment">//树节点的数据</span></span><br><span class="line">    <span class="keyword">public</span> BinaryNode&lt;T&gt;left,right;  <span class="comment">//该节点对应的左右孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryNode</span><span class="params">(T data,BinaryNode&lt;T&gt;left,BinaryNode&lt;T&gt;right)</span></span>&#123;  <span class="comment">//带参数的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(data,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeft</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left == <span class="keyword">null</span>&amp;&amp;<span class="keyword">this</span>.right ==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> BinaryNode&lt;T&gt; root;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span>[] list)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(T[] prelist)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.root = create(prelist);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> BinaryNode&lt;T&gt;create(T[]prelist)&#123;</span><br><span class="line">       BinaryNode&lt;T&gt; p =<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;prelist.length)&#123;</span><br><span class="line">           T node = prelist[i];</span><br><span class="line">           i++;</span><br><span class="line">           <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               p = <span class="keyword">new</span> BinaryNode&lt;&gt;(node);</span><br><span class="line">               p.left = create(prelist);</span><br><span class="line">               p.right = create(prelist);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.root == <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">insert</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.root = <span class="keyword">new</span> BinaryNode&lt;&gt;(x,<span class="keyword">this</span>.root,<span class="keyword">null</span>); <span class="comment">//插入根节点，其实就是只插入左孩子节点</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">insert</span><span class="params">(BinaryNode&lt;T&gt; parent,T x,<span class="keyword">boolean</span> leftChild)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="keyword">null</span>)  <span class="comment">//值为空，则就是不插入节点</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(leftChild)    <span class="comment">//判断是否为左孩子，如果是，则给父节点插入左孩子节点，否则，插入右孩子节点</span></span><br><span class="line">           <span class="keyword">return</span> parent.left = <span class="keyword">new</span> BinaryNode&lt;T&gt;(x,parent.left,<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">return</span> parent.right = <span class="keyword">new</span> BinaryNode&lt;T&gt;(x,<span class="keyword">null</span>,parent.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(BinaryNode&lt;T&gt; parent,<span class="keyword">boolean</span> leftChilde)</span></span>&#123;   <span class="comment">//这里的左孩子Boolean变量，只是为了判断是否为左孩子节点</span></span><br><span class="line">       <span class="keyword">if</span>(leftChilde)&#123;</span><br><span class="line">           parent.left =<span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           parent.right = <span class="keyword">null</span>;     <span class="comment">//这里只是删除了以一个节点为根的一颗子树，</span></span><br><span class="line">           <span class="comment">//在二叉树中删除一个节点，不仅要修改其父母节点的left或right域，还要约定如何调整子树结构的规则，即删除一个节点。</span></span><br><span class="line">           <span class="comment">//原先以该节点为根的子树则变成由原左子树和右子树组成的森林，约定一种规则使这个森林组成一颗子树。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;   <span class="comment">//删除二叉树的所有节点</span></span><br><span class="line">       <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">preorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">       preorder(<span class="keyword">this</span>.root);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BinaryNode&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.print(p.data.toString()+<span class="string">" "</span>);</span><br><span class="line">           preorder(p.left);</span><br><span class="line">           preorder(p.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inorder(<span class="keyword">this</span>.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BinaryNode&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           inorder(p.left);</span><br><span class="line">           System.out.print(p.data.toString()+<span class="string">" "</span>);</span><br><span class="line">           inorder(p.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BinaryNode&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postorder(p.left);</span><br><span class="line">           postorder(p.right);</span><br><span class="line">           System.out.print(p.data.toString()+<span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">       postorder(<span class="keyword">this</span>.root);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String[] prelist = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"D"</span>,<span class="keyword">null</span>,<span class="string">"G"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">"C"</span>,<span class="string">"E"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">"F"</span>,<span class="string">"H"</span>&#125;;</span><br><span class="line">       BinaryTree&lt;String&gt; bitree = <span class="keyword">new</span> BinaryTree&lt;String&gt;(prelist);</span><br><span class="line">       System.out.println(<span class="string">"先根次序遍历二叉树："</span>+bitree.toString());</span><br><span class="line">       bitree.preorder();</span><br><span class="line">       System.out.println(<span class="string">"中根次序遍历二叉树："</span>);</span><br><span class="line">       bitree.inorder();                          <span class="comment">//说明了当给定前序二叉树时，用其他的顺序输出不能确定唯一的二叉树，只有按照前序输出才可以输出正确的结果</span></span><br><span class="line">       System.out.println(<span class="string">"后根次序遍历二叉树："</span>);</span><br><span class="line">       bitree.postorder();</span><br><span class="line">       bitree.insert(bitree.root.left,<span class="string">"X"</span>,<span class="keyword">true</span>);</span><br><span class="line">       bitree.insert(bitree.root.right,<span class="string">"Y"</span>,<span class="keyword">false</span>);</span><br><span class="line">       bitree.insert(<span class="string">"Z"</span>);</span><br><span class="line">       bitree.preorder();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BinaryTree代码："><a href="#BinaryTree代码：" class="headerlink" title="+BinaryTree代码："></a>+BinaryTree代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T data;  <span class="comment">//树节点的数据</span></span><br><span class="line">    <span class="keyword">public</span> BinaryNode&lt;T&gt;left,right;  <span class="comment">//该节点对应的左右孩子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryNode</span><span class="params">(T data,BinaryNode&lt;T&gt;left,BinaryNode&lt;T&gt;right)</span></span>&#123;  <span class="comment">//带参数的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryNode</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(data,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeft</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left == <span class="keyword">null</span>&amp;&amp;<span class="keyword">this</span>.right ==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> BinaryNode&lt;T&gt; root;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(<span class="keyword">int</span>[] list)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(T[] prelist)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.root = create(prelist);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> BinaryNode&lt;T&gt;create(T[]prelist)&#123;</span><br><span class="line">       BinaryNode&lt;T&gt; p =<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;prelist.length)&#123;</span><br><span class="line">           T node = prelist[i];</span><br><span class="line">           i++;</span><br><span class="line">           <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               p = <span class="keyword">new</span> BinaryNode&lt;&gt;(node);</span><br><span class="line">               p.left = create(prelist);</span><br><span class="line">               p.right = create(prelist);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.root == <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">insert</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.root = <span class="keyword">new</span> BinaryNode&lt;&gt;(x,<span class="keyword">this</span>.root,<span class="keyword">null</span>); <span class="comment">//插入根节点，其实就是只插入左孩子节点</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> BinaryNode&lt;T&gt; <span class="title">insert</span><span class="params">(BinaryNode&lt;T&gt; parent,T x,<span class="keyword">boolean</span> leftChild)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x==<span class="keyword">null</span>)  <span class="comment">//值为空，则就是不插入节点</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(leftChild)    <span class="comment">//判断是否为左孩子，如果是，则给父节点插入左孩子节点，否则，插入右孩子节点</span></span><br><span class="line">           <span class="keyword">return</span> parent.left = <span class="keyword">new</span> BinaryNode&lt;T&gt;(x,parent.left,<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">return</span> parent.right = <span class="keyword">new</span> BinaryNode&lt;T&gt;(x,<span class="keyword">null</span>,parent.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(BinaryNode&lt;T&gt; parent,<span class="keyword">boolean</span> leftChilde)</span></span>&#123;   <span class="comment">//这里的左孩子Boolean变量，只是为了判断是否为左孩子节点</span></span><br><span class="line">       <span class="keyword">if</span>(leftChilde)&#123;</span><br><span class="line">           parent.left =<span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           parent.right = <span class="keyword">null</span>;     <span class="comment">//这里只是删除了以一个节点为根的一颗子树，</span></span><br><span class="line">           <span class="comment">//在二叉树中删除一个节点，不仅要修改其父母节点的left或right域，还要约定如何调整子树结构的规则，即删除一个节点。</span></span><br><span class="line">           <span class="comment">//原先以该节点为根的子树则变成由原左子树和右子树组成的森林，约定一种规则使这个森林组成一颗子树。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;   <span class="comment">//删除二叉树的所有节点</span></span><br><span class="line">       <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">preorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">       preorder(<span class="keyword">this</span>.root);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BinaryNode&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.print(p.data.toString()+<span class="string">" "</span>);</span><br><span class="line">           preorder(p.left);</span><br><span class="line">           preorder(p.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inorder(<span class="keyword">this</span>.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BinaryNode&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           inorder(p.left);</span><br><span class="line">           System.out.print(p.data.toString()+<span class="string">" "</span>);</span><br><span class="line">           inorder(p.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BinaryNode&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           postorder(p.left);</span><br><span class="line">           postorder(p.right);</span><br><span class="line">           System.out.print(p.data.toString()+<span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span></span>&#123;</span><br><span class="line">       postorder(<span class="keyword">this</span>.root);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String[] prelist = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"D"</span>,<span class="keyword">null</span>,<span class="string">"G"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">"C"</span>,<span class="string">"E"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="string">"F"</span>,<span class="string">"H"</span>&#125;;</span><br><span class="line">       BinaryTree&lt;String&gt; bitree = <span class="keyword">new</span> BinaryTree&lt;String&gt;(prelist);</span><br><span class="line">       System.out.println(<span class="string">"先根次序遍历二叉树："</span>+bitree.toString());</span><br><span class="line">       bitree.preorder();</span><br><span class="line">       System.out.println(<span class="string">"中根次序遍历二叉树："</span>);</span><br><span class="line">       bitree.inorder();                          <span class="comment">//说明了当给定前序二叉树时，用其他的顺序输出不能确定唯一的二叉树，只有按照前序输出才可以输出正确的结果</span></span><br><span class="line">       System.out.println(<span class="string">"后根次序遍历二叉树："</span>);</span><br><span class="line">       bitree.postorder();</span><br><span class="line">       bitree.insert(bitree.root.left,<span class="string">"X"</span>,<span class="keyword">true</span>);</span><br><span class="line">       bitree.insert(bitree.root.right,<span class="string">"Y"</span>,<span class="keyword">false</span>);</span><br><span class="line">       bitree.insert(<span class="string">"Z"</span>);</span><br><span class="line">       bitree.preorder();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="+二叉树的层次遍历"></a>+二叉树的层次遍历</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7</p>
<p>返回其自底向上的层次遍历为：</p>
<p>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">             List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">             Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();  </span><br><span class="line">             <span class="comment">//定义一个队列，由于队列先进先出的概念</span></span><br><span class="line">             <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> list;</span><br><span class="line">             &#125;</span><br><span class="line">             queue.offer(root);</span><br><span class="line">             <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                 List&lt;Integer&gt; nodelist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                 <span class="keyword">int</span> size = queue.size(); <span class="comment">//这里很关键，用size来记录原先的长度，而不是等queue变长</span></span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                     TreeNode node = queue.poll();  <span class="comment">//删除上次进入的节点</span></span><br><span class="line">                     nodelist.add(node.val);</span><br><span class="line">                     <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                         queue.offer(node.left);   <span class="comment">//添加上次进入节点的左孩子节点</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                         queue.offer(node.right);<span class="comment">//添加上次进入节点的右孩子节点</span></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 list.add(<span class="number">0</span>,nodelist);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">                 <span class="comment">//java中队列queue的一些操作</span></span><br><span class="line"><span class="comment">/*void add(Object e);　　   //将指定元素加入此队列的尾部。</span></span><br><span class="line"><span class="comment">Object element();　　     //获取队列头部的元素，但是不删除该元素。</span></span><br><span class="line"><span class="comment">boolean offer(Object e); //将指定元素加入此队列的尾部。当使用有容量限制的队列时，此方法通常比add(Object e)方法更好。</span></span><br><span class="line"><span class="comment">Object peek(); 　　        //获取队列头部的元素，但是不删除该元素，如果此队列为空，则返回null。</span></span><br><span class="line"><span class="comment">Object poll();                //获取队列头部的元素，并删除该元素，如果此队列为空，则返回null。</span></span><br><span class="line"><span class="comment">Object remove();　　    //获取队列头部的元素，并删除该元素*/</span></span><br></pre></td></tr></table></figure>

<p>（1）队列的实现通常不允许插入null值，尽管一些队列实现了，如LinkedList就没有禁止，即使LinkedList可以插入null值，但我们在实际使用的时候也不应该向队列插入null值，因为null值通常用于poll方法表示当前队列没有元素了，但如果允许插入null值，这个方法就有歧义，所以我们在使用时候应该避免在队列中插入null值。</p>
<p>（2）队列的实现通常不需要重写该类的equasl和hashCode方法，代替使用Object类默认的定义，因为在队列里面一样的元素可能拥有不同的排序属性。</p>
<h2 id="letcode-1373-二叉搜索子树的最大键值和"><a href="#letcode-1373-二叉搜索子树的最大键值和" class="headerlink" title="*letcode (1373)二叉搜索子树的最大键值和"></a>*letcode (1373)二叉搜索子树的最大键值和</h2><h2 id="链表"><a href="#链表" class="headerlink" title="* 链表"></a>* 链表</h2><h3 id="链表的转置-倒序、翻转Reverse"><a href="#链表的转置-倒序、翻转Reverse" class="headerlink" title="+链表的转置(倒序、翻转Reverse)"></a>+链表的转置(倒序、翻转Reverse)</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="-思路："></a>-思路：</h4><p>首先处理第一个不为null的节点，将其变为未节点，先将该节点的下个节点的位置信息存入一个临时节点，LNode temp = cur.Next,r然后将当前节点的Next置空，即让LNode.Next =  null; 然后使前置节点指向，该节点，即 pre = cur，最后再将当前节点指向临时节点所代表的内容，即 cur = temp；</p>
<p>接着，我们先判断当前元素是不是最后一个元素，如果是最后一个元素，则将当前节点的Next指向前置节点，即 cur.Next = pre; 然后再将头指针的Next指向当前元素，否则，将后置节点赋值即 next = cur.Next; 然后将当前节点的Next指针指向pre，也就是前置节点，即 cur.Next = pre; 然后在让前置节点指向当前节点，即pre = cur; 最后再让当前节点指向 后置节点，即 cur = next；</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="-代码："></a>-代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LNode head = <span class="keyword">new</span> LNode();</span><br><span class="line">        LNode temp = <span class="keyword">null</span>;</span><br><span class="line">        LNode cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> LNode();    <span class="comment">//设置一个链表</span></span><br><span class="line">            temp.val = i;</span><br><span class="line">            temp.Next = <span class="keyword">null</span>;</span><br><span class="line">            cur.Next = temp;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"逆序前："</span>);</span><br><span class="line">        <span class="keyword">for</span>(cur=head.Next;cur!=<span class="keyword">null</span>;cur = cur.Next)&#123;</span><br><span class="line">                System.out.print(cur.val+<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"逆序后："</span>);</span><br><span class="line">        Reverse(head);</span><br><span class="line">        <span class="keyword">for</span>(cur=head.Next;cur!=<span class="keyword">null</span>;cur = cur.Next)&#123;</span><br><span class="line">                System.out.print(cur.val+<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(LNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.Next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LNode pre = <span class="keyword">null</span>;</span><br><span class="line">        LNode cur = <span class="keyword">null</span>;</span><br><span class="line">        LNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        cur = head.Next;</span><br><span class="line">        next = cur.Next;</span><br><span class="line">        cur.Next = <span class="keyword">null</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur.Next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.Next;</span><br><span class="line">            cur.Next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line"><span class="comment">//            cur = cur.Next;</span></span><br><span class="line">           <span class="comment">/*书中出现了一些逻辑上的错误，这里cur.Next早就设置成了前置节点了，</span></span><br><span class="line"><span class="comment">           因此只需将当前指针，指向下一个未逆序的节点即可，即cur = next,这句是多余的*/</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.Next = pre;</span><br><span class="line">        head.Next = cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="算法总结："><a href="#算法总结：" class="headerlink" title="*算法总结："></a>*算法总结：</h1><h2 id="1-求区间-i-j-的和"><a href="#1-求区间-i-j-的和" class="headerlink" title="1.求区间 i - j 的和"></a>1.求区间 i - j 的和</h2><p>维护一维前序和，sum = d[ j ] - d[i-1]</p>
<h2 id="2-求某数组中以某元素为最小值的最长区间，即letcode-84"><a href="#2-求某数组中以某元素为最小值的最长区间，即letcode-84" class="headerlink" title="2. 求某数组中以某元素为最小值的最长区间，即letcode-84"></a>2. 求某数组中以某元素为最小值的最长区间，即letcode-84</h2><h3 id="2-1-若数组中的数全是正数，则我们应当用Letcode-84"><a href="#2-1-若数组中的数全是正数，则我们应当用Letcode-84" class="headerlink" title="2.1 若数组中的数全是正数，则我们应当用Letcode- 84"></a>2.1 若数组中的数全是正数，则我们应当用Letcode- 84</h3><h3 id="2-2-若数组中有非正数，则我们应当使用动态规划"><a href="#2-2-若数组中有非正数，则我们应当使用动态规划" class="headerlink" title="2.2 若数组中有非正数，则我们应当使用动态规划"></a>2.2 若数组中有非正数，则我们应当使用动态规划</h3><h2 id="3-二叉树的中序遍历是带顺序的"><a href="#3-二叉树的中序遍历是带顺序的" class="headerlink" title="3. 二叉树的中序遍历是带顺序的"></a>3. 二叉树的中序遍历是带顺序的</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>win10+eclipse+maven+ssm环境搭建</title>
    <url>/2020/04/24/win10-eclipse-maven-ssm%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="win10-eclipse-maven-ssm环境搭建"><a href="#win10-eclipse-maven-ssm环境搭建" class="headerlink" title="win10+eclipse+maven+ssm环境搭建"></a>win10+eclipse+maven+ssm环境搭建</h1><a id="more"></a>

<h2 id="1-安装JDK"><a href="#1-安装JDK" class="headerlink" title="1.安装JDK"></a>1.安装JDK</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载JDK</a></p>
<p>注：JDK比较稳定的还是JDK8，按照自己的系统选择就好，将JDK安装入一个空目录文件夹下</p>
<p>接下来，配置JDK 的环境变量</p>
<ol>
<li><p>创建系统变量JAVA_HOME</p>
<p><img src="https://s1.ax1x.com/2020/04/24/Jrrql6.png" alt="img"></p>
</li>
</ol>
<ol start="2">
<li><p>引用JAVA_HOME变量，添加lib的路径和tool.jar文件的路径</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JryKVe.png" alt="img"></p>
</li>
</ol>
<ol start="3">
<li><p>将JDK中的bin文件的路径添加至系统Path中</p>
<img src="https://s1.ax1x.com/2020/04/24/JrsrnO.png" alt="img" style="zoom: 200%;" />



</li>
</ol>
<ol start="4">
<li><p>测试JDK是否安装成功，win+R输入cmd，然后在cmd中输入 java  命令，若是有java的用法提示，则表明安装成功，否则安装失败。</p>
<hr>
</li>
</ol>
<h2 id="2-安装Eclipse"><a href="#2-安装Eclipse" class="headerlink" title="2. 安装Eclipse"></a>2. 安装Eclipse</h2><p>   <a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载Eclipse</a></p>
<p>   下载完成后，打开eclipse-ins-win64.exe文件</p>
<p>   选择Eclipse IDE for Java EE Developers，直至完成</p>
<hr>
<h2 id="3-安装Maven"><a href="#3-安装Maven" class="headerlink" title="3. 安装Maven"></a>3. 安装Maven</h2><p>   <a href="http://maven.apache.org/download.cgi#" target="_blank" rel="noopener">下载Maven</a></p>
<p>   <img src="https://s1.ax1x.com/2020/04/25/Jsgr1s.png" alt="Download_Maven"></p>
<p>   如上图，可以选择zip压缩包的安装形式</p>
<h3 id="3-1-Maven环境变量的配置"><a href="#3-1-Maven环境变量的配置" class="headerlink" title="3.1  Maven环境变量的配置"></a>3.1  Maven环境变量的配置</h3><p>   win10-&gt;找到此电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p>
<p>   在系统变量中，配置Maven环境</p>
<ul>
<li><p>新增系统变量MAVEN_HOME</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Js2DUO.png" alt="MAVEN_HOME"></p>
<p>注：变量值为bin目录的上级目录</p>
</li>
<li><p>在Path中追加：%MAVEN_HOME%\bin</p>
</li>
<li><p>win+R打开cmd窗口输入：mvn -v, 如果如下图所示则说明maven配置成功</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsR9G4.png" alt="cmd_maven"></p>
</li>
</ul>
<h2 id="3-2-Maven仓库-Repository-设置"><a href="#3-2-Maven仓库-Repository-设置" class="headerlink" title="3.2 Maven仓库(Repository)设置"></a>3.2 Maven仓库(Repository)设置</h2><p>   Maven的仓库有三类，简单来说三个仓库的关系：</p>
<p>   <img src="https://s1.ax1x.com/2020/04/25/Jsh9JS.png" alt="maven_repertory"></p>
<h4 id="3-2-1-编辑setting-xml文件，maven仓库位置在下图"><a href="#3-2-1-编辑setting-xml文件，maven仓库位置在下图" class="headerlink" title="3.2.1 编辑setting.xml文件，maven仓库位置在下图"></a>3.2.1 编辑setting.xml文件，maven仓库位置在下图</h4><p>   <img src="https://s1.ax1x.com/2020/04/25/Jsh6TP.png" alt=""></p>
<ul>
<li><p>当直接访问maven公共仓库的速度会比较慢，所以这里推荐使用仓库镜像，这里使用阿里的maven仓库，在settings.xml文件中找到<mirrors>节点(添加镜像仓库)</p>
</li>
<li><p>在<mirrors>节点中添加如下代码(请添加到该节点原有注释之下)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到<localRepository>节点(该节点被注释掉了，直接在注释下方自己重新添加该节点并添加仓库路径)，加入以下内容(添加本地仓库)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:\SoftTool\Maven\maven_repo\localrepo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加代码后如下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsI7TI.png" alt="localRepository"></p>
</li>
<li><p>找到<profile>节点，加入如下内容(将默认JDK1.4设置为1.8)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="4-安装Tomcat"><a href="#4-安装Tomcat" class="headerlink" title="4. 安装Tomcat"></a>4. 安装Tomcat</h2><p>   <a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">下载Tomcat</a></p>
<p>   <img src="https://s1.ax1x.com/2020/04/25/JsdhQS.png" alt="img"></p>
<p>   按照上图选择合适的版本和系统配置下载</p>
<h3 id="4-1-环境变量的配置"><a href="#4-1-环境变量的配置" class="headerlink" title="4.1 环境变量的配置"></a>4.1 环境变量的配置</h3><p>   win10-&gt;找到此电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p>
<p>   然后在系统变量这一栏里，配置Tomcat的环境变量</p>
<ul>
<li><p>新建CATALINA_BASE变量</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyfzNV.png" alt="Tomcat"></p>
<p>注：其中变量名必须为CATALINA_BASE，否则Tomcat会找不到配置的环境变量。而变量值则是安装的Tomcat文件中bin目录的上级目录。</p>
</li>
</ul>
<ul>
<li><p>新建CATALINA_HOME变量</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyhPc4.png" alt="Tomcat"></p>
</li>
</ul>
<ul>
<li><p>找到Path变量，点击编辑，添加如下</p>
<img src="https://s1.ax1x.com/2020/04/25/JsDVyT.png" style="zoom:200%;" />



</li>
</ul>
<h3 id="4-3-验证Tomcat是否配置成功"><a href="#4-3-验证Tomcat是否配置成功" class="headerlink" title="4.3  验证Tomcat是否配置成功"></a>4.3  验证Tomcat是否配置成功</h3><p>   启动Tomcat服务的方式有很多种，这里值列举两种：</p>
<ul>
<li><p>方式一</p>
<ol>
<li><p>win+R搜索输入cmd，打开命令提示符窗口：</p>
</li>
<li><p>直接输入startup，按下Enter键，则会弹出一个标题栏为”Tomcat”的窗口，并出现如下图所示的信息。</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsrQHg.png" alt=""></p>
<p>注：先不要关闭黑窗口，否则等于Tomcat也关了，因为随后会打开浏览器验证</p>
</li>
</ol>
</li>
</ul>
<pre><code>3.  在浏览器的地址栏中输入：[http://localhost:8080/](http://localhost:8080/) 或[http://127.0.0.1:8080/](http://127.0.0.1:8080/)

   如果能够显示下图界面，则说明Tomcat配置成功

   ![Test_browser_Tomcat](https://s1.ax1x.com/2020/04/25/JyhQjH.png)



   * 方式二

     1. 找到Tomcat的安装目录下的bin文件

     2. 打开bin文件，找到startup.bat，双击打开该文件，会弹出跟方式一相同的Tomcat窗口(弹窗最后一句话：Server startup in 533 ms，就是说服务启动耗时533毫秒)

        如果想关闭Tomcat，那么只要双击bin文件下的shutdown.bat就可以了</code></pre><h3 id="4-4-Tomcat的详细配置-端口号，部署web应用，配置数据源"><a href="#4-4-Tomcat的详细配置-端口号，部署web应用，配置数据源" class="headerlink" title="4.4 Tomcat的详细配置(端口号，部署web应用，配置数据源)"></a>4.4 Tomcat的详细配置(端口号，部署web应用，配置数据源)</h3><p><a href="https://www.jb51.net/article/140516.htm" target="_blank" rel="noopener">Tomcat详细配置-&gt;脚本之家</a></p>
<hr>
<h2 id="5-Eclipse整合Maven"><a href="#5-Eclipse整合Maven" class="headerlink" title="5.  Eclipse整合Maven"></a>5.  Eclipse整合Maven</h2><p>打开Eclipse-&gt;Window-&gt;Preferences</p>
<p>设置顺序如下：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyNL38.png" alt=""></p>
<p>接着选择Installations节点-&gt;Add-&gt;Directory-&gt;Finish-&gt;勾选maven</p>
<p>Installation name可以自行修改</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JydwjS.png" alt=""></p>
<h2 id="6-使用Maven创建SSM项目"><a href="#6-使用Maven创建SSM项目" class="headerlink" title="6. 使用Maven创建SSM项目"></a>6. 使用Maven创建SSM项目</h2><h3 id="6-1-File-gt-new-gt-project-gt-maven-gt-maven-project"><a href="#6-1-File-gt-new-gt-project-gt-maven-gt-maven-project" class="headerlink" title="6.1  File-&gt;new-&gt;project-&gt;maven-&gt;maven-project"></a>6.1  File-&gt;new-&gt;project-&gt;maven-&gt;maven-project</h3><p>Filter选项选择web类型，(我的话有点慢，过了一阵子才有了Group Id，而且点击Configure后，在搜索框中输入web后，才显示出Group IP)</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyDjJA.png" alt=""></p>
<h3 id="6-2-填写GroupID、ArtifatID"><a href="#6-2-填写GroupID、ArtifatID" class="headerlink" title="6.2 填写GroupID、ArtifatID"></a>6.2 填写GroupID、ArtifatID</h3><ul>
<li><p>Group ID：相当于一个组织</p>
</li>
<li><p>Artifact ID：相当于这个组织下的一个具体项目</p>
</li>
<li><p>Packege：根据Group ID和Artifact ID生成一个默认的名称</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyygZ8.png" alt=""></p>
</li>
</ul>
<p>点击Finish后，会在本地仓库中创建出如下图所示的文件</p>
<img src="https://s1.ax1x.com/2020/04/25/JygNZV.png"  />



<h3 id="6-3-创建出的maven项目如下"><a href="#6-3-创建出的maven项目如下" class="headerlink" title="6.3 创建出的maven项目如下"></a>6.3 创建出的maven项目如下</h3><p><img src="https://s1.ax1x.com/2020/04/25/Jy2bc9.png" alt="project-structure"></p>
<p>创建ssm项目报错如下：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyRPcd.png" alt=""></p>
<h3 id="6-4-在eclipse中设置Server为Tomcat"><a href="#6-4-在eclipse中设置Server为Tomcat" class="headerlink" title="6.4 在eclipse中设置Server为Tomcat"></a>6.4 在eclipse中设置Server为Tomcat</h3><p>Eclipse-&gt;Window-&gt;preferences-&gt;Server-&gt;Runtime Enviroments-&gt;Add-&gt;在弹框type filter text处选择对应的Tomcat版本(这里选v9.0)-&gt;Next</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Jy58tP.png" alt=""></p>
<p>接着找到本地配置好的Tomcat，然后在JRE设置安装JDK的jre</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Jy5OnH.png" alt=""></p>
<h3 id="6-5-在工程上右键，查看工程属性-properties-，找到Java-Build-Path，添加Server-Runtime为Tomcat"><a href="#6-5-在工程上右键，查看工程属性-properties-，找到Java-Build-Path，添加Server-Runtime为Tomcat" class="headerlink" title="6.5 在工程上右键，查看工程属性(properties)，找到Java Build Path，添加Server Runtime为Tomcat"></a>6.5 在工程上右键，查看工程属性(properties)，找到Java Build Path，添加Server Runtime为Tomcat</h3><p><img src="https://s1.ax1x.com/2020/04/25/Jy7uCt.png" alt=""></p>
<p>点击Finish，并Apply</p>
<img src="https://s1.ax1x.com/2020/04/25/Jy7fxK.png"  />

<p>工程错误消失，但是jdk版本显示还是1.7</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JyHRoj.png" alt=""></p>
<h3 id="6-6-还是在项目上右键，查看项目信息-properties-，选择project-facets"><a href="#6-6-还是在项目上右键，查看项目信息-properties-，选择project-facets" class="headerlink" title="6.6 还是在项目上右键，查看项目信息(properties)，选择project  facets"></a>6.6 还是在项目上右键，查看项目信息(properties)，选择project  facets</h3><p><img src="https://s1.ax1x.com/2020/04/25/J6AeOg.png" alt=""></p>
<p>默认的Dynamic Web Module为2.3，使用Tomcat v9，需要修改为4.0。这里无法直接选择修改成4.0，需要以下几个步骤设置：</p>
<ol>
<li><p>maven工程setting下org.eclipse.wst.common.project.facet.core.xml</p>
<p><img src="https://s1.ax1x.com/2020/04/25/J6VYdJ.png" alt=""></p>
<p>修改后为(主要修改了java和java.web的版本号)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">faceted-project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fixed</span> <span class="attr">facet</span>=<span class="string">"wst.jsdt.web"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"java"</span> <span class="attr">version</span>=<span class="string">"1.8"</span>/&gt;</span> <span class="comment">&lt;!--JDK版本为1.8--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"jst.web"</span> <span class="attr">version</span>=<span class="string">"4.0"</span>/&gt;</span>  <span class="comment">&lt;!--将2.3改为4.0，搭配Tomcat9--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"wst.jsdt.web"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">faceted-project</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将maven工程目录\src\main\webapp\WEB-INF中的web.xml文件修改为(将整个文件修改)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">version</span>=<span class="string">"4.0"</span> <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>maven工程目录下的pom.xml文件中修改build节点，添加剂如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--添加--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在project节点下添加如下代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 另外一种激活方式 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li>修改后，在项目上右键，点击Maven属性下的Update Project</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/04/25/J6njN4.png" alt=""></p>
<p>选择该项目进行更新，如果怕不能强制更新，可以勾选Force Update of Snapshots/Releases</p>
<p><img src="https://s1.ax1x.com/2020/04/26/J6us54.png" alt=""></p>
<p>右下角更新进度，大约几分钟左右</p>
<ol start="5">
<li><p>更新maven项目(右键-&gt;maven-&gt;updateproject)，再观察项目属性(项目右键-&gt;properties-&gt;project Facets)，Module已经变为4.0</p>
<p><img src="https://s1.ax1x.com/2020/04/26/J6Ms39.png" alt=""></p>
</li>
</ol>
<p>若更新maven项目后，报错建议先检查以上的几个步骤</p>
<ol start="6">
<li><p>下载ssm框架就所需的jar包</p>
<p>修改maven工程目录下的pom.xml文件：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.temptation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ssm Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Spring版本号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.3.8.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Spring相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- AOP相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- MyBatis相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- MySQL相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Spring集成MyBatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- JSP标准标签库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">&lt;!-- 日志相关包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--单元测试相关包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--添加--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 另外一种激活方式 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接复制上述内容至pom.xml文件，也可以根据需求添加一下jar，保存该文件后，右键点击项目后选中refresh，可以看到相关jar包被下载至本地仓库。</p>
<h3 id="6-7-完善项目结构"><a href="#6-7-完善项目结构" class="headerlink" title="6.7  完善项目结构"></a>6.7  完善项目结构</h3><p>由于服务端maven项目的标准结构有4个子包：src/main/java、src/main/resources、src/test/java、src/test/resources，这里缺少了src/test/resources,所以手动补上。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学证明有界无界</title>
    <url>/2020/04/19/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E6%9C%89%E7%95%8C%E6%97%A0%E7%95%8C/</url>
    <content><![CDATA[<p>高等数学证明有界无界</p>
<a id="more"></a>

<p>问题：证明函数f(x)= 1/x²在(0,1)上无界。</p>
<ol>
<li><p>“有界” 定义(注意有界与区间有关)</p>
<p>存在M&gt;0，使得对任意的x∈D，都有 |f(x)| ≤ M.</p>
</li>
<li><p>到“无界”定义，即否定“有界”</p>
<p>对任意M&gt;0(无论多大)，存在xm属于D，使得 |f(xm)| &gt; M</p>
</li>
<li><p>回到问题，梳理思路：</p>
<p>要证明f(x)在(0,1)上无界，按“无界” 定义</p>
<p>对任意M&gt;0，要找到一个满足的 |f(x)|&gt;M的x∈(0,1)</p>
<p>即找到一个满足1/x²&gt; M 的x∈(0,1)</p>
<p>即找到一个满足 <img src="https://s1.ax1x.com/2020/04/20/JQUab6.png" alt="img"> 的x∈(0,1)</p>
<p>取<img src="https://s1.ax1x.com/2020/04/20/JQNEOx.png" alt="img">)即可(不唯一)</p>
</li>
<li><p>解题过程：</p>
<p>对任意的M&gt;1/4 (无论多大)，都存在<img src="https://s1.ax1x.com/2020/04/20/JQUT2j.png" alt="img"></p>
<p>使得<img src="https://s1.ax1x.com/2020/04/20/JQULq0.png" alt="img"></p>
</li>
</ol>
<p>   故f(x)在(0,1)上无界。</p>
<p>   摘录<a href="https://zhuanlan.zhihu.com/p/29552253" target="_blank" rel="noopener">高数有界无界</a></p>
]]></content>
      <categories>
        <category>高数学习</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>软件架构8种模式和设计原则</title>
    <url>/2020/06/06/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%848%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="软件架构8种模式和设计原则"><a href="#软件架构8种模式和设计原则" class="headerlink" title="软件架构8种模式和设计原则"></a>软件架构8种模式和设计原则</h1><a id="more"></a>

<h2 id="1-工厂模式（FactoryPattern）"><a href="#1-工厂模式（FactoryPattern）" class="headerlink" title="1. 工厂模式（FactoryPattern）"></a>1. 工厂模式（FactoryPattern）</h2><p>一般情况下有3中工厂模式，简单工厂模式(不属于23中模式之一)，工厂方法模式，以及抽象工厂模式。工厂方法模式是日常开发中使用频率最高的一种设计模式，工厂方法模式也是我们通常说的工厂模式。</p>
<p>为什么要用工厂模式？</p>
<p>1.解耦：把对象的创建和使用的过程分开</p>
<p>2.降低代码重复：如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码，冗余过大。</p>
<p>3.降低维护成本：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不要找到所有需要创建某个对象的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。</p>
<p>该模式存在的问题：当产品派生类中定义了抽象产品类中没有的方法时，用具体工厂类return返回的具体产品类的对象是无法调用这些方法的，只有在创建具体对象后，调用具体对象中new该具体产品类的那个方法时强制转换成该具体产品类的对象才可以调用。</p>
<h3 id="1-1-简单工厂模式"><a href="#1-1-简单工厂模式" class="headerlink" title="1.1 简单工厂模式"></a>1.1 简单工厂模式</h3><p>简单工厂模式其实并不算是一种设计模式，更多的时候是一种编程习惯。</p>
<p>定义：定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口</p>
<p>适用场景：</p>
<p>其实由定义也大概能推测出其使用场景，首先由于只有一个工厂类，所以工厂类中创建的对象不能太多，否则工厂类的业务逻辑就太复杂了，其次由于工厂类封装了对象的创建过程，所以客户端应该不关心对象的创建。总结一下适用场景：</p>
<p>(1)需要创建的对象较少。</p>
<p>(2)客户端不关心对象的创建过程。</p>
<p>简单工厂模式所具有的组件：</p>
<p>1.抽象的产品类(可以是接口或者抽象类，接口是更高层的抽象)</p>
<p>2.各种具体的产品类(继承于抽象产品类)</p>
<p>3.一个具体的工厂类(含有一个方法，根据传入的产品名称，new出对应产品的对象实例并返回)</p>
<p>4.Client客户端测试类(main函数)</p>
<p>实例：创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图。</p>
<p>因为每个图形都会有个draw()，为了减少代码冗余和代码的复用性，我们将其抽象为一个Shape的抽象产品类，该类中有一个抽象的方法draw().</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or定义成抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是具体的产品类，每种图形都实现Shape接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleShape</span>:<span class="type">Shape&#123; //Kotlin中当继承接口时只需Shape，继承类时则要Shape</span></span>()</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">          println(<span class="string">"draw:CircleShape"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleShape</span>:<span class="type">Shape&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"draw:TriangleShape"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正方形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectShape</span>:<span class="type">Shape&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"draw:RectShape"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂的具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> getShape:<span class="title">Shape</span><span class="params">(name:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">var</span> shape:Shape?=<span class="literal">null</span></span><br><span class="line">       <span class="keyword">when</span>(name)&#123;</span><br><span class="line">           <span class="string">"circle"</span>-&gt;shape=CircleShape()</span><br><span class="line">           <span class="string">"rect"</span>-&gt;shape=RectShape()</span><br><span class="line">           <span class="string">"triangle"</span>-&gt;shape=TrilangleShape()</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shape</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client客户端：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shape:Shape=ShapeFactory.getShape(<span class="string">"circle"</span>)</span><br><span class="line">  <span class="keyword">var</span> shape1:Shape=ShapeFactory.getShape(<span class="string">"rect"</span>)</span><br><span class="line">  <span class="keyword">var</span> shape2:Shape=ShapeFactory.getShape(<span class="string">"triangle"</span>)</span><br><span class="line">    </span><br><span class="line">   shape.draw()</span><br><span class="line">   shape1.draw()</span><br><span class="line">   shape2.draw()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h3><p>工厂方法模式是简单工厂的仅一步深化，在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p>
<p>定义：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类，表明在具体的子类工厂中创建某个具体的产品。</p>
<p>适用场景：</p>
<p>1.一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，客户端需要知道创建具体产品的工厂类。</p>
<p>2.一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏</p>
<p>3.将创建对的任务委托给多个工厂子类中的某一个，客户端在使用时间可以无需关心是哪个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p>工厂模式功能类编制步骤：</p>
<p>1.定制抽象产品接口(or抽象类)</p>
<p>2.定制具体产品子类(继承抽象产品类)</p>
<p>3.定制抽象工厂类(or接口)</p>
<p>4.定制具体工厂子类</p>
<p>实例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Reader</span></span>&#123; <span class="comment">//抽象产品类</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是各种具体产品类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JpgReader</span>:<span class="type">Reader&#123;  //Jpg图片加载器</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"read jpg"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PngReader</span>:<span class="type">Reader&#123;  //Png图片加载器</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"read png"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GifReader</span>:<span class="type">Reader&#123;  //Gif图片加载器</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"read gif"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个抽象的工厂接口ReaderFactory</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ReaderFactory</span></span>&#123; <span class="comment">//抽象工厂类</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">getReader</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义具体工厂类，根据需求来生产不同的产品</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JpgReaderFactory</span>:<span class="type">ReaderFactory&#123;  //Jpg加载器工厂</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> new JpgReader  <span class="comment">//生产Jpg加载器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PngReaderFactory</span>:<span class="type">ReaderFactory&#123;  //Png加载器工厂</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> new PngReader  <span class="comment">//生产Png加载器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GifReaderFactory</span>:<span class="type">ReaderFactory&#123;  //Gif加载器工厂</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> new GifReader  <span class="comment">//生产Gif加载器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在每个工厂类中我们都通过复写的getReader()方法返回各自的图片加载器对象</span></span><br></pre></td></tr></table></figure>

<p>定义Client类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">            <span class="comment">//读取Jpg</span></span><br><span class="line">            <span class="keyword">val</span> factory = JpgReaderFactory()</span><br><span class="line">            factory.getReader().read()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//读取Png</span></span><br><span class="line">            <span class="keyword">val</span> factory1 = PngReaderFactory()</span><br><span class="line">            factory1.getReader().read()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//读取Gif</span></span><br><span class="line">            <span class="keyword">val</span> factory2 = GifReaderFactory()</span><br><span class="line">            factory2.getReader().read()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-抽象工厂模式"><a href="#1-3-抽象工厂模式" class="headerlink" title="1.3 抽象工厂模式"></a>1.3 抽象工厂模式</h3><p>在工厂方法模式中，其实我们有一个潜在的问题，那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的进一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。</p>
<p>适用场景：</p>
<p>1.和工厂方法一样客户端不需要知道它所创建的对象的类。</p>
<p>2.需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。(同属于同一个产品族的产品)</p>
<p>3.系统结构稳定，不会频繁的增加对象。(因为一旦增加就需要修改原有代码，不符合开闭原则)</p>
<p>实例：</p>
<p>穿越火线中有不同种类的枪，我们假设现在存在Ak、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产Ak的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便可以生产M4A1使用的子弹。(Ak工厂生产AK系列产品包括子弹，枪等)，M4A1同理</p>
<p>创建抽象产品接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Gun</span></span>&#123;  <span class="comment">//枪</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shooting</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bullet</span></span>&#123; <span class="comment">//子弹</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体产品类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AK</span> : <span class="type">Gun&#123;</span></span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shooting</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"shooting with Ak"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AK_Bullet</span> : <span class="type">Bullet&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"Load bullets with AK"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M4A1</span> : <span class="type">Gun&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shooting</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"shooting with M4A1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M4A1_Bullet</span> : <span class="type">Bullet&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"Load bullets with M4A1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建抽象工厂类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">produceGun</span><span class="params">()</span></span>:Gun</span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">produceBullet</span><span class="params">()</span></span>:Bullet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体工厂类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AK_Factory</span> : <span class="type">Factory&#123;     //AK系列具体工厂类</span></span></span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produceGun</span><span class="params">()</span></span>:Gun&#123;</span><br><span class="line">              <span class="keyword">return</span> AK()</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produceBullet</span><span class="params">()</span></span>:Bullet&#123;</span><br><span class="line">              <span class="keyword">return</span> AK_Bullet()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M4A11_Factory</span> : <span class="type">Factory&#123;     //M4A11系列具体工厂类</span></span></span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produceGun</span><span class="params">()</span></span>:Gun&#123;</span><br><span class="line">              <span class="keyword">return</span> M4A11()</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">produceBullet</span><span class="params">()</span></span>:Bullet&#123;</span><br><span class="line">              <span class="keyword">return</span> M4A11_Bullet()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">   <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">      <span class="meta">@JvmStatic</span></span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">           <span class="keyword">val</span> factory=AK_Factory()</span><br><span class="line">           factory.produceGun().shooting()</span><br><span class="line">           factory.produceBullet().load()</span><br><span class="line">           <span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">              Load bullets with AK</span></span><br><span class="line"><span class="comment">              shooting with AK</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">val</span> factory1=M4A1_Factory()</span><br><span class="line">           factory1.produceGun().shooting()</span><br><span class="line">           factory1.produceBullet().load()</span><br><span class="line">             <span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">              Load bullets with M4A1</span></span><br><span class="line"><span class="comment">              shooting with M4A1</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：也就是说抽象工厂类中，一个具体工厂能够生产某系列的多少个产品，就会有多少个抽象产品类，抽象工厂中就会有多少个返回产品类的抽象方法。具体工厂类就会new多少个不同产品的对象，然后返回。</p>
<h2 id="2-原型模式-创建型模式"><a href="#2-原型模式-创建型模式" class="headerlink" title="2.原型模式(创建型模式)"></a>2.原型模式(创建型模式)</h2><h3 id="2-1意图"><a href="#2-1意图" class="headerlink" title="2.1意图"></a>2.1意图</h3><p>软件系统中，某些对象的创建过程可能是复杂的，可能会花费很多时间和资源。但是这些对象我们可能需要频繁的创建，那么每次通过new来创建对象是不合理的，因为这意味着我们每次都要调用构造方法来实例化对象。我们可以通过已有的对象，进行克隆的方式，对已有的对象进行复制，从而得到一个新的对象。</p>
<h3 id="2-2使用场景"><a href="#2-2使用场景" class="headerlink" title="2.2使用场景"></a>2.2使用场景</h3><p>1.资源优化场景</p>
<p>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等。</p>
<p>2.性能和安全要求的场景</p>
<p>通过new产生一个对象需要非常繁琐的数据准备或访问权限。</p>
<p>3.一个对象多个修改者的场景</p>
<p>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</p>
<p>注：clone方法并不是Cloneable中的，而是Object中的方法，Cloneable是一个标识接口，它表明这个类的对象是可以拷贝的。如果没有实现Cloneable接口却调用了clone()函数将抛出异常。并且cloneable是代表prototype角色。</p>
<h3 id="2-3原型模型的UML图"><a href="#2-3原型模型的UML图" class="headerlink" title="2.3原型模型的UML图"></a>2.3原型模型的UML图</h3><p><img src="https://s1.ax1x.com/2020/06/06/tcNgVU.png" alt=""></p>
<p>其中Prototype一般指cloneable，而ConcretePrototype则指需要被clone的具体类。</p>
<h3 id="2-4-原型模型的浅拷贝和深拷贝"><a href="#2-4-原型模型的浅拷贝和深拷贝" class="headerlink" title="2.4 原型模型的浅拷贝和深拷贝"></a>2.4 原型模型的浅拷贝和深拷贝</h3><p>注意：通过clone拷贝对象的时候并不会执行构造函数。如果在构造函数中有需要一些特殊的初始化，在使用Cloneable实现拷贝的时候，需要注意这一点。</p>
<p>浅拷贝：</p>
<p>上述原型模式的实例其实是一个浅拷贝，也叫影子拷贝，这种拷贝实际上并不是将原始文档的所有字段都重新构造一份，而是将副本文档的字段引用原始文档的字段。 </p>
<img src="https://s1.ax1x.com/2020/06/06/tcx4f0.png" style="zoom:80%;" />

<p>深拷贝：</p>
<p>两个对象之间没有任何瓜葛，即当clone后的对象，和被clone的对象之间是没有关系的，当两个中的某一个被修改的时候，另一个是不会被影响的，对于引用类型的字段也要采用拷贝的形式，而不是单纯引用的形式，这就是深拷贝。</p>
<img src="C:\Users\PXN\AppData\Roaming\Typora\typora-user-images\image-20200606233712053.png" style="zoom:80%;" />

<p>引用类型成员变量和值类型成员变量</p>
<img src="https://s1.ax1x.com/2020/06/06/tczduF.png" style="zoom: 80%;" />



<h2 id="3-桥接模式-结构型模式"><a href="#3-桥接模式-结构型模式" class="headerlink" title="3.桥接模式(结构型模式)"></a>3.桥接模式(结构型模式)</h2><h3 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h3><p>桥接模式是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦</p>
<p>试想一下，当我们在绘画时需要大中小三种型号的画笔，并且能绘制12种颜色。当我们选择蜡笔时，为了满足这个需求，我们需要12*3=36支蜡笔。而同样的情况，如果我们选择了油彩笔时，我们仅需要3支不同型号的油彩笔，配合12种不同的颜料就可以了，总共需要3+12=15个物品。而且当我们需要增加一种型号的画笔并且也需要12种颜色，蜡笔需要增加12支，而油彩笔仅需要增加一支不同型号的笔就行。为什么同样一个需求，选择不同的画笔会有不同的结果呢？</p>
<p>这里我们注意到绘画需求中对画笔有两个属性的需求，型号与颜色，这两个属性都是可变可拓展的，选择蜡笔每一支蜡笔上这两个属性都非常明确，这就导致了两种属性有多少中组合，我们就需要多少支蜡笔。而相对的，选择油彩笔时，这两个属性是分开的，油彩笔仅仅具有型号的属性，而颜色的属性由颜料提供。</p>
<p>这就是桥接模式最生动的演示，当我们在软件开发时，某一个类存在两个独立变化的维度时，通过桥接模式，可以将这两个维度分离出来，使两者可以单独扩展变化，让系统更符合”单一职责”原则。</p>
<h3 id="3-2桥接模式的UML图"><a href="#3-2桥接模式的UML图" class="headerlink" title="3.2桥接模式的UML图"></a>3.2桥接模式的UML图</h3><p><img src="https://s1.ax1x.com/2020/06/07/tgXLan.png" alt=""></p>
<p>1.Abstraction(抽象类)：用于定义抽象类的接口，它一般抽象类而不是接口，其中定义了一个Implementor(实现类接口)类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</p>
<p>2.RefinedAbstraction(扩充抽象类)：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstration中可以调用在Implementor中定义的业务方法。</p>
<p>3.Implementor(实现类接口)：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可能会做更多更复杂的操作。一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</p>
<p>4.ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</p>
<p>具体到我们前面的例子，Abstraction对应的就是油彩笔的抽象对象，具有型号这个属性，RefinedAbstraction对应的就是具体三种型号的油彩笔，Implementor对应的就是颜料的抽象对象，ConcreteImplementor对应的就是具体的有不同颜色的颜料。</p>
<h3 id="3-3-实例"><a href="#3-3-实例" class="headerlink" title="3.3 实例"></a>3.3 实例</h3><p>市面上有很多种笔，比如铅笔、黑色的圆柱笔和红色的圆柱笔等等，也有很多种类型的纸，比如考试的卷子用的纸，报纸用的纸等等，一般来说，报纸上的字颜色是黑色的，这里我们就用黑色的圆珠笔进行书写，考试卷子上的打分字颜色是红色的，这里我们就用红色的圆珠笔来进行书写。笔类和纸类相互独立，但是在纸上写字又将它们关联起来，这里我们就可以使用桥接模式。</p>
<p>实现步骤如下：</p>
<p>1.定义一个抽象笔类的接口</p>
<p>2.定义具体红笔和黑笔的类，实现抽象笔类的接口</p>
<p>3.定义一个抽象纸类，并将抽象笔类的接口作为成员变量，并定义抽象的writing()方法</p>
<p>4.定义卷子纸盒新闻纸类，继承纸类并实现writing()方法</p>
<p>5.Client类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pen</span></span>&#123;   <span class="comment">//抽象接口类，一边桥</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedPen</span>:<span class="type">Pen&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"红色的字"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackPen</span>:<span class="type">Pen&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"黑色的字"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Paper</span></span>(<span class="keyword">val</span> Pen pen)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setPen</span><span class="params">(Pen pen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pen=pen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">writing</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExaminationPaper</span>:<span class="type">Paper</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        pen.write()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span>:<span class="type">Paper</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        pen.write()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">            Paper paper=ExaminationPaper()</span><br><span class="line">            paper.setPen(RedPen())</span><br><span class="line">            paper.writing()</span><br><span class="line">            </span><br><span class="line">            Paper paper2=NewsPaper()</span><br><span class="line">            paper2.setPen(BlackPen())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-适配器模式-结构型模式"><a href="#4-适配器模式-结构型模式" class="headerlink" title="4.适配器模式(结构型模式)"></a>4.适配器模式(结构型模式)</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>适配器模式是作为两个不兼容的接口之间的桥梁。这种模型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>简单来说就是通过某个接口将不兼容的两个类进行兼容，俗称转换器。生活比较典型的例子是电器的电压，美国的电压是110v左右，而中国的电压普遍是220v，如果我们想在国内用美国或日本的电器，则需要一个转换器，将110v转换成220v。还有一个很典型例子就是曾经的万能充，基本可以充各种手机的电池</p>
<p>这里我们用一个简单的示例来进行说明。 某个视频播放器，只能播放MP4格式的视频，但是主流的视频格式除了MP4，还有AVI、RVMB等，这时就有个软件，格式工厂用于对视频格式的转换(适配器)，从而进行播放视频。这时我们就可以使用适配器模式来进行完成该代码的编写</p>
<h3 id="4-2-类适配器模式"><a href="#4-2-类适配器模式" class="headerlink" title="4.2 类适配器模式"></a>4.2 类适配器模式</h3><p>主要通过继承来实现适配器功能</p>
<p>用视频播放器的例子，需要完成一下步骤：</p>
<p>1.建立MP4、AVI、RVMB视频格式的接口：</p>
<p>2.建立一个视频播放器的类实现MP4视频格式的类；</p>
<p>3.编写一个格式工厂类，将AVI、RVMB等格式的视频文件转化成MP4格式的文件。</p>
<p>4.播放这些视频</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Mp4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">playMp4</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Avi</span></span>&#123; <span class="comment">//被适配类</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">playAvi</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Rvmb</span></span>&#123;<span class="comment">//被适配类</span></span><br><span class="line">     <span class="function"><span class="keyword">fun</span> <span class="title">playRvmb</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span>:<span class="type">Mp4&#123; //类似作业中的Robot</span></span></span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">playMp4</span><span class="params">()</span></span>&#123;</span><br><span class="line">          println(<span class="string">"播放MP4格式的视频文件"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormatFactory</span>:<span class="type">VideoPlayer</span></span>(),Avi&#123;    <span class="comment">//类适配，FormatFactory是适配器</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">playAvi</span><span class="params">()</span></span>&#123;</span><br><span class="line">           playMap4()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">   <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">      <span class="meta">@JvmStatic</span></span><br><span class="line">      <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">           Mp4 mp4 = VideoPlayer()</span><br><span class="line">           mp4.playMp4()</span><br><span class="line">           Avi avi = FormatFactory()</span><br><span class="line">           avi.playAvi()</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           运行结果：</span></span><br><span class="line"><span class="comment">           播放Mp4格式的视频文件</span></span><br><span class="line"><span class="comment">           播放Mp4格式的视频文件</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码以及运行结果，我们可以得到想要的结果了，如果还有新增的视频格式，也需要使用该视频播放器播放的话，只需要在增加一个接口以及格式工厂类就可以了。</p>
<h3 id="4-3对象适配器模式"><a href="#4-3对象适配器模式" class="headerlink" title="4.3对象适配器模式"></a>4.3对象适配器模式</h3><p>通过组合来实现适配器功能，所以这里我们只需将格式工厂中继承改为创建对象即可</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被适配类上面定义了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormatFactroy2</span></span>(<span class="keyword">var</span> mp4:Mp4) : Rvmb&#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">playRvmb</span><span class="params">()</span></span>&#123;</span><br><span class="line">          mp4.playMp4()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> rvmb:Rvmb = new FormatFactory2(VideoPlayer())</span><br><span class="line">    rvmb.playRvmb()</span><br><span class="line">    <span class="comment">//播放Mp4格式的视频文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种适配器模式中，都实现了该功能，不过在这里推荐使用对象适配器模式，相比类适配器模式，它更加灵活，也符合设计原则中的合成复用原则：</p>
<p>尽量使用合成 /聚合的方式，而不是使用继承。</p>
<h3 id="4-4适配器模式的优点和缺点"><a href="#4-4适配器模式的优点和缺点" class="headerlink" title="4.4适配器模式的优点和缺点"></a>4.4适配器模式的优点和缺点</h3><p>优点：</p>
<p>提升了类的复用和灵活度</p>
<p>缺点：</p>
<p>使用过多，系统会比较杂乱，难以把握</p>
<h2 id="5-组合模式"><a href="#5-组合模式" class="headerlink" title="5.组合模式"></a>5.组合模式</h2><h3 id="5-1-组合模式定义"><a href="#5-1-组合模式定义" class="headerlink" title="5.1 组合模式定义"></a>5.1 组合模式定义</h3><p>整体-部分(Part-Whole)模式/树结构模式，它的宗旨是通过将单个对象(叶子节点)和组合对象(树枝节点/容器)用相同的接口进行表示，使得客户对单个对象和组合对象的使用具有一致性。</p>
<p><img src="https://s1.ax1x.com/2020/06/07/t26GNR.png" alt=""></p>
<h3 id="5-2组合模式优点和缺点"><a href="#5-2组合模式优点和缺点" class="headerlink" title="5.2组合模式优点和缺点"></a>5.2组合模式优点和缺点</h3><p>优点：</p>
<ol>
<li>屏蔽了对象系统的层次差异性，将客户代码与复杂的容器对象解耦</li>
<li>可以很方便地增加树枝节点和叶子节点对象，并对现有类库无侵入，符合开闭原则(对扩展开放，对修改关闭)。</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果类系统（树形结构）过于庞大，客户端仍需花费时间理清类之间的层次关系。</li>
<li>具体实现上违背了设计模式的接口隔离原则(透明组合模式违背)或依赖倒置原则(安全组合模式违背)。</li>
</ol>
<h3 id="5-3适用场景"><a href="#5-3适用场景" class="headerlink" title="5.3适用场景"></a>5.3适用场景</h3><p>表示对象的部分-整体层次结构，希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构中的所有对象。</p>
<h3 id="5-4透明组合模式和安全组合模式"><a href="#5-4透明组合模式和安全组合模式" class="headerlink" title="5.4透明组合模式和安全组合模式"></a>5.4透明组合模式和安全组合模式</h3><p>透明组合模式：</p>
<p>透明组合模式中，抽象构件角色中声明了所有用于管理成员对象的方法，譬如在示例中 <code>Component</code> 声明了 <code>add</code>、<code>remove</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 <code>add()</code>、<code>remove()</code> 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>
<p>安全组合模式：</p>
<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在容器构件 <code>Composite</code> 类中声明并实现这些方法。</p>
<p>安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p>
<p>在实际应用中 <code>java.awt</code> 和 <code>swing</code> 中的组合模式即为安全组合模式。</p>
<h3 id="5-5示例"><a href="#5-5示例" class="headerlink" title="5.5示例"></a>5.5示例</h3><p>实现一个简单的目录树，有文件夹和文件两种类型，首先需要一个抽象构件类，声明了文件夹类和文件类需要的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//采用透明组合模式，并定义了错误处理，防止叶子类调用出错</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持获取名称操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持添加操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持删除操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持打印操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持获取内容操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个文件夹类 Folder，继承 Component，定义一个 <code>List&lt;Component&gt;</code> 类型的componentList属性，用来存储该文件夹下的文件和子文件夹，并实现 getName、add、remove、print等方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Folder</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; componentList = <span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">    <span class="keyword">public</span> Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Folder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.componentList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.componentList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.level == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.level = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.level; i++) &#123;</span><br><span class="line">            prefix += <span class="string">"\t- "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Component component : <span class="keyword">this</span>.componentList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (component <span class="keyword">instanceof</span> Folder)&#123;</span><br><span class="line">                ((Folder)component).level = <span class="keyword">this</span>.level + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(prefix);</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.level = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件类 File，继承Component父类，实现 getName、print、getContent等方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Folder DSFolder = <span class="keyword">new</span> Folder(<span class="string">"设计模式资料"</span>);</span><br><span class="line">        File note1 = <span class="keyword">new</span> File(<span class="string">"组合模式笔记.md"</span>, <span class="string">"组合模式组合多个对象形成树形结构以表示具有 \"整体—部分\" 关系的层次结构"</span>);</span><br><span class="line">        File note2 = <span class="keyword">new</span> File(<span class="string">"工厂方法模式.md"</span>, <span class="string">"工厂方法模式定义一个用于创建对象的接口，让子类决定将哪一个类实例化。"</span>);</span><br><span class="line">        DSFolder.add(note1);</span><br><span class="line">        DSFolder.add(note2);</span><br><span class="line"></span><br><span class="line">        Folder codeFolder = <span class="keyword">new</span> Folder(<span class="string">"样例代码"</span>);</span><br><span class="line">        File readme = <span class="keyword">new</span> File(<span class="string">"README.md"</span>, <span class="string">"# 设计模式示例代码项目"</span>);</span><br><span class="line">        Folder srcFolder = <span class="keyword">new</span> Folder(<span class="string">"src"</span>);</span><br><span class="line">        File code1 = <span class="keyword">new</span> File(<span class="string">"组合模式示例.java"</span>, <span class="string">"这是组合模式的示例代码"</span>);</span><br><span class="line"></span><br><span class="line">        srcFolder.add(code1);</span><br><span class="line">        codeFolder.add(readme);</span><br><span class="line">        codeFolder.add(srcFolder);</span><br><span class="line">        DSFolder.add(codeFolder);</span><br><span class="line"></span><br><span class="line">        DSFolder.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">设计模式资料</span><br><span class="line">	- 组合模式笔记.md</span><br><span class="line">	- 工厂方法模式.md</span><br><span class="line">	- 样例代码</span><br><span class="line">	- 	- README.md</span><br><span class="line">	- 	- src</span><br><span class="line">	- 	- 	- 组合模式示例.java</span><br></pre></td></tr></table></figure>



<h2 id="6-单例模式"><a href="#6-单例模式" class="headerlink" title="6. 单例模式"></a>6. 单例模式</h2><p>我们在日常的工作中经常需要在应用程序中保持一个唯一的实例，如：IO处理，数据库操作等，由于这些对象都要占用重要的系统资源，所以我们必须限制这些实例的创建或始终使用一个公用的实例，这就是我们今天要介绍的-单例模式</p>
<h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>单例模式，又称单件模式或者单子模式，指的是一个类只有一个实例，并且提供一个全局访问点。</p>
<h3 id="6-2实现思路"><a href="#6-2实现思路" class="headerlink" title="6.2实现思路"></a>6.2实现思路</h3><p>在单例的类中设置一个private静态变量instance，instance类型为当前类，用来持有单例唯一的实例，将(无参数)构造器设置为private，避免外部使用new构造多个实例。提供一个public的静态方法，如getInstance，用来返回该类的唯一实例instance。</p>
<h3 id="6-3-饿汉型-不推荐"><a href="#6-3-饿汉型-不推荐" class="headerlink" title="6.3 饿汉型(不推荐)"></a>6.3 饿汉型(不推荐)</h3><p>名字由来：因为随着类加载而加载，显得很”急迫”，所以称之为饿汉型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HazardousTypeSingleton</span> </span>&#123;<span class="comment">//HeadFirst 核心代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> App APP = <span class="keyword">new</span> App();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HazardousTypeSingleton</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载时已初始化，不会有多线程的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> App <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"APP - 饿汉型模式"</span>);</span><br><span class="line">        <span class="keyword">return</span> APP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉型指的是单例的实例在类装载时进行创建。由于是在类装载时候创建的，所以可以保证线程安全。如果单例类的构造方法中没有包含过多的操作处理，饿汉型其实是可以接受的。</p>
<p>评价：这样的写法和全局变量没有本质区别，不推荐。</p>
<p>不足：</p>
<p>1.如果构造方法中存在过多的处理，会导致加载这个类时比较慢，可能会引起性能问题。</p>
<p>2.如果使用饿汉型的话，只进行了类的装载，并没有实质的调用，会造成资源的浪费。</p>
<h3 id="6-4懒汉型-不推荐"><a href="#6-4懒汉型-不推荐" class="headerlink" title="6.4懒汉型(不推荐)"></a>6.4懒汉型(不推荐)</h3><p>名字由来：调用时才加载，因此称之为懒汉型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyTypeSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyTypeSingleton</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态私用成员，没有初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> App intance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 直接加synchronized关键字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span>  <span class="keyword">static</span> App <span class="title">getIntance</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"APP - 懒汉型模式"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == intance) &#123;</span><br><span class="line">            intance = <span class="keyword">new</span> App();</span><br><span class="line">            <span class="keyword">return</span> intance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉型指的是单例实例在第一次使用时进行创建。这种情况下避免了上面饿汉型可能遇到的问题。</p>
<p>但是如果在多线程并发的情况下就会存在问题，因为它们存在共同的[临界资源]instance，比如线程A进入null == instance这段代码块，而在A线程未创建完成实例时，这时候线程B也进入了该代码块，必然会造成两个实例的产生。</p>
<p>因此多线程这里要考虑加锁同步。如果使用synchronized修饰getInstance方法后必然会导致性能下降，而且getInstance是一个被频繁调用的方法。虽然这种方法能解决问题，但是不推荐使用在多线程的情况下。</p>
<p>评价：这样写有延迟加载的功能，但是加了一个synchronized大锁，因此多线程环境下效率较低。</p>
<h3 id="6-5-懒汉型之双重锁校验-推荐"><a href="#6-5-懒汉型之双重锁校验-推荐" class="headerlink" title="6.5 懒汉型之双重锁校验(推荐)"></a>6.5 懒汉型之双重锁校验(推荐)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyTypeSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile关键字修饰，防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> App app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * Double Check Lock（DCL） 双重锁校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> App <span class="title">getInstanceByDCL</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == app) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyTypeSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == app) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"APP - 饿汉模式DCL 双重锁校验"</span>);</span><br><span class="line">                    app = <span class="keyword">new</span> App();</span><br><span class="line">                    <span class="keyword">return</span> app;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先进入该方法时进行 null == app检查，如果第一次检查通过，即没有实例创建，则进入synchronized控制的同步块，并再次检查实例是否创建，如果仍未创建，则创建该实例。</p>
<p>双重检查加锁保证了多线程下只创建一个实例，并且加锁代码块只在实例创建之前进行同步。如果实例已经创建后，进入该方法，则不会执行到同步块的代码。</p>
<p>评价：比较推荐的写法，可以保证线程安全，同时具备延时加载的效果。</p>
<h3 id="6-6-静态内部类方式-推荐"><a href="#6-6-静态内部类方式-推荐" class="headerlink" title="6.6 静态内部类方式(推荐)"></a>6.6 静态内部类方式(推荐)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnterTypeSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnterTypeSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类方式，类似饿汉保证天然的线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> App app = <span class="keyword">new</span> App();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> App <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"APP - 静态内部类方式(Holder)"</span>);</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面InnterTypeSingleton类被装载了，app不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化app。想象一下，如果实例化app很消耗资源，我想让它延迟加载，上面这种方式就可以达到这种效果。</p>
<h3 id="6-7-单例模式的优点和缺点"><a href="#6-7-单例模式的优点和缺点" class="headerlink" title="6.7 单例模式的优点和缺点"></a>6.7 单例模式的优点和缺点</h3><p>优点：</p>
<p>1.单例模式会控制其实例对象的数量，从而确保访问对象的唯一性。</p>
<p>2.实例控制：单例模式防止其它对象对自己的实例化，确保所有的对象都访问一个实例。</p>
<p>3.伸缩性：因为由类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</p>
<p>缺点：</p>
<p>1.系统开销。虽然这个系统开销看起来小，但是每次引用这个类实例的时候都要进行实例是否存在的检查。这个问题可以通过静态实例来实现。</p>
<p>2.使用多个类加载器加载单例类，也会导致创建多个实例并存在的问题。</p>
<p>3.使用反射，虽然构造器为非公开，但是在反射面前就不起作用了</p>
<p>4.对象生命周期。因为单例模式没有提出对象的销毁，所以使用时容易造成内存泄漏，例如在Android中在Activity中使用单例，所以我们要额外小心。</p>
<h3 id="6-8-使用场景"><a href="#6-8-使用场景" class="headerlink" title="6.8 使用场景"></a>6.8 使用场景</h3><p>1.系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>
<p>2.不要使用单例模式存取全局变量。这违背了单例模式的用意，最好放到对应类的静态成员中。</p>
<p>3.在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</p>
<h2 id="7-命令模式"><a href="#7-命令模式" class="headerlink" title="7.命令模式"></a>7.命令模式</h2>]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中关键字与修饰符</title>
    <url>/2020/04/16/kotlin%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>kotlin中的修饰符关键字主要分为</p>
<a id="more"></a>

<ul>
<li>类修饰符</li>
<li>成员修饰符</li>
<li>访问权限修饰符</li>
<li>协变逆变修饰符</li>
<li>函数修饰符</li>
<li>属性修饰符</li>
<li>参数修饰符</li>
<li>具体化类型修饰符</li>
</ul>
<p>​                                 表2-1 kotlin中的类修饰符</p>
<table>
<thead>
<tr>
<th align="center">类修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abstract</td>
<td align="center">抽象类</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">不可被继承final类</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">枚举类</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">可继承open类</td>
</tr>
<tr>
<td align="center">annotation</td>
<td align="center">注解类</td>
</tr>
<tr>
<td align="center">scaled</td>
<td align="center">密封类</td>
</tr>
<tr>
<td align="center">data</td>
<td align="center">数据类</td>
</tr>
</tbody></table>
<p>​                               表2-2  kotlin中的成员修饰符</p>
<table>
<thead>
<tr>
<th align="center">成员修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">override</td>
<td align="center">重写函数(方法)</td>
</tr>
<tr>
<td align="center">open</td>
<td align="center">声明函数可被重写</td>
</tr>
<tr>
<td align="center">final</td>
<td align="center">声明函数不可被重写</td>
</tr>
<tr>
<td align="center">abstract</td>
<td align="center">声明函数为抽象函数</td>
</tr>
<tr>
<td align="center">lateinit</td>
<td align="center">延迟初始化</td>
</tr>
</tbody></table>
<p>​                             表2-3 kotlin中的访问权限修饰符</p>
<table>
<thead>
<tr>
<th align="center">访问权限修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">私有，仅当前类可访问</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">当前类以及继承该类的可访问</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">默认值，对外可访问</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="center">整个模块内可访问(模块是指一起编译的一组kotlin源代码文件。例如，一个Maven工程，或Gradle工程，通过Ant任务的一次调用编译的一组文件等)</td>
</tr>
</tbody></table>
<p>​                         表2-4  空调连载中的协变逆变修饰符</p>
<table>
<thead>
<tr>
<th>协变逆变修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>生产者类型修饰符，in T 等价于 ?super T</td>
</tr>
<tr>
<td>out</td>
<td>消费者类型修饰符，out T 等价于 ?extends T</td>
</tr>
</tbody></table>
<p>​                                       表2-5  kotlin中的函数修饰符</p>
<table>
<thead>
<tr>
<th align="center">函数修饰符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tailrec</td>
<td align="left">尾递归</td>
</tr>
<tr>
<td align="center">operator</td>
<td align="left">运算符重载函数</td>
</tr>
<tr>
<td align="center">infix</td>
<td align="left">中缀函数。例如，给Int定义扩展中缀函数 infix fun Int.shl(x:Int): Int</td>
</tr>
<tr>
<td align="center">inline</td>
<td align="left">内联函数</td>
</tr>
<tr>
<td align="center">external</td>
<td align="left">外部函数</td>
</tr>
<tr>
<td align="center">suspend</td>
<td align="left">挂起协程函数</td>
</tr>
</tbody></table>
<p>​                                              表2-6 kotlin中的属性修饰符</p>
<table>
<thead>
<tr>
<th align="center">属性修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">const</td>
<td>常量修饰符</td>
</tr>
</tbody></table>
<p>​                                            表2-7  kotlin中的参数修饰符</p>
<table>
<thead>
<tr>
<th>参数修饰符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vararg</td>
<td>变长参数修饰符</td>
</tr>
<tr>
<td>noinline</td>
<td>不内联参数修饰符，有时，只需要将内联函数的部分参数使用内联Lambda，其他的参数不需要内联，可以使用noinline关键字修饰。例如：inline fun foo(inlined:()-&gt;Unit, noinline notInlined:()-&gt;Unit)</td>
</tr>
<tr>
<td>crossinline</td>
<td>首先，默认内联函数的Lambda表达式参数是允许非局部返回的，即：     fun outterFun(){                                                                                                                                                        innerFun{                                                                                                                                        retuurn   //支持直接返回outterFun                                                             }}                                                                                                               而使用crossinline限制Lambda表达式直接非局部return返回。                    这样做的原因是：                                                                                          一些内联函数可能通用传给它们的不是直接来自函数体，而是来自另一个执行上下文 的Lambda表达式参数，如来自局部对象或嵌套函数。在这种情况下，该Lambda表达式中也是禁止直播return的。为了标识这种情况，该Lambda表达式参数需要用crossinline修饰符标记。</td>
</tr>
</tbody></table>
<p>​                                               表2-8  kotlin中的具体化类型修饰符</p>
<table>
<thead>
<tr>
<th align="center">具体化类型修饰符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reified</td>
<td align="center">具体化类型参数</td>
</tr>
</tbody></table>
<p>一个crossinline代码实例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(<span class="keyword">crossinline</span> body: ()-&gt;<span class="type">Unit</span>)</span></span>&#123;<span class="comment">//内联函数f的body参数是一个Lambda</span></span><br><span class="line">   <span class="keyword">val</span> f=<span class="keyword">object</span>: Runnable&#123;   <span class="comment">//在对象表达式中使用body参数</span></span><br><span class="line">         <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>=body() <span class="comment">//参数标记为crossinline后,return操作将不被允许</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面的修饰符关键字之外，还有一些特殊语义的关键字如表2-9所示。</p>
<p>​                                              表2-9  kotlin中的关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>package</td>
<td>包声明</td>
</tr>
<tr>
<td>as</td>
<td>类型转换</td>
</tr>
<tr>
<td>typealias</td>
<td>类型别名</td>
</tr>
<tr>
<td>class</td>
<td>声明类</td>
</tr>
<tr>
<td>this</td>
<td>当前对象引用</td>
</tr>
<tr>
<td>super</td>
<td>父亲对象引用</td>
</tr>
<tr>
<td>val</td>
<td>声明不可变变量</td>
</tr>
<tr>
<td>var</td>
<td>声明可变变量</td>
</tr>
<tr>
<td>fun</td>
<td>声明函数</td>
</tr>
<tr>
<td>for</td>
<td>for循环</td>
</tr>
<tr>
<td>null</td>
<td>特殊值null</td>
</tr>
<tr>
<td>true</td>
<td>真值</td>
</tr>
<tr>
<td>false</td>
<td>假值</td>
</tr>
<tr>
<td>is</td>
<td>类型判断</td>
</tr>
<tr>
<td>throw</td>
<td>抛出异常</td>
</tr>
<tr>
<td>return</td>
<td>返回值</td>
</tr>
<tr>
<td>break</td>
<td>跳出循环体</td>
</tr>
<tr>
<td>continue</td>
<td>继续下一次循环</td>
</tr>
<tr>
<td>object</td>
<td>单例类声明</td>
</tr>
<tr>
<td>if</td>
<td>逻辑判断if</td>
</tr>
<tr>
<td>else</td>
<td>逻辑判断，结合if使用</td>
</tr>
<tr>
<td>while</td>
<td>while循环</td>
</tr>
<tr>
<td>do</td>
<td>do循环</td>
</tr>
<tr>
<td>when</td>
<td>条件判断</td>
</tr>
<tr>
<td>interface</td>
<td>接口声明</td>
</tr>
<tr>
<td>file</td>
<td>文件</td>
</tr>
<tr>
<td>field</td>
<td>成员</td>
</tr>
<tr>
<td>property</td>
<td>属性</td>
</tr>
<tr>
<td>receiver</td>
<td>接收者</td>
</tr>
<tr>
<td>param</td>
<td>参数</td>
</tr>
<tr>
<td>setparam</td>
<td>设置参数</td>
</tr>
<tr>
<td>delegate</td>
<td>委托</td>
</tr>
<tr>
<td>import</td>
<td>导入包</td>
</tr>
<tr>
<td>where</td>
<td>where条件</td>
</tr>
<tr>
<td>by</td>
<td>委托类或属性</td>
</tr>
<tr>
<td>get</td>
<td>get函数</td>
</tr>
<tr>
<td>set</td>
<td>set函数</td>
</tr>
<tr>
<td>constructor</td>
<td>构造函数</td>
</tr>
<tr>
<td>init</td>
<td>初始化代码块</td>
</tr>
<tr>
<td>try</td>
<td>异常捕获</td>
</tr>
<tr>
<td>catch</td>
<td>异常捕获，结合try使用</td>
</tr>
<tr>
<td>finally</td>
<td>异常最终执行代码块</td>
</tr>
<tr>
<td>dynamic</td>
<td>动态的</td>
</tr>
<tr>
<td>typeof</td>
<td>类型定义，预留用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习</title>
    <url>/2020/04/03/vue%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="今天你学Vue了吗-1"><a href="#今天你学Vue了吗-1" class="headerlink" title="今天你学Vue了吗?(1)"></a>今天你学Vue了吗?(1)</h1><a id="more"></a>

<p>  作为程序员中的小小白，对vue敬仰已久。这几天心血来潮，想学习一些基础的vue语法，请大佬们赐教。(vue是MVVM(model-view-viewmodel)模式)</p>
<h2 id="如何使用vue呢？"><a href="#如何使用vue呢？" class="headerlink" title="如何使用vue呢？"></a>如何使用vue呢？</h2><h3 id="1-可以直接在-html-文件中，引用一下代码使用Vue："><a href="#1-可以直接在-html-文件中，引用一下代码使用Vue：" class="headerlink" title="1. 可以直接在.html 文件中，引用一下代码使用Vue："></a>1. 可以直接在.html 文件中，引用一下代码使用Vue：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-还有更多安装Vue的方式。但不推荐新手直接使用-vue-cli，尤其不熟悉基于Node-js-的构建工具。"><a href="#2-还有更多安装Vue的方式。但不推荐新手直接使用-vue-cli，尤其不熟悉基于Node-js-的构建工具。" class="headerlink" title="2.还有更多安装Vue的方式。但不推荐新手直接使用 vue-cli，尤其不熟悉基于Node.js  的构建工具。"></a>2.还有更多安装Vue的方式。但不推荐新手直接使用 vue-cli，尤其不熟悉基于Node.js  的构建工具。</h3><h2 id="Coding-Show："><a href="#Coding-Show：" class="headerlink" title="Coding Show："></a>Coding Show：</h2><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM的系统：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">'#app'</span></span><br><span class="line">   data: &#123;</span><br><span class="line">     message: <span class="string">'Hello Vue!'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">Hello Vue!</span><br></pre></td></tr></table></figure>

<p>vue的数据绑定。数据绑定是将数据和视图相关联，当数据发生变化时，可以自动更新视图。</p>
<p>以上代码便是数据绑定的例子。是文本插值，是最基本的方式，例子中的将会被相应的数据对象替换。当text的值变化时，文本的内容也会联动地发生变化。有时候只需要渲染一次数据，后续数据变化不再关心，可以通过“*”实现，代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span></span></span><br><span class="line"><span class="tag">   &#123;&#123;*<span class="attr">message</span>&#125;&#125;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>双大括号标签会把里面的值全部当作字符串来处理。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
